\documentclass[titlepage,12pt,twoside]{article}
%\usepackage[a4paper, inner=25mm, outer=20mm, top=20mm, bottom=20mm, bindingoffset=0mm]{geometry}

\raggedbottom
\pagenumbering{arabic}
\textheight=240mm
\textwidth=150mm
\parskip=0pt plus3pt
\marginparwidth=22mm
\marginparsep=3mm

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{4}

\usepackage{filecontents}
\usepackage{graphicx}
\graphicspath{{/Users/laci/Schule/Diplomarbeit_GitHub/LATEX_DOKU_DA/src}}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{xcolor}
\usepackage{caption}
\usepackage[autostyle]{csquotes}
\usepackage{circuitikz}
\usepackage{amsmath}
\usepackage{textgreek}
\usepackage{siunitx}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[margin=2.2cm]{geometry}
\usepackage[none]{hyphenat}
\usepackage{float} % für Positionierungsoption [H] beie Tables, figures,...
\usepackage{hyperref} %Für URLS
\usepackage{listings} %Für Codezeilen
\usepackage{titlesec} %Für Buchstaben als Überschriftsnummerierung
\usepackage{enumitem}
\usepackage{pdfpages} %Für A3-Seiten
\usepackage{siunitx}
\lstset{language=C++}
\setlength{\fboxsep}{5pt} % Ändere die Rahmenbreite nach Bedarf
\usepackage{ragged2e}
\justifying
\usepackage{microtype}
\usepackage[style=authoryear,backend=biber]{biblatex}
%\usepackage[style=apa]{biblatex}
\addbibresource{Literatur.bib}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\setlength{\headheight}{20pt}
\fancyhead[LE,RO]{\rightmark}

\fancyfoot[L]{\small{Al-Maytah, Schweitzer, Szabo}}
\fancyfoot[C]{}
\fancyfoot[R]{\arabic{page}}

%\usepackage[nottoc]{tocbibind}
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%==DOKUMENTBEGINN==========================================================

\begin{document}

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%==TITELSEITE==============================================================

\begin{titlepage}

	\begin{center}
	\begin{tabular}{p {2.4cm} p{10.8cm} p{2cm}}
	\includegraphics[width=0.16\textwidth,page=1]{/Users/laci/Schule/Diplomarbeit_GitHub/LATEX_DOKU_DA/src/TGM_logo.pdf}& \large{{\textbf{HTBLVA Technologisches Gewerbemuseum}}}\par\par\centering{\scriptsize{\textbf{Höhere Lehranstalt für Elektronik und Technische Informatik}}}&\includegraphics[width=0.12\textwidth,page=1]{/Users/laci/Schule/Diplomarbeit_GitHub/LATEX_DOKU_DA/src/HTL.png}\\
	\end{tabular}
	\noindent\rule{1.1\textwidth}{1pt} 
	\end{center}
	
	\begin{center}
	
	\vspace*{1cm}
	\LARGE
	\textbf{DIPLOMARBEIT}
	
	\vspace{1.7cm}
	\normalsize
	Gesamtprojekt\\
	\LARGE
	\textbf{RoboGlove - Bionische Hand}\\
	\end{center}
	
	\vspace{1.7cm}
	
	\normalsize 
	\large
	
	\begin{center}
		\begin{tabular}{llr} 
			\multicolumn{3}{c}{\large{\textbf{3D-Druck, Mechanik, User-Interface Programmierung}}} \\
			\large{Amir Al-Maytah} & \hspace{0.3cm}\large{5BHEL}\hspace{0.3cm} &  \large{Betreuer: Prof. Dipl.-Ing. Christoph Diemberger}\\
			\\
			\multicolumn{3}{c}{\large{\textbf{Mikrokontroller-Programmierung, Testmanagement, Gesamtintegration}}} \\
			\large{Fabian Schweitzer} & \hspace{0.3cm}\large{5BHEL}\hspace{0.3cm} &  \large{Betreuer: Prof. Dipl.-Ing. Christoph Diemberger}\\
			\\
			\multicolumn{3}{c}{\large{\textbf{Hardwareentwicklung, PCB-Design, Projektleitung}}} \\
			\large{Ladislaus Szabo} & \hspace{0.3cm}\large{5BHEL}\hspace{0.3cm} &  \large{Betreuer: Prof. Dipl.-Ing. Christoph Diemberger}\\
			\\
		\end{tabular}
	\end{center}
	
	
	
	\vspace{1.5cm}
	\normalsize
	Ausgeführt im Schuljahr 2023/2024\\
	\vspace{0.7cm}
	\noindent\rule{\textwidth}{1pt}
	\begin{tabular}{lr}
	Abgabevermerk:\\
	\\
	\\
	Datum: 04.04.2024 &\hspace{4cm}   übernommen von:\\
	\end{tabular}
	
	\end{titlepage}
	
	\newpage
	\thispagestyle{empty}
	\clearpage\mbox{}\clearpage

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%==EIDESSTATTLICHE-ERKLÄRUNG===============================================

\thispagestyle{empty}
	
\begin {center}
	\begin{tabular} {p{3cm} p{6cm} p{1cm}}
  & 
  & 
  \vspace{1mm}\centering{\includegraphics[width=0.2\textwidth,page=1]{/Users/laci/Schule/Diplomarbeit_GitHub/LATEX_DOKU_DA/src/TGM_logo.pdf}}\\ 
\end{tabular}

\hspace{40mm}

\color{white}

\color{blue}	
\Large{\bfseries{Eidesstattliche Erklärung}}	
\color{black}	

\end {center}

\hspace{10mm}

Hiermit versichere ich, dass ich die vorliegende Arbeit selbstständig verfasst und keine anderen Hilfsmittel als die angegebenen benützt habe. Die Stellen, die anderen Werken (gilt ebenso für Werke
aus elektronischen Datenbanken oder aus dem Internet) wörtlich oder sinngemäß entnommen sind, habe ich unter Angabe der Quelle und Einhaltung der Regeln wissenschaftlichen Zitierens kenntlich
gemacht. Diese Versicherung umfasst auch in der Arbeit verwendete bildliche Darstellungen, Tabellen, Skizzen und Zeichnungen. Für die Erstellung der Arbeit habe ich auch folgende Hilfsmittel generativer
KI-Tools (ChatGPT, Microsoft Copilot) zu folgendem Zweck verwendet: [Syntaxhilfen bei der Programmierung, allgemeine Informationsquelle]. Die verwendeten Hilfsmittel wurden vollständig und wahrheitsgetreu inkl. Produktversion 
und Prompt ausgewiesen. \\

\begin{tabular}{p{7cm}}
\\
\vspace{3cm}
------------------------------------------------\\
Amir Al-Maytah\\
\vspace{3cm}
------------------------------------------------\\
Fabian Schweitzer\\
\vspace{3cm}
------------------------------------------------\\
Ladislaus Szabo\\


\end{tabular}

\newpage
\thispagestyle{empty}
\clearpage\mbox{}\clearpage

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%==DANKSAGUNG==============================================================

\thispagestyle{empty}

\begin{center}
\Large{\textbf{Danksagung}} 
\end{center}

\hspace{2cm}
\\
Wir möchten uns herzlich bei unserem Betreuer Dipl.-Ing. Christoph Diemberger bedanken, 
der uns bei diesem Projekt grundlegend unterstützt und motiviert hat. \\
\\
Des Weiteren gilt unser Dank auch Fachlehrer Robert Offner und allen anderen Lehrpersonen, 
die uns in der Werkstatt betreut und geholfen haben. \\
\\
Wir danken allen, die uns im Rahmen dieses Projekts zur Seite standen.      

\newpage
\thispagestyle{empty}
\clearpage\mbox{}\clearpage

%--------------------------------------------------------------------------
%==========================================================================
%== Diploma Thesis Englisch ===============================================

\thispagestyle{empty}
	
\begin {center}
\begin{tabular} {|p {3cm}|p{8cm}|p{4.55cm}|}
 \hline 
\vspace{1mm}
 \centering{\includegraphics[width=0.18\textwidth,page=1]{/Users/laci/Schule/Diplomarbeit_GitHub/LATEX_DOKU_DA/src/TGM_logo.pdf}} &
\centering{\normalsize{\textbf{HTBLVA Wien 20}}\par\small{\textbf{College of}\par Electronic and Technical Information Technology}} &
	\small{\bfseries{Diploma\par Exam}}\\ 
	\hline
\end{tabular}

\vspace{5mm}
\Large{\textbf{DIPLOMA THESIS\\}}
\vspace{1mm}
\small{\textbf{DOCUMENTATION\\}}
\vspace{5mm}  

	\begin{tabular} {|p {6cm}|p{10cm}|}
	 \hline 
		\bfseries{\small{Authors}} & \small{Amir Al-Maytah, Fabian Schweitzer, Ladislaus Szabo}\\
	 \hline
	  \bfseries{\small{From\par Academic year}} & \small{5BHEL 2023/2024}\\
	 \hline 
	  \bfseries{\small{Topic}} & \small{RoboGlove - Bionische Hand}\\ 
	 \hline 
	  \bfseries{\small{CO-operation partners}} & \small{}\\ 
	 \hline
	\multicolumn{2}{l}{\large{ \textbf{}}}\\
	 \hline
	  \bfseries{\small{Assignment of tasks}} & \small{As part of a feasibility study, a robotic hand is to be controlled by means of a glove. For
	  this purpose, various sensors must be tested for accuracy and the evaluated data then
	  transmitted wirelessly to the robotic hand. The positions of the fingers are to be displayed in a
	  user interface.}\\
	 \hline
	\multicolumn{2}{l}{\large{ \textbf{}}}\\ 
	 \hline
	  \bfseries{\small{Realization}} & \small{The movements of the human hand are recorded with Flex sensors on the glove.
	  The required data is then transmitted to the robotic hand via wireless communication. An application of some kind will serve as
	  the user interface.}\\  
	 \hline
	\multicolumn{2}{l}{\large{ \textbf{}}}\\ 
	 \hline
	  \bfseries{\small{Results}} & \small{The hand movements can be correctly evaluated and transmitted. The user wears the
	  glove and grasps an object. The servo motors interpret the received data by means of the PCB
	  and enable the robot hand to also grasp the same object. When the hand is opened, the robot
	  hand must also move back to its starting position.}\\
	 \hline
	\end{tabular}
\end {center}

\thispagestyle{empty}
	
\newpage
\thispagestyle{empty}

\begin{centering}
\begin{tabular} {|p {3cm}|p{8cm}|p{4.55cm}|}
 \hline 
\vspace{1mm}
 \centering{\includegraphics[width=0.18\textwidth,page=1]{/Users/laci/Schule/Diplomarbeit_GitHub/LATEX_DOKU_DA/src/TGM_logo.pdf}} &
\centering{\normalsize{\textbf{HTBLVA Wien 20}}\par\small{\textbf{College of}\par Electronic and Technical Information Technology}} &
	\small{\bfseries{Diploma\par Exam}}\\ 
	\hline
\end{tabular}

\vspace {2mm}

	\begin{tabular} {|p {6cm}|p{10cm}|}
	 \hline 
		\bfseries{\small{Illustrative graph, photo\par (with explanation)}} & \vspace{0.0mm} \small{
		\includegraphics[width=0.58\textwidth]{/Users/laci/Schule/Diplomarbeit_GitHub/LATEX_DOKU_DA/src/schematic_drawing.jpeg} \par Final construction of the System
		}\\
	 \hline
	  \multicolumn{2}{l}{\large{ \textbf{}}}\\
	 \hline
	  \bfseries{\small{Participation in competitions,\par Awards}} & \small{}\\
	 \hline 
	  \multicolumn{2}{l}{\large{ \textbf{}}}\\
	 \hline
	  \bfseries{\small{Accesibility
		of\par Diploma Thesis}} & \small{Department administration}\\ 
	 \hline 
	  \multicolumn{2}{l}{\large{ \textbf{}}}\\
	\end{tabular}  
	
	\begin{tabular} {|p {6cm}|p{5cm}|p{4.6cm}|}
	 \hline
   \vspace{5mm}
	  \bfseries{\small{Approval\par (Date/Signature)}} \vspace{5mm} & \tiny{Examiner} & \tiny{Head of College/Department}\\ 
	 \hline 
	\end{tabular} 
	\end{centering}

\thispagestyle{empty}

\newpage

%--------------------------------------------------------------------------
%==========================================================================
%== Diploma Thesis Deutsch ================================================

\thispagestyle{empty}
	
\begin {center}
\begin{tabular} {|p {3cm}|p{8cm}|p{4.55cm}|}
 \hline 
\vspace{1mm}
 \centering{\includegraphics[width=0.18\textwidth,page=1]{/Users/laci/Schule/Diplomarbeit_GitHub/LATEX_DOKU_DA/src/TGM_logo.pdf}} &
\centering{\normalsize{\textbf{HTBLVA Wien 20}}\par\small{\textbf{Höhere Technische Lehranstalt für}\par Elektronik und Technische  Informatik}} &
	\small{\bfseries{Reife- und\par Diplomprüfung}}\\ 
	\hline
\end{tabular}

\vspace{5mm}
\Large{\textbf{DIPLOMARBEIT\\}}
\vspace{1mm}
\small{\textbf{DOKUMENTATION\\}}
\vspace{5mm}  

	\begin{tabular} {|p {6cm}|p{10cm}|}
	 \hline 
		\bfseries{\small{Namen der\par Verfasser/innen}} & \small{Amir Al-Maytah, Fabian Schweitzer, Ladislaus Szabo}\\
	 \hline
	  \bfseries{\small{Jahrgang\par Schuljahr}} & \small{5BHEL 2023/2024}\\
	 \hline 
	  \bfseries{\small{Thema der Diplomarbeit}} & \small{RoboGlove - Bionische Hand}\\ 
	 \hline 
	  \bfseries{\small{Kooperationspartner}} & \small{}\\ 
	 \hline
	\multicolumn{2}{l}{\large{ \textbf{}}}\\
	 \hline
	  \bfseries{\small{Aufgabenstellung}} & \small{Im Rahmen eines Diplomprojekts soll eine Roboterhand mittels eines Handschuhs gesteuert werden. 
	  Dazu müssen verschiedene Sensoren auf Genauigkeit getestet und aanscließend die ausgewerteten Daten kabellos an die
	  Roboterhand übertragen werden. Die Bewegungen der Finger sollen mit Motoren nachgebildet werden und die Stellungen
	  dieser soll im User-Interface dargestellt werden.}\\
	 \hline
	\multicolumn{2}{l}{\large{ \textbf{}}}\\ 
	 \hline
	  \bfseries{\small{Realisierung}} & \small{Die Bewegungen der menschlichen Hand werden mit Flexsensoren am Handschuh erfasst. Die benötigten Daten werden
	  anschließend über ein drahtloses Protokoll an die Roboterhand übertragen. Die Bewegungen der Roboterfinger werden mit
	  Servomotoren realisiert. Als User-Interface soll eine Applikation dienen.}\\  
	 \hline
	\multicolumn{2}{l}{\large{ \textbf{}}}\\ 
	 \hline
	  \bfseries{\small{Ergebnisse}} & \small{Die Handbewegungen können korrekt ausgewertet und übertragen werden. Der Benutzer trägt den Handschuh und greift 
	  ein Objekt. Die Servomotoren interpretieren mittels des PCBs die empfangenen Daten und ermöglichen es der Roboterhand 
	  ebenfalls das gleiche Objekt zu greifen. Beim Öffnen der Hand muss sich die Roboterhand in ihre Ausgangsstellung 
	  zurückbewegen.}\\
	 \hline
	\end{tabular}
\end {center}
\thispagestyle{empty}
	
\newpage
\thispagestyle{empty}

\begin{centering}
\begin{tabular} {|p {3cm}|p{8cm}|p{4.55cm}|}
 \hline 
\vspace{1mm}
 \centering{\includegraphics[width=0.18\textwidth,page=1]{/Users/laci/Schule/Diplomarbeit_GitHub/LATEX_DOKU_DA/src/TGM_logo.pdf}} &
\centering{\normalsize{\textbf{HTBLVA Wien 20}}\par\small{\textbf{Höhere Technische Lehranstalt für}\par Elektronik und Technische  Informatik}} &
	\small{\bfseries{Reife- und\par Diplomprüfung}}\\ 
	\hline
	\multicolumn{3}{l}{\large{ \textbf{}}}\\
\end{tabular} 

\vspace {1mm}

	\begin{tabular} {|p {6cm}|p{10cm}|}
	 \hline 
		\bfseries{\small{Typische Grafik, Foto etc.\par (mit Erläuterung)}} & \vspace{0.0mm} \small{
		\includegraphics[width=0.58\textwidth]{/Users/laci/Schule/Diplomarbeit_GitHub/LATEX_DOKU_DA/src/schematische_Darstellung.jpeg} \par Vollständiger Aufbau des Systems
		}\\
	 \hline
	  \multicolumn{2}{l}{\large{ \textbf{}}}\\
	 \hline
	  \bfseries{\small{Teilnahme an Wettbewerben,\par Auszeichnungen}} & \small{}\\
	 \hline 
	  \multicolumn{2}{l}{\large{ \textbf{}}}\\
	 \hline
	  \bfseries{\small{Möglichkeiten der\par Einsichtnahme in die Arbeit}} & \small{Abteilungsadministration}\\ 
	 \hline 
	  \multicolumn{2}{l}{\large{ \textbf{}}}\\
	\end{tabular}
	
	\begin{tabular} {|p {6cm}|p{5cm}|p{4.6cm}|}
	 \hline
   \vspace{5mm}
	  \bfseries{\small{Approbation\par (Datum/Unterschrift)}} \vspace{5mm} & \tiny{Prüfer/Prüfernin} & \tiny{ Direktor/Direktorin\par Abteilungsvorstand/Abteilungsvorständin}\\ 
	 \hline 
	\end{tabular} 
	\end{centering}
	
\thispagestyle{empty}

\newpage

%==INHALT==================================================================

\tableofcontents

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------

\clearpage
\pagenumbering{arabic}

\section{Einleitung}
\label{chap:Einleitung}
In einer sterilen Umgebung ist es unerlässlich, eine keimfreie Methode zu haben, um Aufgaben zu erledigen, die normalerweise von 
menschlichen Händen ausgeführt werden. Beispielsweise muss ein Objekt gegriffen und an eine andere Position innerhalb dieser 
geschlossenen Umgebung bewegt werden. Zusätzlich ist es hilfreich, eine Möglichkeit zur Analyse gefährlicher Güter zu haben.
Diese Anforderungen können durch eine bionische Hand erfüllt werden. Diese Hand wird drahtlos vom Menschen über eine, in einen 
Handschuh integrierte elektronische Schaltung, gesteuert. Weitere Hardware-, Software- und Mechanikkomponenten sind erforderlich, 
um den gewünschten Anwendungsfall zu realisieren. Ein Prototyp eines Roboterarms wird entwickelt, der je nach Einsatzgebiet 
drahtlos gesteuert und vielfältig eingesetzt werden kann. \\
\\
Diese Diplomarbeit wurde von mehreren Autoren verfasst und ist in verschiedene Kapitel unterteilt, um eine klare Struktur zu 
gewährleisten. Dadurch können die benötigten Informationen schnell gefunden werden. Zunächst werden grundlegende theoretische 
Kenntnisse festgehalten, um den Einstieg in das Thema zu erleichtern. Anschließend beschreiben wir die Umsetzung der Mechanik, 
gefolgt von der Hardware und der Software. Alle relevanten Aspekte der bionischen Hand werden in diesen Hauptkapiteln abgedeckt. 
Darüber hinaus werden Tests, Messungen und die während der Entwicklungsphase erzielten Ergebnisse aufgeführt und ausgewertet. Die 
abschließenden Erkenntnisse geben einen Überblick darüber, inwiefern die gewünschte Realisierung möglich ist. Jedes dieser 
Hauptkapitel enthält auch Unterkapitel, um die jeweilige Thematik detaillierter zu beschreiben. \\
\\
In dieser Diplomarbeit sind alle durchgeführten Überlegungen und Entwicklungsschritte genau dokumentiert. Dadurch wird der gesamte 
Arbeitsfortschritt nachvollziehbar. Die verwendeten Informationen stammen aus eigener Erfahrung, Internetrecherchen oder 
Fachliteratur. Falls externe Quellen genutzt wurden, sind diese in Fußnoten mit entsprechenden Verweisen gekennzeichnet. \\
\\

\subsection{Ausgangslage und grundlegende Motivation}
\label{chap:Ausgangslage und grundlegende Motivation}
Es gibt Produktionsbereiche, die klinisch sauber gehalten werden müssen, da durch Menschen Kontaminationen entstehen
können. Für dieses Vorhaben soll ein Prototyp einer Roboterhand, die über einen Sensorhandschuh kabellos gesteuert wird,
entwickelt und aufgebaut werden. Diverse Parameter der Roboterhand sollen in einem Interface für den Benutzer 
dargestellt werden. \\

\subsection{Themenerläuterung}
\label{chap:Themenerläuterung}
Ziel des Projekts ist es, eine Roboterhand zu bauen, die über einen kabellos verbundenen
Handschuh gesteuert werden kann. Das Ziel ist es, Daten der Fingergelenkssensoren auszulesen,
zu übertragen und die Bewegungen mit der Roboterhand nachzustellen. Endziel ist es, Daten
richtig zu verarbeiten und die Roboterhand entsprechend zu bewegen. Daten sollen in einem
Interface dargestellt werden. \\
\\
Es soll eine Erfassung der Sensordaten möglich sein. Diese sollen übertragen und empfangen
werden können. Die Roboterhand soll die Finger nach der Vorgabe des Handschuhs bewegen
können. Als Endergebnis soll eine halbvolle 500mL Plastikflasche umschlossen und in der Luft
gehalten werden. In dem Interface, dem User-Interface, sollen wichtige Daten dargestellt und
Parameter verändert werden können. \\

\subsection{Grundgliederung der Arbeit}
\label{chap:Grundgliederung der Arbeit}
Folgende Schüler des TGMs haben, das in [\textcolor{blue}{\autoref{chap:Themenerläuterung}}] erläuterte Projekt, entwickelt und gefertigt: \hfill \break
\\
Projektleiter:    Ladislaus Szabo (Hardwareentwicklung, PCB-Design, Projektleitung)\\
Mitarbeiter: Fabian Schweitzer (Mikrokontroller-Programmierung, Testmanagement, Gesamtintegration)\\
Amir Al-Maytah (3D-Druck, Mechanik, Userinterface-Programmierung) 
\\
\\
Die folgenden beiden Betreuer haben uns jeder Zeit geholfen:
\\
Dipl.Ing. Christoph Diemberger \\
Fachlehrer Robert Offner

\subsection{Untersuchungsanliegen der individuellen Themenstellungen}
\label{chap:Untersuchungsanliegen der individuellen Themenstellungen}
Mit dieser Diplomarbeit soll eine Roboterhand nach einem fertigen Design, das nach Bedarf auch erweitert werden kann, aufgebaut werden,
die mit einem kabellos angebundenen Handschuh gesteuert wird. Zu diesem Zweck müssen
verschiedene Sensoren getestet werden, die die Fingergelenksstellung messen. Deren Daten
müssen ausgelesen und mittels kabelloser Schnittstelle an die Roboterhand übertragen werden
[\textcolor{blue}{Schweitzer}]. Um die Fingerbewegungen an der Roboterhand nachzustellen, muss folglich eine
Motoransteuerung entwickelt werden [\textcolor{blue}{Szabo}]. Um die elektronischen Bauelemente
unterzubringen, muss ein entsprechendes Gehäuse, in Form einer menschlichen Hand
beziehungsweise eines Arms, gefertigt werden. Zusätzlich soll ein Interface erstellt werden, in
dem der Benutzer Daten des Roboterarms und des Handschuhs einsehen kann. [\textcolor{blue}{Al-Maytah}] \\

\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break

\newpage
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\section{Lastenheft}
\label{chap:Lastenheft}

\begin{table}[H]
    \centering
    \caption{Lastenheft}
    \begin{tabular}{|c|c|c|c|}
        \hline
        Requirement Nr. & Requirement Text & Mandatory (Y/N) & Erfüllungsgrad (\%) \\
        \hline
        1 & \fcolorbox{white}{white}{\parbox{5cm}{Es soll ein Handchuh (Eingabe) entwickelt werden, mit dem man eine Roboterhand (Ausgabe) steuern kann.}} & Y & 100 \\
		\hline
		2 & \fcolorbox{white}{white}{\parbox{5cm}{Der Handschuh soll kabellos mit der Roboterhand verbunden werden können.}} & Y & 100 \\
        \hline
		3 & \fcolorbox{white}{white}{\parbox{5cm}{Die Bewegungen der Roboterhand sollen möglichst gut die einer echten Hand immitieren.}} & Y & 100 \\
		\hline
		4 & \fcolorbox{white}{white}{\parbox{5cm}{Die Roboterhand ist ein fertiges Design (3D Druck), dass im Projekt integriert wird.}} & Y & \fcolorbox{white}{white}{\parbox{3cm}{150 , weil das fertige Design verbessert und modifieziert wurde}} \\
        \hline
		5 & \fcolorbox{white}{white}{\parbox{5cm}{Die Bewegungserfassung soll mit entsprechender Sensorik erfolgen.}} & Y & 100 \\
		\hline
		6 & \fcolorbox{white}{white}{\parbox{5cm}{ - Flex Sensoren für die Finger}} & Y & 100 \\
        \hline
		7 & \fcolorbox{white}{white}{\parbox{5cm}{ - Gyro Sensor für die Drehung des Handgelenks}} & N & \fcolorbox{white}{white}{\parbox{3cm}{50, Hardware ja, Software nein}} \\
		\hline
		8 & \fcolorbox{white}{white}{\parbox{5cm}{Die Datenauswertung soll mit einem Mikrokontroller erfolgen.}} & Y & 100 \\
        \hline
		9 & \fcolorbox{white}{white}{\parbox{5cm}{Eine Platine für das Verbinden aller Komponenten am Handschuh muss gebaut werden.}} & Y & 100 \\
		\hline
		10 & \fcolorbox{white}{white}{\parbox{5cm}{ - soll auf den Handrücken des Handschuhs passen}} & Y & 100 \\
        \hline
    \end{tabular}
    \label{tab:zeilenumbruch_parbox}
\end{table}

\begin{table}[H]
    \centering
    \caption{Lastenheft}
    \begin{tabular}{|c|c|c|c|}
        \hline
        Requirement Nr. & Requirement Text & Mandatory (Y/N) & Erfüllungsgrad \\
        \hline
		11 & \fcolorbox{white}{white}{\parbox{5cm}{ - Anschlussmöglichkeiten für einen Akku (Akkupack oder LiPo), plus alternativ für eine externe Stromversorgung müssen vorhanden sein}} & Y & 100 \\
		\hline
		12 & \fcolorbox{white}{white}{\parbox{5cm}{ - USB Anschluss zum Programmieren des ESP32}} & Y & 100 \\
        \hline
		13 & \fcolorbox{white}{white}{\parbox{5cm}{ - Upload und Reset Button für ESP32}} & Y & 100 \\
		\hline
		14 & \fcolorbox{white}{white}{\parbox{5cm}{ - Annähen?}} & N & \fcolorbox{white}{white}{\parbox{3cm}{0, da die Sensoren anfangs angenäht wurden nun aber schlussendlich nicht}}  \\
        \hline
		15 & \fcolorbox{white}{white}{\parbox{5cm}{Mit einem ADC, sollen mindestens 30 verschiedene Positionen der Flexsensoren detektiert werden können.}} & Y & 100 \\
		\hline
		16 & \fcolorbox{white}{white}{\parbox{5cm}{ - diese Positionen sollen wiederherstellbar sein}} & Y & 50 \\
        \hline
		17 & \fcolorbox{white}{white}{\parbox{5cm}{Das Maximalgewicht des Handschuhs soll 500g nicht übersteigen.}} & Y & 100 \\
		\hline
		18 & \fcolorbox{white}{white}{\parbox{5cm}{Fertigung mittels 3D-Druck (fertiges Design)}} & Y & 100 \\
        \hline
		19 & \fcolorbox{white}{white}{\parbox{5cm}{ - metallische Gelenke für die Finger}} & Y & 100 \\
		\hline
		20 & \fcolorbox{white}{white}{\parbox{5cm}{ - Abmessungen der Hand und Finger wie eine echte !!}} & Y & 100 \\
        \hline
		21 & \fcolorbox{white}{white}{\parbox{5cm}{Drucksensoren an den Fingerspitzen}} & N & 0 \\
		\hline
		22 & \fcolorbox{white}{white}{\parbox{5cm}{Nachstellung der Bewegungen mit Motoren}} & Y & 100 \\
        \hline
		23 & \fcolorbox{white}{white}{\parbox{5cm}{ - Servomotoren}} & Y & 100 \\
		\hline
    \end{tabular}
    \label{tab:zeilenumbruch_parbox}
\end{table}

\begin{table}[H]
    \centering
    \caption{Lastenheft}
    \begin{tabular}{|c|c|c|c|}
        \hline
        Requirement Nr. & Requirement Text & Mandatory (Y/N) & Erfüllungsgrad \\
        \hline
		24 & \fcolorbox{white}{white}{\parbox{5cm}{Die Finger sollen sich kontrolliert zum und vom Handballen weg bewegen können.}} & Y & 100 \\
        \hline
		25 & \fcolorbox{white}{white}{\parbox{5cm}{Die Finger sollen sich seitlich bewegen können.}} & N & 0 \\
		\hline
		26 & \fcolorbox{white}{white}{\parbox{5cm}{Die Finger sollen sich zitterfrei bewegen können.}} & Y & 90 \\
        \hline
		27 & \fcolorbox{white}{white}{\parbox{5cm}{Die Finger sollen sich störungsfrei bewegen können.}} & Y & 90 \\
		\hline
		28 & \fcolorbox{white}{white}{\parbox{5cm}{ - stabile kabellose Verbindung !! (störungstolerantes Kommunikationsprotokoll)}} & Y & 90 \\
        \hline
		29 & \fcolorbox{white}{white}{\parbox{5cm}{ - stabile Spannungsversorgung für jeden einzelnen Motor}} & Y & 100 \\
		\hline
		30 & \fcolorbox{white}{white}{\parbox{5cm}{ - Mikrokontroller für die Kommunikation mit dem Handschuh und die Steuerung der Servomotoren (ESP32)}} & Y & 100 \\
        \hline
		31 & \fcolorbox{white}{white}{\parbox{5cm}{ - Anschluss für externes Netzteil}} & Y & 100 \\
		\hline
		32 & \fcolorbox{white}{white}{\parbox{5cm}{ - USB Anschlus zum Programmieren des ESP32}} & Y & 100 \\
        \hline
		33 & \fcolorbox{white}{white}{\parbox{5cm}{ - Upload -und Reset Button für ESP32}} & Y & 100 \\
		\hline
		34 & \fcolorbox{white}{white}{\parbox{5cm}{Jeder einzelne Servomotor soll eine Stromüberwachung haben.}} & Y & 100 \\
        \hline
		35 & \fcolorbox{white}{white}{\parbox{5cm}{ - mit dieser soll die Griffkraft der Finger kontrolliert werden können. (leicht - mittel - stark)}} & Y & 0 \\
		\hline
    \end{tabular}
    \label{tab:zeilenumbruch_parbox}
\end{table}

\begin{table}[H]
    \centering
    \caption{Lastenheft}
    \begin{tabular}{|c|c|c|c|}
        \hline
        Requirement Nr. & Requirement Text & Mandatory (Y/N) & Erfüllungsgrad \\
        \hline
		36 & \fcolorbox{white}{white}{\parbox{5cm}{ - die Parameter der Griffkraft sollen eingestellt werden können.}} & Y & 0 \\
        \hline
		37 & \fcolorbox{white}{white}{\parbox{5cm}{Die Hand soll eine 500mL Plastikflasche, die zur Hälfte gefüllt ist, als Endziel greifen können und in der Luft halten.}} & Y & 100 \\
		\hline
		38 & \fcolorbox{white}{white}{\parbox{5cm}{Das User Interface soll folgende Elemente aufweisen:}} & Y & 75 \\
        \hline
		39 & \fcolorbox{white}{white}{\parbox{5cm}{ - 3D Modell der Hand}} & N & 100 \\
		\hline
		40 & \fcolorbox{white}{white}{\parbox{5cm}{ - Griffkraftanzeige (in kg)}} & Y & 0 \\
        \hline
        41 & \fcolorbox{white}{white}{\parbox{5cm}{ - Anzeige der Servostellung (Winkel)}} & Y & 100 \\
		\hline
		42 & \fcolorbox{white}{white}{\parbox{5cm}{ - in Form einer Applikation}} & Y & 100 \\
        \hline
    \end{tabular}
    \label{tab:zeilenumbruch_parbox}
\end{table}


\newpage
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\section{VWTT - Aktuatoren mit Positionsregelung [\textcolor{blue}{Al-Maytah}]}
\subsection{Überblick über Aktuatoren}
Ein Aktuator bezeichnet ein Gerät, welches erhaltene Energie und Signale 
in eine Bewegung oder auch Kraft umwandelt. Diese Apparaturen sind 
weitverbreitete Komponenten in Bereichen wie der Robotik bis zu 
großflächigen Anwendungen bei der Automatisierung und Steuerung 
verschiedener Applikationen in der Industrie. \footnote{\cite{Q1}} \\
\\
Die anhand der Umwandlung resultierende Bewegung kann rotierend oder 
geradlinig sein. Rotierende Bewegungen werden anhand eines Drehantriebs 
erzeugt, bei linearen Bewegungen hingegen bewegt sich der Antrieb auf 
einer Achse in beide Richtungen, vor und zurück. \footnote{\cite{Q4}} \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Actuator}}
		\caption{Actuator (\textcolor{blue}{Quelle: \cite{Q4}})}
		\label{fig:Actuator}
	\end{center}
\end{figure}
\subsubsection{Diverse Arten von Aktuatoren und deren Anwendungsbereiche}
Aufgrund der weitverbreiteten Anwendung von Aktuatoren erschließen sich 
verschiedene Arten von diesen. Demnach gibt es thermische, mechanische, 
elektrische, pneumatische und hydraulische Aktuatoren, mit verschiedenen 
Eigenschaften für das jeweilige Anwendungsgebiet. Diese Eigenschaften, 
können zu einem die Kraft, Reaktionszeit und auch Haltbarkeit sein, 
sowie auch die Dreh- beziehungsweise allgemeine Geschwindigkeit. \footnote{\cite{Q1}} \\
\paragraph{Pneumatische Antriebe}
\hfill \break
\hfill \break
Unter einem Pneumatischen Antrieb versteht sich ein Gerät welches anhand 
von Druckluft eine Bewegung erzeugt. Die Anwendungen sind äußerst 
vielseitig, beispielsweise für die Bewegung von Komponenten in Maschinen 
und unter anderem auch zum Steuern der Stellung eines Ventils. Die 
Eigenschaften solch eines Antriebs sind sehr geringe Reaktionszeiten 
sowie starke Kräfte. \footnote{\cite{Q1}} \\
\paragraph{Hydraulische Antriebe}
\hfill \break
\hfill \break
Anhand des Drucks von Flüssigkeit wird beim hydraulischen Antrieb eine 
Bewegung erzeugt, diese findet ihren Platz bei Schwerlast-Anwendungen, 
besonders im Konstruktions- und Fertigungsbereich. Hydraulische 
Aktuatoren stehen für eine hohe Kraft und Haltbarkeit. \footnote{\cite{Q1}} \\
\paragraph{Elektrische Antriebe}
\hfill \break
\hfill \break
Diese Formen der Antriebe nutzen elektrische Energie um aus dieser eine 
Bewegung zu erzeugen. Diese unterteilen sich in Gleich- und 
Wechselstrommotoren, welche in elektronischen Anwendungen weitverbreitet 
sind. Aufgrund ihrer äußerst genauen Steuerungsmöglichkeiten, sowie des 
geringen Geräusches finden solche Antriebe ihre Anwendung in der Automatisierung 
gewisser Systeme, medizinischer Geräte und weiterer Laboranwendungen. \footnote{\cite{Q1}} \\
\paragraph{Thermische und magnetische Antriebe}
\hfill \break
\hfill \break
Diese Form eines Aktuators nutzt die Änderung von Temperatur oder 
magnetischen Feldern um daraus eine Bewegung zu erzeugen. Ein thermischer 
Antrieb macht sich somit die Ausdehnung oder Kontraktion gewisser 
Materialien, welche durch Temperaturänderungen verursacht wurde, zu 
nutze. Diese Verfahren finden ihre Applikation in sehr kleinen Systemen, 
wie in mikromechanischen oder miniaturisierten Anwendungen. \footnote{\cite{Q1}} \\
\paragraph{Mechanische Antriebe}
\hfill \break
\hfill \break
Eine Bewegung kann bei diesem Antrieb anhand von mechanischen Komponenten 
wie Zahnrädern, Nocken oder Hebel erzeugt werden. Deren Einsatz erfolgt 
häufig in Anwendungen, die geringe Kosten und eine hohe Haltbarkeit auf 
längere Zeit erfordern. \footnote{\cite{Q1}} \\
\subsubsection{Einführung in den Servomotor}
Mit einem DC-Motor als Kernkomponente ordnet sich der Servomotor den 
elektrischen Antrieben zu. Der Begriff \textquote{Servo} bedeutet so viel wie 
\textquote{Diener} im Lateinischen und ist auf seine Funktion als 
Aktuator zurückzuführen, denn er ist eine Kombination eines 
Elektromotors und einer zugehörigen Steuerungs- und Regelungselektronik. \footnote{\cite{Q6}} \\
\paragraph{Grundlagen eines Servos}
\hfill \break
\hfill \break
Aus dem Zusammenspiel eines Servomotors und eines Servoreglers 
erschließt sich ein geschlossener Regelkreis, aus dem sich ein 
jeweiliger Antrieb bildet. Der Servo wird geregelt nach dem Prinzip der 
Positionsregelung, welche in [\textcolor{blue}{\autoref{chap:Positionsregelung}}] ausführlicher 
erläutert wird. \footnote{\cite{Q6}} Besonders zeichnen sich diese Motoren anhand ihrer 
hohen Präzision aus, da sie in der Lage sind eine angeforderte Position 
akkurat anzusteuern und diese konstant zu halten. Auch führt dies dazu, 
dass der Antrieb ohne große Verzögerung eine Position beziehungsweise 
auch Drehzahl erreicht. Eine Anwendung findet dieser daher, aufgrund 
seiner Eigenschaften, in Systemen, welche darauf abzielen dynamische 
Bewegungen zu erzielen, wie Roboter oder Maschinen. \footnote{\cite{Q7}} \\
\paragraph{Aufbau und Funktionsprinzip eines Servomotors}
\label{par:Aufbau und Funktionsprinzip eines Servomotors}
\hfill \break
\hfill \break
\textbf{Äußere Komponenten} \\
\\
Von außen sind von einem Servomotor sein Hauptgehäuse und seine 
Anschlüsse zu sehen. Die Anschlüsse dabei sind bei Modellbau-Motoren 
die Versorgung, sowie das Signalkabel. Auf diesem Kabel erfolgt die 
Datenübermittlung per PWM (Pulse-Width-Modulation). Auf der oberen Seite 
des Hauptgehäuses ist ein Zahnrad zu sehen, auf diesem können je nach 
Anwendung verschiedene Aufsätze montiert werden. \footnote{\cite{Q1}}\textcolor{blue}{@3 min 38 Sekunden} \\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{Amir_Servo1}}
		\caption{Äußere Betrachtung eines Servomotors (\textcolor{blue}{Quelle: \cite{Q8}@3 min 51 Sekunden})}
		\label{fig:Amir_Servo1}
	\end{center}
\end{figure}
\hfill \break
\textbf{Innere Komponenten} \\
\\
Im Innenleben des Servos befindet sich ein Mechanismus, welcher sich aus 
mehreren Zahnrädern und Kugellagern zusammensetzt, aufgrund der 
Anordnung, die diese Zahnräder haben, kann der Mechanismus auch als 
Verbundgetriebe bezeichnet werden. Dieses Getriebe hat zwei Seiten, auf 
der linken ist der sogenannte Eingang, welcher von einem Gleichstrommotor 
angetrieben wird, und rechts ist der Ausgang, welcher letztlich die 
gewünschte Drehung am Äußeren des Motors ausgibt und zugleich mit einem 
Potentiometer, zur Erfassung der Position, verbunden ist. \footnote{\cite{Q8}}\textcolor{blue}{@4 min 15 Sekunden} \\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{Amir_Servo2}}
		\caption{Servomotor von Innen (\textcolor{blue}{Quelle: \cite{Q8}@4 min 16 Sekunden})}
		\label{fig:Amir_Servo2}
	\end{center}
\end{figure}
\hfill \break
Das Verbundgetriebe bewirkt, dass aus der hohen Drehzahl vom 
Gleichstrommotor eine niedrigere geschaffen wird, und es erhöht sich 
aufgrund der Übersetzung der Zahnräder das Drehmoment. \footnote{\cite{Q8}}\textcolor{blue}{@4 min 15 Sekunden} \\
\subsubsection{Positionsregelung}
\label{chap:Positionsregelung}
\paragraph{Einführung in die Positionsregelung}
\hfill \break
\hfill \break
Bezugnehmend auf ein System, wie der Antrieb eines Motors, regelt der 
Positionsregler diesen auf eine bestimmte Position und versucht diese 
durchgängig zu halten, solange bis auf eine neue Position geregelt 
werden soll. Die Anwendung der Positionsregelung ist oft in der Robotik 
zu sehen, sei es eine einzelne Achse eines Roboters oder Großanwendungen für diverse
Systeme. \\
\\
Wie bereits erwähnt regelt der Servomotor auf eine per PWM angewiesene Position, die 
Positionsregelung erfolgt unter gängigen Eigenschaften einer Regelung. Eine 
Regelabweichung zwischen Soll- und Ist Wert wird berechnet, darauf folgt vom Regler 
eine entsprechende Stellgröße. \\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Servo_Case}}
		\caption{Servomotor von Innen (\textcolor{blue}{Quelle: \cite{Q13}})}
		\label{fig:Servo_Case}
	\end{center}
\end{figure}
\hfill \break
Der Regelkreis eines Servomotors sieht wie folgt aus: Ein Mikrocontroller sendet per 
PWM eine Position an den Servo-Controller. Die gesendete Position entspricht nun der 
Sollgröße, das über das Getriebe verbundene Potentiometer liefert eine Rückmeldung 
der aktuellen Position, die Ist-Größe, an den Controller. Aus der Regelabweichung 
berechnet der Controller eine Stellgröße, einen Antriebsstrom, welcher zum Gleichstrommotor 
fließt und diesen antreibt, bis über das Feedback des Potentiometers festgestellt 
wird, dass die Zielposition erreicht wurde. \\
\paragraph{Theoretische Grundlagen}
\hfill \break
\hfill \break
\textbf{Essenzielle Begriffe} \\
\\
Ist-Größe: Beschreibt in diesem Zusammenhang den aktuellen Drehwinkel $\Phi$ des Motors, 
wird über das Potentiometer ermittelt. \\
Soll-Größe: Diese ist der Zielwinkel, bis zu dieser Position soll der Gleichstrommotor 
sich drehen und wird per PWM übergeben. \\
Regelabweichung: Die Differenz zwischen der Soll- und Ist-Größe \\
Stellgröße: Die Größe welche bewirken soll, dass sich die Abweichung stetig 
verringert. \\
\\
\textbf{Erläuterung integrierter Regler} \\
\\
Der Regelkreis eines Positionsreglers setzt sich aus mehreren einzelnen 
Reglern zusammen, um daraus die notwendige Regelstrecke zu bilden. \\
\\
\textbf{PID-Regler} \\
\\
Eine wesentliche Komponente der Positionsregelung ist der PID-Regler, 
welcher eine Kombination beziehungsweise gar Parallelschaltung dreier 
Reglungsglieder ist. Sein Ziel ist es grundsätzlich die Abweichung 
zwischen Ist- und Sollgröße zu minimieren und dies möglichst präzise, 
effizient und genau. Aufgrund seiner vielfältigen Eigenschaften ist der 
PID-Regler in sämtlichen Anwendungen weitverbreitet und darf sich 
dementsprechend als der \textquote{Standardregler} bezeichnen. Die drei 
integrierten Glieder, das P-Glied, das I-Glied sowie das D-Glied, 
ermöglichen das Einstellen anhand von drei Parametern, jedoch 
ausschließlich auf Basis einer fundierten Berechnung. \footnote{\cite{Haager}}\textcolor{blue}{p.99} \\
\\
Die Übertragungsfunktion des PID-Reglers setzt sich aus den einzelnen 
Übertragungsfunktionen der jeweiligen Glieder zusammen: \\
\\
$F_{R}(s)=k_{R}*(1+\frac{1}{sT_{n}}+sT_{v})=k_{R}+\frac{1}{sT_{O}}+sT_{D} $ \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{P_Glied}}
		\caption{P-Glied (\textcolor{blue}{Quelle: \cite{Haager}p.101})}
		\label{fig:P_Glied}
	\end{center}
\end{figure}
\hfill \break
Der erste Summand \textquote{$k_{R}$} der Übertragungsfunktion ist der P-Regler, das 
\textquote{P} im Namen ergibt sich aus der Tatsache, dass seine Ausgangsgröße 
proportional zur Eingangsgröße ist, der P-Regler gibt somit die 
Konstante \textquote{$k_{R}$}. \footnote{\cite{Q9}}\textcolor{blue}{P-Regler} \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{I_Glied}}
		\caption{I-Glied (\textcolor{blue}{Quelle: \cite{Haager}p.101})}
		\label{fig:I_Glied}
	\end{center}
\end{figure}
\hfill \break
In der Übertragungsfunktion beschreibt der zweite Summand den I-Anteil, 
dieser erzeugt eine Ausgangsstellgröße, welche dem zeitlichen Integral, 
daher der Name, der Eingangsgröße, sprich der Regelabweichung 
proportional ist. Bei einer konstanten Regelabweichung würde sich die 
Stellgröße in Form einer Rampe ändern. \footnote{\cite{Haager}}\textcolor{blue}{p.99} \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{D_Glied}}
		\caption{D-Glied (\textcolor{blue}{Quelle: \cite{Haager}p.101})}
		\label{fig:D_Glied}
	\end{center}
\end{figure}
\hfill \break
Der letzte Summand beinhaltet die Übertragungsfunktion des D-Anteils, 
das \textquote{D} steht dabei für Differenzierer, denn dieser erzeugt eine 
Stellgröße, welche proportional der zeitlichen Änderungsrate der 
Regelabweichung ist. Ist die Regelabweichung konstant, gibt es demnach 
keine Stellgröße, was jedoch bedeutet, dass mit einer raschen Reaktion 
auf eine Änderung der Regelabweichung zu rechnen ist. \\
\paragraph{Funktionsprinzip des Regelkreises}
\hfill \break
\hfill \break
Der Regelkreis einer Positionsregelung setzt sich aus mehreren verschiedenen 
Komponenten zusammen, mitunter dem PID-Regler als Kernglied, dem Motorblock und 
auch weiteren P und I Reglern. \\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{Regelkreis}}
		\caption{Makrodarstellung des Regelkreises}
		\label{fig:Regelkreis}
	\end{center}
\end{figure}
\hfill \break
Das Funktionsprinzip der Positionsregelung wird anhand einer Simulation, wie in Abbildung 8 ersichtlich, dargestellt. Die Modellierung des Gleichstrommotors dient ausschließlich zur Veranschaulichung des Prinzips und soll nicht einen spezifischen Servomotor immitieren.
Grundsätzlich beginnt der Kreislauf der Regelung mit einer Sollgröße, in diesem Fall 
einem Soll-Winkel von 100\textdegree. Vorhanden in der Simulation der Positionsregelung ist auch 
ein optionaler Sollsprung. Zu Beginn wird der Sollwinkel von Grad in Radiant 
umgerechnet, danach wird eine Differenz zwischen dem Soll- und dem aktuellen 
Drehwinkel (Ist-Größe) gebildet. \\
\begin{figure}[H]
	\begin{center}
		\scalebox{1}
		{\includegraphics[width=0.8 \linewidth]{Regelkreis2}}
		\caption{Abschnitt des Regelkreises für die Sollgröße}
		\label{fig:Regelkreis2}
	\end{center}
\end{figure}
\hfill \break
Die berechnete Differenz, welche die Regelabweichung darstellt, wird darauf an den 
PID-Regler übergeben, welche eine entsprechende Stellgröße in Form einer Spannung an 
den Motor gibt. \\
\begin{figure}[H]
	\begin{center}
		\scalebox{1}
		{\includegraphics[width=0.8 \linewidth]{Regelkreis3}}
		\caption{Abschnitt des Regelkreises Motor}
		\label{fig:Regelkreis3}
	\end{center}
\end{figure}
\hfill \break
Beschreiben lässt sich der Motor anhand folgendem Block, welcher sich aus einem 
PT1-Glied und sämtlichen Störmomenten zusammensetzt. Als Verzögerungsglied erster 
Ordnung beschreibt dieses das Anlaufverhalten des Motors. (Q12) Zusätzlich werden 
das Lastmoment, die Reibung und die Trägheit in das System miteinkalkuliert. \\
Aus der mathematischen Modellierung des Gleichstrommotors, wie im Blockschaltbild 
dargestellt, ergibt sich eine Winkelgeschwindigkeit, die Drehzahl des Motors \textquote{$\Omega$}.
Wie in [\textcolor{blue}{\autoref{par:Aufbau und Funktionsprinzip eines Servomotors}}] 
bereits beschrieben, wird die Drehzahl mit einem Getriebe übersetzt, im Falle dieses 
Beispiels beträgt das Übersetzungsverhältnis des Getriebes 0,1. \\
Mit einem I-Glied muss diese in den Drehwinkel $\Phi$, welcher der Motorposition 
entspricht, umgerechnet werden. \\
\\
$\int_{0}^{t} \omega(t)dt = \phi$ \\
\\
Finalerweise wird der Drehwinkel nochmals von Radiant in Grad rückgerechnet und der 
Drehwinkel ergibt sich, dieser wird anschließend als Feedback im Regelkreis 
rückgeführt und bietet eine Grundlage zur Berechnung der neuen Regelabweichung. \\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{Diagram_Positionsregler}}
		\caption{Diagram Positionsregler}
		\label{fig:Diagram_Poositionsregler}
	\end{center}
\end{figure}
\hfill \break
Zu sehen sind in dieser Abbildung drei Größen: In Grün der Soll-Winkel, in Blau der 
tatsächliche Drehwinkel $\Phi$ (die Ist-Größe) und die Drehzahl (Winkelgeschwindigkeit 
$\Omega$) ist orange gekennzeichnet. \\
Erkennen lässt sich, dass zum Zeitpunkt t=0 das System die Anweisung bekommt auf 
einen Winkel von 100\textdegree zu regeln. Nach 0,4 Sekunden wurde diese Position erreicht, 
jedoch zugleich überschritten, der Motor hat sich auf 105\textdegree gedreht. Während dieses 
Vorgangs ist die Drehzahl auf ein Maximum von 10 Umdrehungen die Sekunde angestiegen, nach dem 
Erreichen des Zielwerts sinkt die Drehzahl und somit auch der Drehwinkel $\Phi$ bis 
dieser 100\textdegree erreicht. \\
\\

\newpage
%=============================================================================
%=============================================================================

\section{VWTT - Freie Lizenzen [\textcolor{blue}{Schweitzer}]}
\subsection{Urheberrecht}
\subsubsection{Definition und Bedeutung}
Autoren, Programmierer oder aber auch beispielsweise Maler sind Urheber ihres selbst geschaffenen Werkes. 
Dabei beschreibt das Urheberrecht die Rechte, die eine Person an diesen hat. Wichtig ist auch, dass es nicht 
immer nur einen Urheber geben muss, sondern auch Teil- oder Miturheber existieren können, falls ein Werk 
nicht allein geschaffen wurde. \footnote{\cite{Saferinternet.p7}} \\
Das Urheberrecht besitzt viele Merkmale, die vier wichtigsten sind allerdings folgende: \\
\begin{itemize}
	\item Keine Möglichkeit der Übertragung: Es ist nicht möglich, sein Urheberrecht an andere Personen 
	abzugeben. Es können lediglich Verwertungsrechte an bestimmte Personen vergeben werden. Damit ist es 
	diesen möglich, das, von einer anderen Person geschaffene, Werk zu vervielfältigen, zu verbreiten und 
	öffentlich auszustellen. Die einzige Ausnahme, einer Übertragung des Urheberrechts, stellt jene nach dem 
	eigenen Tod an die Erben dar.
	\item Erlischt nach bestimmter Zeit: Das eigens geschaffene Werk ist für die gesamte Lebenszeit 
	urheberrechtlich geschützt. Nach dem Tod erlischt das Urheberrecht nicht sofort, sondern erst 70 Jahre 
	danach. Die Erben sind dadurch dazu berechtigt davon zu profitieren und die Nutzung weiterhin zu 
	kontrollieren. Wenn allerdings das Urheberrecht erloschen ist, dann gilt das Werk als gemeinfrei und hat 
	somit keinen urheberrechtlichen Schutz mehr.
	\item Tritt von selbst in Kraft: Sobald ein Werk eigenständig geschaffen wurde, fällt es unter den Bereich 
	des Urheberrechts. Das bedeutet, dass man sich auch an die damit verbundenen Pflichten, sowie Rechte, 
	halten muss.
	\item Kein Mindestalter: Es ist nicht notwendig ein bestimmtes Alter erreicht zu haben, um als Urheber 
	gelten zu dürfen. \footnote{\cite{Saferinternet.p7}} \\
\end{itemize}
\hfill \break
Die folgenden drei Anforderungen sind allerdings essenziell, um ein Werk als urheberrechtlich geschützt 
bezeichnen zu können: \\
\begin{itemize}
	\item Wahrnehmbarkeit: Die bloße Idee lässt sich nicht schützen. Das Werk muss in einer Form existieren, 
	in der es auch auf sinnlicher Ebene wahrgenommen werden kann.
	\item Schöpfungshöhe: Es muss sich um ein einzigartiges Werk handeln, das die eigentümliche geistige 
	Schöpfung beinhaltet. Es muss sich von anderen Werken zumindest im kleinen Maß unterscheiden.
	\item Orginalität: Fakten oder Wissen sind nicht geschützt. Deshalb muss eine individuelle Prägung 
	des Schöpfers erkennbar sein. \footnote{\cite{Saferinternet.p8}} \\
\end{itemize}
\hfill \break
Als Urheber muss man auch Pflichten nachgehen. Dabei ist zu beachten, dass man keine illegalen Inhalte in das 
Internet stellen darf. Genauer gesagt dürfen diese nicht gegen das österreichische Recht verstoßen. \\
\begin{itemize}
	\item Persönlichkeitsrechte: Es müssen die personenbezogenen Daten, sowie das Recht auf das eigene Bild 
	stets gewahrt werden. Außerdem sollte man das Namensrecht, sowie die Privatsphäre immer berücksichtigen.
	\item Rechtliche Grenzen der Inhaltsveröffentlichung: Andere Menschen im Internet zu beleidigen oder zu 
	diskriminieren verstößt gegen die guten Sitten. Genauso ist es beispielsweise verboten 
	nationalsozialistisches Gedankengut zu verbreiten. \footnote{\cite{Saferinternet.p10}}
\end{itemize}
\hfill \break
Als Urheber hat man aber auch genauso Rechte, die einem zustehen. Diese sind in Persönlichkeits- und 
Verwertungsrechte gegliedert: \\
\\
Persönlichkeitsrechte: Die wichtigsten sind, dass man entscheiden kann ob, wann und wie ein Werk 
veröffentlicht werden soll, in welcher Form der Name genannt werden muss und jede Änderung, die zur 
Entstellung des Werks führen würde, unterbunden werden wird. \\
\\
Verwertungsrechte: \\ 
\begin{itemize}
	\item Vervielfältigungsrecht: Das eigene Werk darf egal zu welchem Zeitpunkt in unbedingter Menge 
	vervielfältigt werden.
	\item Verbreitungsrecht: Das eigene Werk darf überall angeboten und vervielfältigt werden. Nur der 
	Urheber ist dazu berechtigt.
	\item Öffentliche Vorführung: Das eigene Werk darf in der Öffentlichkeit gezeigt beziehungsweise 
	aufgeführt werden. 
	\item Zurverfügungstellungsrecht: Das Recht, das Werk der Öffentlichkeit in drahtgebundener oder 
	drahtloser Weise zur Verfügung zu stellen, zum Beispiel im Internet. \footnote{\cite{Saferinternet.p11}}
\end{itemize}
\hfill \break
Welche Nutzungsrechte können erworben werden? \\
Ein urheberrechtlich geschütztes Werk darf rechtmäßig nur durch eine Ausnahmeregelung oder im Rahmen der 
freien Werknutzung verwendet werden. Genau zwischen diesen beiden Arten muss unterschieden werden: \\
\begin{itemize}
	\item Nutzungsbewilligung und -recht, Lizenz: Es reicht eine mündliche Bestätigung aus, um eine 
	Nutzungsbewilligung, ein Nutzungsrecht oder eine Lizenz an eine ausgewählte Person auszusprechen, 
	allerdings ist eine schriftliche Bestätigung, gerade im Fall von Streitfällen, die geeignetere Methode.
	\item Freie Werknutzung: Im privaten Bereich darf eine Privatkopie auch ohne Zustimmung des Urhebers erstellt 
	werden. Musik, die unter den urheberrechtlichen Schutz fällt, darf beispielsweise auf privaten Feiern abgespielt werden, ohne 
	eine Verletzung des Urheberrechts zu begehen. Im Unterricht, sowie im Zitatrecht, darf auf urheberrechtlich geschützte Werke 
	zugegriffen werden. Beim Zitatrecht ist allerdings darauf zu achten, dass der Autor, sowie die Quelle, angegeben werden müssen.  \footnote{\cite{Saferinternet.p29}}
\end{itemize}
\hfill \break

\subsubsection{Auswirkung auf Software und Kreativwerke}
\hfill \break
\hfill \break
Auch Softwares, beziehungsweise allgemein Kreativwerke, sind vom Urheberrecht geschützt. Dies ist der Fall, 
da diese auch in die Kategorie der Sprachwerke fallen (§2 Abs.1 Nr.1 UrhG). Bereits ab dem Schaffen der 
Software fällt diese unter das Urheberrechtsgesetz. Diese muss hierbei nicht fertiggestellt worden sein und 
dennoch ist diese gegen die unerlaubte Verbreitung, öffentliche Wiedergabe, sowie Ausstellung und 
Vervielfältigung geschützt. Es fallen hierbei auch keine Kosten an, sondern erst bei der Patentanmeldung, 
falls dies gewünscht sein sollte. \footnote{\cite{Ionos7}} \\
\\
\textbf{Individualität von Computerprogrammen} \\
\\
Es gelten besondere Regeln für das Urheberrecht bei Computerprogrammen (§69a UrhG). Das Werk muss eine eigene 
geistige Schöpfung des Entwicklers beinhalten, also eine gewisse Individualität widerspiegeln und darf keiner 
juristischen Person zugeschrieben werden. Diese kann lediglich Nutzungsrechte am Werk erhalten. Allerdings 
fallen objektive Neuheiten nicht unter den Schutz des Urheberrechtgesetzes. \footnote{\cite{Ionos8}} \\
\\
Urheberrechtlich sind folgende Teile geschützt: \\
\\
\begin{itemize}
	\item \textquote{Maschinencodes, Objektcodes, Quellcodes, sämtliche Programmteile, Unterprogramme und Programmodule, zugehöriges Entwurfsmaterial (Pläne, Struktogramme).} \footnote{\cite{Ionos9}}
	\item \textquote{Grafische Benutzeroberflächen, Ideen und Grundsätze des Programms, abstrakte Problemstellungen, technische Schnittstellen, Webseiten, Datenbanken, Datenstrukturen und Daten.} \footnote{\cite{Ionos10}}
\end{itemize}
\hfill \break

\subsection{Open Source}
\subsubsection{Definition und Bedeutung}
Open Source bezieht sich auf Software, von welcher der Quellcode eingesehen werden darf. 
Ebenso ist die Änderung und Nutzung erlaubt, zumeist sogar kostenfrei, allerdings muss stets auf die 
Lizenzbedingungen geachtet werden. Durch die Open Source Initiative (OSI) wird definiert, dass Lizenzverträge 
drei charakteristischen Merkmalen entsprechen müssen: \footnote{\cite{WikipediaOpenSource}} \\
\begin{itemize}
	\item Der Quelltext muss in einer Form vorliegen, in der ein Mensch diesen lesen kann. Des Weiteren muss 
	dieser auch verstanden werden können, was bedeutet, dass ein Code in der Computersprache diese 
	Anforderungen meist nicht erfüllen kann. 
	\item Der Quelltext darf von allen Menschen verwendet werden. Dieser darf auch kopiert und verbreitet 
	werden, allerdings wird zumeist die Weitergabe des Quelltextes befohlen.
	\item Der Quelltext darf verändert werden. Ebenso die Weitergabe dieser adaptierten Version ist möglich, 
	dass dies zur Entwicklung der Anwendung beiträgt. 
\end{itemize}
\hfill \break
Trotzdem muss stets darauf geachtet werden, alle Lizenzbedingungen zu erfüllen. Jede Open Source Lizenz 
besitzt auch eine verschieden große Komplexität diesbezüglich. Oftmals ist damit eine gewisse 
Einarbeitungszeit nötig. \footnote{\cite{WikipediaOpenSource12}} \\
\\
Zusätzlich müssen die zehn Punkte der Open Source Definition erfüllt sein: \textquote{Freie Weitergabe, Quellcode,
Abgeleitete Werke, Integrität des Quellcodes des Autors, Keine Diskriminierung von Personen oder Gruppen, 
Keine Diskriminierung von Tätigkeitsfeldern, Verteilung der Lizenz, Lizenz darf nicht produktspezifisch sein, 
Lizenz darf keine andere Software einschränken, Lizenz muss technologieneutral sein.} \footnote{\cite{Opensource}} \\
\\
Grundsätzlich ist Open Source Software kostenfrei. Allerdings darf der Entwickler auch festlegen, ob die 
Software kommerziell verwendet werden darf oder nicht. Es kann außerdem für den Support oder den Verkauf 
der Software auf Datenträgern, Geld verlangt werden. Der Quellcode muss zwar immer im Internet zu finden sein, 
allerdings darf dieser, falls der Entwickler es so möchte, erst nach dem Kauf einer Genehmigung auf diesen 
zurückgreifen. \footnote{\cite{Giga}} \\
\\

\subsubsection{Geschichte}
\paragraph{Motivation, Entstehung und Meilensteine}
\hfill \break
\hfill \break
Die Motivation hinter Open Source ist ganz klar das Ziel, bessere Software durch ein großes Netz an Nutzern 
weltweit zu gewährleisten. Unter diesen befinden sich etliche Entwickler, die sich mit der Optimierung und 
Verbesserung der Software beschäftigen. Somit kann die Innovation gesteigert werden, auch, wenn kein 
finanzieller Nutzen daraus resultiert. \footnote{\cite{WikipediaOpenSource}} \\
\begin{itemize}
	\item In den 1950er bis 1960er Jahren bildete sich die Do-it-yourself-Bewegung, die den Fokus darauf hatte, 
	alles selbst zu machen. Damals war es beinahe überall so, dass zusätzlich zu der Software auch der 
	Quellcode mitgeliefert wurde. Es war also jederzeit möglich, Änderungen vorzunehmen. 
	\item In den 1970er Jahren begannen Unternehmen für ihre Software Geld zu verlangen. Der zuvor immer 
	preisgegebene Quellcode wurde plötzlich zum firmeninternen Geheimnis. \footnote{\cite{WikipediaOpenSource16}}
	\item 1983 wurde das GNU-Projekt gestartet. Das Ziel war es ein freies Betriebssystem zu entwickeln und 
	anderen zur Verfügung zu stellen. Er ist der Gründer der Free Software Foundation. \footnote{\cite{WikipediaGPL2}}
	\item 1991 wurde der Linux-Kernel für die Öffentlichkeit als freie Software freigegeben. Linus Torvalds 
	entwickelte diesen und leitete hiermit die erste große Grundlage für Open Source ein. \footnote{\cite{WikipediaLinux}}
	\item 1998 wurde der Begriff \textquote{Open Source} immer bekannter, da in diesem Jahr die Open Source 
	Initiative gegründet wurde. Seit damals wird Open Source immer mehr wahrgenommen und als Grundlage für 
	etliche Projekte angesehen. \footnote{\cite{WikipediaOpenSource16}}
\end{itemize}
\hfill \break
\paragraph{Momentaner Zustand und Erwartungen für zukünftige Trends}
\hfill \break
\hfill \break
Laut Befragung nutzen bereits jetzt mehr als 75\% der Unternehmen Open Source Software, bei Behörden sind es 
immerhin stolze 59\%. Rund 50\% der Unternehmen sind bestrebt die Entwicklung von Open Source zu unterstützen 
und 32\% der Befragten haben im Unternehmen schon eine Open Source Policy verankert. \footnote{\cite{PWC}} \\
\\
Die Tendenz ist klar steigend. Dies liegt daran, dass Open Source ein Treiber der Innovation ist. Viele neue 
Technologien werden vorerst auf dieser Basis geschrieben und später erst, nachdem diese erprobt wurden, in 
unternehmensinterne Programme aufgenommen. Ein weiterer Vorteil, der auch in der Zukunft nicht unrelevant 
sein wird, ist der Fakt, dass immer mehr Wert auf Open Source Software gelegt wird, da die anfallenden Kosten 
dort deutlich geringer sind. Es kann auf diese frei zugegriffen werden und zusätzlich profitiert man von dem 
weltweiten Netz der Entwickler, die tagtäglich die Software versuchen ein Stück besser zu machen. \footnote{\cite{PWC2}}
Schlussfolgernd ist es auch für Unternehmen vorteilhaft, wenn sie Open Source Projekte jederzeit verändern 
dürfen. Gerade im Bereich der Künstlichen Intelligenz wird ein Fokus auf die Entwicklung als Open Source 
Software gesetzt werden. Nebenbei ist das Thema Sicherheit nie zu vergessen, deshalb wird wohl in Zukunft 
auch auf diesen Bereich, da es immer häufiger zu Cyberattacken kommt, mehr Wert gelegt werden. \footnote{\cite{bitkom}} \\
\subsubsection{Lizenzen}
\paragraph{Definition und Bedeutung}
\hfill \break
\hfill \break
Für das Nutzen jeder Software ist eine Lizenz notwendig. Damit geht der Entwickler mit dem Nutzer
eine Vereinbarung ein, welche angibt, in welchem Ausmaß die Software mit welchen Voraussetzungen verwendet 
werden darf. Bei dem Installieren von Programmen muss man meistens bereits den Nutzungsbedingungen zustimmen. \footnote{\cite{Simpleclub23}} \\
\\
\paragraph{Freie Softwarelizenzen}
\hfill \break
\hfill \break
Als freie Softwarelizenzen können jene verstanden werden, die bei der Nutzung große Freiheiten bezüglich des 
Veränderns, Nutzens und Verbreitens von Software bieten. Dabei ist es allerdings möglich bestimmte Regeln im 
Lizenztext festzuhalten. Dort ist geregelt, ob die Software beispielsweise kommerziell weiterverkauft werden 
darf oder nicht. Zu den bekanntesten Arten der freien Lizenzen zählen unter anderem Open Source und Public 
Domain. Beide bieten größtenteils deren Software an, ohne dafür etwas bezahlen zu müssen. Der Unterschied ist 
allerdings, dass bei einer Public Domain Software der ursprüngliche Urheber entweder auf sein Urheberrecht 
verzichtet hat oder dieses bereits abgelaufen ist. \footnote{\cite{Simpleclub24}} \\
\\
\paragraph{Kommerzielle Softwarelizenzen - Gegenkonzept der freien Softwarelizenzen}
\hfill \break
\hfill \break
Als kommerzielle Softwarelizenzen werden jene bezeichnet, für die man Geld ausgeben muss, um die Software 
verwenden zu dürfen. Im Vergleich zu freien Softwarelizenzen ist die  Veränderung oder Weiterverbreitung allerdings nicht erlaubt, man nennt sie auch 
proprietäre Lizenzen. Es gibt wieder einige unterschiedliche Arten von kommerziellen Softwarelizenzen: \\
\begin{itemize}
	\item Original Equipment Manufacturer (OEM): Beschreibt Lizenzen, die direkt an die Hardware gebunden 
	sind. Diese sind meist schon auf einem neuen PC, beispielsweise eine Windows Lizenz, vorinstalliert.
	\item Concurrent User Lizenz (Floating License): Beschreibt eine Lizenz, die von einer festgelegten 
	Anzahl von Nutzern verwendet werden darf.
	\item Named-User-Lizenz (Arbeitsplatzlizenz): Beschreibt eine Lizenz, die an eine bestimmte Person 
	gebunden ist. Oftmals ist diese Lizenz dann nur über einen Nutzeraccount aktivierbar. \footnote{\cite{Simpleclub25}}
\end{itemize}
\hfill \break
\paragraph{Copyleft Erklärung}
\hfill \break
\hfill \break
Durch den Einsatz von Copyleft stellt der Schöpfer einer Software oder anderer Werke sicher, dass frei 
zugängliche Werke auch in der Form bestehen bleiben, auch, wenn andere diese nutzen, bearbeiten oder 
weiterverbreiten. Jeder, der etwas an der Software ändert, muss diese dann mit denselben Bedingungen, mit 
denen er diese ursprünglich vorgefunden hat, freigeben und darf keine eigenen Regeln festlegen. Es ist also 
nicht möglich diese dann als proprietäre Software zu verkaufen. Unternehmen müssen also, falls sie auf eine 
Copyleft Software zurückgreifen, getätigte Änderungen im Falle einer Veröffentlichung kostenfrei zur Verfügung 
stellen. Da das Copyleft-Prinzip das Urheberrecht verwendet, kann die Freiheit der Nutzer und des Werkes 
geschützt werden, denn genau für diesen Zweck ist dieses ausgelegt worden. \footnote{\cite{GNU}} \\
\\
Da das GNU-Projekt, das von der Free Software Foundation (FSF) ins Leben gerufen wurde, für die 
Rahmenbedingungen der Copyleft Lizenzen verantwortlich ist, haben sie unterschiedliche Konzepte erstellt: \\ 
\begin{itemize}
	\item GNU General Public Liscense (GPL): Stellt sicher, dass die Software frei bleibt und von jedem 
	genutzt, sowie bearbeitet und verbreitet werden darf.
	\item GNU Lesser General Public License (LGPL): Erlaubt Software, die spezielle Softwarebibliotheken 
	nutzt, auch weiterzuverbreiten, solange die Softwarebibliotheken unter der LGPL bleiben.
	\item GNU Affero General Public License (AGPL): Stellt sicher, dass Änderungen von der Software, auf 
	Servern, auch der Öffentlichkeit zur Verfügung gestellt werden müssen.
	\item GNU Free Documentation License (FDL): Stellt sicher, dass Dokumentationen kopiert, bearbeitet und 
	weiterverbreitet werden dürfen, jedoch muss der Autor immer genannt werden. \footnote{\cite{GNU}}
\end{itemize}
\hfill \break
\paragraph{GNU GPL (General Public License)}
\hfill \break
\hfill \break
Die GNU General Public License fällt unter die Copyleft Lizenzen und wurde von GNU beziehungsweise der Free 
Software Foundation entwickelt. Sie ist die restriktivste, der drei genauer betrachteten Lizenzen (siehe [\textcolor{blue}{\autoref{par:Apache}}] und [\textcolor{blue}{\autoref{par:MIT}}]) 
und wurde deshalb zur genaueren Betrachtung gewählt, da sie eine der am weitesten verbreiteten Softwarelizenzen weltweit darstellt. Bei der GPL gelten vier Bedingungen, nämlich, dass das Programm für jeden Zweck 
ausgeführt werden darf, der Quellcode durchgelesen und angepasst werden darf, sowie die Erlaubnis Kopien, 
beziehungsweise auch verbesserte Versionen, in den Umlauf zu bringen. Beim privaten Gebrauch dürfen auch 
Änderungen vorgenommen werden, ohne den Quellcode dann veröffentlichen zu müssen. \footnote{\cite{WikipediaGPL}} \\
\\
\textbf{GPL V1} \\
\\
Die erste Version der GPL wurde 1989 veröffentlicht. Richard Stallman, einer der bekanntesten 
Persönlichkeiten der Free-Software-Bewegung, schrieb diese. Sie erhält die vier Grundbedingungen. \footnote{\cite{WikipediaGPL3}} \\
\\
\textbf{GPL V2} \\
\\
Die zweite Version der GPL wurde 1991, also nur zwei Jahre nach der ersten, veröffentlicht. Es wurden einige 
Unklarheiten beseitigt und Lücken in der Auslegung verschiedenster rechtlicher Aspekte geschlossen. 
Heutzutage stellt die GPL V2 die am meisten verbreite GPL-Lizenz dar. Nicht zuletzt aufgrund der Einfachheit, 
da es ab der GPL V3 deutlich komplexer wurde. \\
\begin{itemize}
	\item Eine wichtige Neuerung stellte die \textquote{Liberty or Death-Klausel} dar. Diese wurde mit dem Sinn 
	eingeführt, dass diejenigen Menschen, die versuchen die Rechte zu beschränken, die einem durch die 
	Lizenz zustehen, diese automatisch verlieren.
	\item Die Systembibliotheken Ausnahme kam in der V2 ebenfalls hinzu. Ab diesem Zeitpunkt war es auch 
	möglich Systembibliotheken in GPL-lizenzierter Software zu verwenden, ohne dabei einen Verstoß zu begehen. 
	Das erleichterte den Entwicklern das Schaffen von neuer Software drastisch.
	\item Wichtige Softwareprojekte, wie beispielsweise der Linux Kernel, wurden unter der GPL V2 
	veröffentlicht. \footnote{\cite{WikipediaGPL3}}
\end{itemize}
\hfill \break
\textbf{GPL V3} \\
\\
Die dritte Version der GPL wurde 2007 veröffentlicht. In dieser wurde der Fokus vor allem auf die technischen 
Neuerungen, die seit der letzten Veröffentlichung stattfanden, gelegt und wie man auf diese am besten 
reagieren kann. Die wichtigsten Neuerungen: \\
\begin{itemize}
	\item Eine wichtige Neuerung stellte das Behandeln von \textquote{Tivoisierung} dar. Das bedeutet, dass 
	Hersteller oftmals GPL-lizensierte Software auf deren Hardware hatten, die nur sie darauf verändern 
	konnten. In der GPL V3 kam die Neuerung hinzu, dass den Nutzern Schlüssel oder Codes zur Verfügung 
	gestellt werden müssen, damit auch modifizierte Software auf der Hardware zugelassen werden kann.
	\item Neu ist auch, dass Patentklagen nun aufgrund bestimmter Bedingungen erschwert werden.
	\item Die Kompatibilität mit anderen Lizenzen wurde erleichtert, zum Beispiel mit der Apache V2.0 Lizenz. \footnote{\cite{WikipediaGPL4}}
\end{itemize}
\hfill \break
\paragraph{Apache}
\label{par:Apache}
\hfill \break
\hfill \break
Die Apache Lizenz wurde 1999 von der Apache Software Foundation (ASF) veröffentlicht. \footnote{\cite{Apache}} 2004 kam dann die 
zweite Version heraus. Sie stellt eine freie Softwarelizenz dar. Es ist also möglich diese zu nutzen, zu 
verändern und schlussendlich auch zu verbreiten. Einige Softwareanwendungen basieren auf der Apache Lizenz, 
wie unter anderem Android. Die Apache Lizenz wird nun genauer betrachtet, da der Apache Webserver auf dieser beruht und einen wichtigen Anteil 
in diesem Segment darstellt. Die Apache Lizenz ist offener als die GNU GPL, aber restriktiver als die MIT. Der Fokus liegt bei der Apache Lizenz wieder einmal darauf, dass die 
Software frei bleibt. Die Free Software Foundation hat außerdem offiziell bekanntgegeben, dass Apache zu der 
freien Software zählt. Die Apache V2.0 ist außerdem zur GNU GPL V3 kompatibel, zur GPL V2, die sehr oft 
Anwendung findet, allerdings nicht. \footnote{\cite{WikipediaApache}} \\
\\
Werke mit Apache V2.0 Lizenz müssen: \\
\begin{itemize}
	\item eine Kopie der Apache Lizenz beinhalten
	\item angeben, wenn diese modifiziert wurden und dies an einer gut sichtbaren Stelle vermerken
	\item alle originalen Urheberrechtsvermerke innerhalb der Quellform angeben
	\item im Falle des Vorhandenseins einer Textdatei mit dem Namen \textquote{NOTICE}, die 
	darinstehenden Urhebervermerke enthalten \footnote{\cite{WikipediaApache}}
\end{itemize}

\paragraph{MIT}
\label{par:MIT}
\hfill \break
\hfill \break
Die MIT Lizenz (auch bekannt als X Consortium, X- oder X11-Lizenz) wurde 1987 vom Massachusetts Institute of Technology veröffentlicht. Sie ist für ihre Einfachheit und Flexibilität bekannt und stellt die offenste 
Lizenz dar. Sie wurde damals als Erstes für das X-Window System-Projekt eingesetzt. Dieses ermöglicht es, dass Fenster auf Bitmap-Displays angezeigt werden können, also vereinfacht gesagt stellt es eine grafische 
Benutzeroberfläche dar. \footnote{\cite{Holton1}} Die MIT Lizenz erlaubt die Verwendung, Modifikation und Verbreitung des Quellcodes und muss nicht unter der gleichen Lizenz veröffentlicht werden. Es ist außerdem erlaubt, dass diese auch 
in proprietäre Software eingebunden werden darf. Essenziell ist, dass bei jeglichen Kopien oder Modifikationen der Software der ursprüngliche Urheberrechtsvermerk, sowie die Lizenz selbst, angegeben werden müssen. 
Erlaubt ist allerdings, dass der Code weiterlizensiert werden darf, also, dass man bei einer Modifikation eine restriktivere Lizenz miteinbeziehen kann. Da die MIT Lizenz sehr offen ist, wird sie von Entwicklern sehr 
gerne verwendet. \footnote{\cite{Holton2}} jQuery (JavaScript Bibliothek für Webseiten), oder Node.js (JavaScript-Laufzeitumgebung) basieren beispielsweise auf der MIT Lizenz. \footnote{\cite{Holton3}}

\subsection{Creative Commons}
\subsubsection{Definition und Bedeutung}
Creative Commons (CC) will Urhebern durch vorgefertigte Lizenzverträge helfen, dass diese ihre Werke mit 
bestimmten Bedingungen veröffentlichen können. Dabei ist es wichtig zu wissen, dass Creative Commons eine 
Not-Profit-Organisation ist. Die vorgefertigten CC-Lizenzen können bei dem eigens geschaffenen Werk angewandt 
werden. Es gibt sechs verschiedene Lizenzverträge, wobei jede davon den Nutzern andere beziehungsweise mehr 
Rechte gewährt. \footnote{\cite{CreativeCommons35}}  Dadurch ist kein juristisches Fachwissen mehr erforderlich, um ein Werk für die 
Öffentlichkeit preiszugeben, Creative Commons hat diesen Teil bereits bei dem Erstellen der 
Standard-Lizenzverträge übernommen. Die Kreativität kann somit leichter gefördert werden, da durch die 
CC-Lizenzverträge genau geregelt wird, ob man ein Werk beispielsweise bearbeiten und danach veröffentlichen 
darf oder nicht. Auch, wenn eine CC-Lizenz an einem Werk angewandt wurde, ist es möglich, dass bestimmten 
Personen zusätzliche Rechte gewährt werden, die eigentlich laut CC-Lizenz nicht erlaubt wären. Eine 
Beschneidung der Rechte für bestimmte Personen ist allerdings in keinem Fall zulässig. \footnote{\cite{CreativeCommons36}} \\
\\
Creative Commons Lizenzen werden häufig aufgrund bestimmter Interessen verwendet: \\
\begin{itemize}
	\item Ergänzung von neuen Inhalten, die auf einem ursprünglichen Werk beruhen
	\item Bearbeitung wird vereinfacht und die Nennung des Urhebers wird dadurch wahrscheinlicher (gleiche Art der Nennung bei CC-lizenzierten Werken)
	\item Open Source unterstützen und fördern, da man dadurch auch selbst profitieren kann
	\item Höhere Wahrscheinlichkeit der Verbreitung des Werkes, aufgrund von standardisierten bekannten CC-Lizenzbedingungen \footnote{\cite{CreativeCommons37}}
\end{itemize}
\hfill \break

\subsubsection{Überblick der Lizenzen}
Mittlerweile gibt es die Creative Commons Lizenzen in der Version 4. \\
\\
In der ersten Version wurden die grundlegenden Bedingungen festgehalten.  In der zweiten Version wurde es dann möglich gemacht, dass auf die 
Namensnennung verzichtet werden darf, aber nur, wenn ein driftiger Grund dies fordert.  In der dritten Version wurde darauf Wert gelegt, dass 
die Lizenzen international besser angewandt werden können, wobei der Fokus vor allem auf der Kompatibilität mit der GNU GPL V3 lag.  Ab der 
vierten Version sind keine Angaben des Materialtitels mehr nötig. Außerdem wurden Formulierungen vereinfacht, die Anpassung an lokale Gesetze 
vereinfacht, sowie die Internationalisierung angestrebt. \\
\\
Es gibt sechs verschiedene CC -Lizenzen (V4.0). Diese reichen von weitgehender Offenheit zu größerer Kontrolle des Urhebers: \\
\begin{itemize}
	\item CC BY (Attribution): Bei dieser \textquote{Namensnennung} Lizenz darf das Werk uneingeschränkt genutzt werden. Der Autor, sowie 
	Urheberrechtshinweise und Links zur Originalquelle müssen angegeben werden. \footnote{\cite{bpb}}
	\begin{figure}[H]
		\begin{center}
			\scalebox{0.4}
			{\includegraphics[width=0.8 \linewidth]{CC-BY}}
			\caption{CC BY (\textcolor{blue}{Quelle: \cite{CreativeCommonsBilder}})}
			\label{fig:CC BY}
		\end{center}
	\end{figure}
	\hfill \break
	\item CC BY-SA (Attribution-ShareAlike): Bei dieser \textquote{Namensnennung-Weitergabe unter gleichen Bedingungen} Lizenz wird Copyleft 
	ausschlaggebend. Das bedeutet, dass die Bearbeitung und Weiterverteilung nur dann erlaubt ist, wenn die ursprüngliche Lizenz vorhanden 
	bleibt. (Ansonsten ident mit CC BY). \footnote{\cite{bpb}}
	\begin{figure}[H]
		\begin{center}
			\scalebox{0.4}
			{\includegraphics[width=0.8 \linewidth]{CC-BY-SA}}
			\caption{CC BY-SA (\textcolor{blue}{Quelle: \cite{CreativeCommonsBilder}})}
			\label{fig:CC BY-SA}
		\end{center}
	\end{figure}
	\hfill \break
	\item CC BY-NC (Attribution-NonCommercial): Bei dieser \textquote{Namensnennung-Nicht-kommerziell} Lizenz ist keine kommerzielle Nutzung 
	des Werkes erlaubt. (Ansonsten ident mit CC BY). \footnote{\cite{bpb}}
	\begin{figure}[H]
		\begin{center}
			\scalebox{0.4}
			{\includegraphics[width=0.8 \linewidth]{CC-BY-NC}}
			\caption{CC BY-NC (\textcolor{blue}{Quelle: \cite{CreativeCommonsBilder}})}
			\label{fig:CC BY-NC}
		\end{center}
	\end{figure}
	\hfill \break
	\item CC BY-NC-SA (Attribution-NonCommercial-ShareAlike Lizenz): Bei dieser \textquote{Namensnennung-Nicht-kommerziell-Weitergabe unter gleichen 
	Bedingungen} Lizenz dürfen Bearbeitungen vorgenommen werden. Die Weiterverteilung davon ist unter den ursprünglichen Bedingungen erlaubt, 
	allerdings nicht für kommerzielle Zwecke. (Ansonsten ident mit CC BY-NC). \footnote{\cite{bpb}}
	\begin{figure}[H]
		\begin{center}
			\scalebox{0.4}
			{\includegraphics[width=0.8 \linewidth]{CC-BY-NC-SA}}
			\caption{CC BY-NC-SA (\textcolor{blue}{Quelle: \cite{CreativeCommonsBilder}})}
			\label{fig:CC BY-NC-SA}
		\end{center}
	\end{figure}
	\hfill \break
	\item CC BY-ND (Attribution-NoDerivatives): Bei dieser \textquote{Namensnennung-Keine Bearbeitung} Lizenz ist keine Bearbeitung des Werkes erlaubt, 
	weshalb dieses nur in unveränderter Form veröffentlicht und geteilt werden darf. (Ansonsten ident mit CC BY). \footnote{\cite{bpb}}
	\begin{figure}[H]
		\begin{center}
			\scalebox{0.4}
			{\includegraphics[width=0.8 \linewidth]{CC-BY-ND}}
			\caption{CC BY-ND (\textcolor{blue}{Quelle: \cite{CreativeCommonsBilder}})}
			\label{fig:CC BY-ND}
		\end{center}
	\end{figure}
	\hfill \break
	\item CC BY-NC-ND (Attribution-NonCommercial-NoDerivatives): Bei dieser \textquote{Namensnennung-Nicht-kommerziell-Keine Bearbeitung} 
	Lizenz sind keine Bearbeitungen erlaubt und ebenso wenig die kommerzielle Nutzung. (Ansonsten ident mit CC BY). \footnote{\cite{bpb}}
	\begin{figure}[H]
		\begin{center}
			\scalebox{0.4}
			{\includegraphics[width=0.8 \linewidth]{BY-NC-ND}}
			\caption{BY-NC-ND (\textcolor{blue}{Quelle: \cite{CreativeCommonsBilder}})}
			\label{fig:BY-NC-ND}
		\end{center}
	\end{figure}
	\hfill \break
\end{itemize}
\hfill \break
Die CC0 (Public Domain Dedication) stellt die vollständig offene Lizenz dar. Der Urheber gibt hierbei vollständig sein Urheberrecht auf und 
verzichtet ebenso auf sämtliche Schutzrechte. Mit dem Werk, das mit CC0 lizenziert wurde, darf also alles gemacht werden. \footnote{\cite{CreativeComonsLizenz}} \\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.4}
		{\includegraphics[width=0.8 \linewidth]{CCO}}
		\caption{CCO (\textcolor{blue}{Quelle: \cite{CreativeCommonsBilder}})}
		\label{fig:CCO}
	\end{center}
\end{figure}

\newpage
%=============================================================================
%=============================================================================

\section{VWTT - Sicherheitsaspekte der MRK [\textcolor{blue}{Szabo}]}
\subsection{Einleitung}
\subsubsection{Hintergrund und Motivation}
Der Hintergrund dieser vorwissenschaftlichen Arbeit besteht darin, mögliche 
Sicherheitsanforderung, die für unser Diplomprojekt relevant sind, kennenzulernen 
und gegebenenfalls umzusetzen. Aufgrund von unvorhersehbaren Ereignissen in 
elektronischen Bauteilen, Programmabläufen und Berechnungen, sind die Vorschriften 
zur Absicherung von Menschen bei der Verwendung von Robotern unerlässlich, wenn 
ein solches Produkt vermarktet werden soll. \\
\\
Da die bionische Hand, gebaut von dem in der Dokumentation beschriebenen 
Entwicklerteam, erhebliche Kraft hat und dadurch Verletzungen an Körperteilen 
entstehen könnten, ist der Sicherheitsaspekt ein grundlegender Projektteil, um 
den Entwicklungsprozess zu vollenden. \\
\subsubsection{Ziel der Arbeit}
Das Ziel dieser Ausarbeitung ist es, Wissen über diverse Sicherheitsstandards und 
Normen zu sammeln und diese in Zukunft in Bezug auf das Diplomprojekt umzusetzen. \\
\\ 
Diesbezüglich werden im folgenden Verlauf der Arbeit diverse Punkte beschrieben, 
die es bei der Konzeptionierung und Umsetzung von Sicherheitsstandards -und Normen 
zu beachten gilt. Es wird erklärt, was als Zusammenarbeit von Menschen und Roboter 
gesehen wird und welche Arten dieser gemeinsamen Arbeit, beziehungsweise 
Kollaboration, existieren. Anschließend werden die dazugehörigen 
Sicherheitsaspekte näher erläutert und die damit verbundenen Standards und Normen 
beschrieben. Gegen Ende werden noch Technologien und Praktiken genannt, die 
derzeit in der Industrie angewendet werden, um Vorfälle jeglicher Art zu vermeiden. \\

\subsection{Grundlagen der Mensch-Roboter-Kollaboration}
\subsubsection{Definition}
Die Grundidee der Mensch-Roboter-Kollaboration ist die Zusammenarbeit zwischen 
Menschen und industriell verwendeten Robotern. Dadurch sollen die Stärken beider 
Parteien vereint und die Schwächen minimiert werden. Heute wird jede Art der 
Zusammenarbeit, die keine robuste Abgrenzung, wie zum Beispiel einen Zaun oder 
eine Glasscheibe, hat, als Kollaboration zwischen Mensch und Roboter bezeichnet. 
Da Zusammenarbeit allerdings bedeutet an einer Aufgabe gemeinsam und zur gleichen 
Zeit zu arbeiten, müssen die verschiedenen Arbeitsschritte koordiniert und 
aufgeteilt werden. \footnote{\cite{rubigm.p10}} \\
\\
Um die Arten der Arbeitsteilung zu unterteilen, existieren vier verschiedene 
Bereiche, die das Frauenhofer-Institut für Arbeitsorganisation definiert hat. Im 
folgenden Punkt werden diese Bereiche genannt und näher beschrieben. \footnote{\cite{rubigm.p11}}\\
\subsubsection{Arten der Zusammenarbeit}
\paragraph{Koexistenz}
\hfill \break
\hfill \break
Bei der Koexistenz ist ein Kontakt zwischen Mensch und Maschine nicht vorgesehen. 
Beide Parteien arbeiten allerdings im selben Raum und sind physisch nicht 
voneinander isoliert. Dies könnte bei Fehlfunktionen des Roboters zu unerwünschten 
Kontakten führen, weshalb auch bei der Koexistenz ein Sicherheitskonzept und 
Schutzmaßnahmen vorhanden sein müssen. \footnote{\cite{rubigm.p11}} \\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.4}
		{\includegraphics[width=0.8 \linewidth]{Koexistenz}}
		\caption{Koexistenz \textcolor{blue}{Quelle: \cite{rubigm.p11}}}
		\label{fig:Koexistenz}
	\end{center}
\end{figure}
\hfill \break
\paragraph{Synchonisation}
\hfill \break
\hfill \break
Wie das Wort synchron impliziert, ist bei dieser Art der Zusammenarbeit eine 
zeitliche Abhängigkeit der Arbeitsschritte vorhanden. Mensch und Roboter arbeiten 
immer noch getrennt voneinander, jedoch wird nun ein Arbeitstakt vorgegeben. Dies 
dient zur zeitlichen Festlegung der verschiedenen Produktionsschritte, wodurch 
Kontakte zwischen Mensch und Roboter vermieden werden sollen. \footnote{\cite{rubigm.p11}}\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.4}
		{\includegraphics[width=0.8 \linewidth]{Synchronisation}}
		\caption{Synchronisation \textcolor{blue}{Quelle: \cite{rubigm.p11}}}
		\label{fig:Synchronisation}
	\end{center}
\end{figure}
\hfill \break
\paragraph{Kooperation}
\hfill \break
\hfill \break
Bei der Kooperation arbeiten beide Parteien gemeinsam in einem definierten 
Arbeitsraum. Ein Kontakt von Mensch und Maschine ist hier ebenfalls nicht 
vorgesehen, jedoch kann an mehreren Werkstücken gleichzeitig gearbeitet werden. 
Dies erfordert schon wesentlich komplexere Sicherungsmaßnahmen als bei der 
Synchronisation und Koexistenz. \footnote{\cite{rubigm.p11}}\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.4}
		{\includegraphics[width=0.8 \linewidth]{Kooperation}}
		\caption{Kooperation \textcolor{blue}{Quelle: \cite{rubigm.p11}}}
		\label{fig:Kooperation}
	\end{center}
\end{figure}
\hfill \break
\paragraph{Kollaboration}
\hfill \break
\hfill \break
Die Kollaboration ist die fortgeschrittenste Arbeitsweise, bei der Mensch und 
Roboter gleichzeitig im selben Arbeitsraum und möglicherweise am selben Werkstück 
arbeiten. Ein kontrollierter Kontakt kann bei der Kollaboration durchaus Teil des 
Arbeitsablaufs sein. \footnote{\cite{rubigm.p11}}\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.4}
		{\includegraphics[width=0.8 \linewidth]{Kollaboration}}
		\caption{Kollaboration \textcolor{blue}{Quelle: \cite{rubigm.p11}}}
		\label{fig:Kollaboration}
	\end{center}
\end{figure}

\subsection{Sicherheitsaspekte}
\subsubsection{Gefahren und Risiken}
Wie bei Computern und anderen Geräten mir elektronischen Bauteilen und Mikrochips, 
bieten Roboter eine vielfältige Angriffsfläche für Hacker. Die folgende Liste des 
TÜV Austria (2016), zeigt die zehn häufigsten Bedrohungen, die von IT-Angreifern 
genutzt werden. \footnote{\cite{TÜVaustria}} \\
\begin{itemize}
	\item Social Engineering and Pishing
	\item Einschleusen von Schadsoftware über Hardware (z.B. USB-Sticks)
	\item Infektion mit Schadsoftware über Inter- und Intranet
	\item Einbruch über Wartungsfernzugänge
	\item Menschliches Fehlverhalten/Sabotage
	\item Internet verbundene Steuerungskomponenten
	\item Technisches Fehlverhalten, höhere Gewalt
	\item Kompromittierung von Extranet und Cloud-Komponenten
	\item (D) DoS Angriffe
	\item Kompromittierung von Smartphones im Produktionsbetrieb \footnote{\cite{TÜVaustria}}
\end{itemize}
\hfill \break
Bei diesen Arten der Bedrohung, handelt es sich um sogenannte Primärangriffe. 
Diese werden verwenden, um Sabotage auszuüben und Geräte zu manipulieren. Durch 
diese gezielten Angriffe, können sowohl Maschinen beschädigt als auch Menschen 
verletzt werden, da durch die Übernahme fremder Personen alle Sicherheitsmaßnahmen 
außer Kraft gesetzt werden. \footnote{\cite{TÜVaustria}}\\
\\
Die Schutzziele werden in der CIA-Triade zusammengefasst. [\textcolor{blue}{siehe \cite{CIAtriade}}] \\
\\
In den folgenden Punkten werden Gefahren und Risiken erläutert, die nicht nur 
durch etwaige Hacker-Angriffe oder anderweitige illegale Tätigkeiten entstehen 
könnten. \\
\\
\paragraph{Kollisionen}
\hfill \break
\hfill \break
Unerwartete Störungen und Fehlfunktionen können jederzeit auftreten. Dies gilt für 
den Betrieb, als auch für den Zeitraum, indem die Maschine von der elektrischen 
Versorgung getrennt ist. Die möglichen Gefahren beim Stillstand des Roboters 
werden allerdings nicht erläutert, es handelt sich hierbei ausschließlich um 
Ereignisse, die beim Betrieb eines Roboters auftreten können. \\
\\
Kollisionen kommen bei geprüften Robotersystem eher selten vor, allerdings heißt 
dies nicht, dass diese nicht auch bei technisch abgenommenen Maschinen vorkommen 
können. Durch mechanische Abnutzung und Verschleiß können jederzeit 
unvorhergesehene Schwächen in der physischen Integrität auftreten, wodurch 
Bewegungen plötzlich anders als gewünscht geschehen können. Nicht nur das, Teile 
könnten genauso nachgeben und abbrechen, wodurch der Kollaborateur erheblichen 
Schaden nehmen könnte. Dies gilt es mit allen Mitteln zu verhindern, weshalb 
Richtlinien und Normen [siehe \textcolor{blue}{\autoref{chap:Sicherheitsstandards und Normen}}]
unbedingt eingehalten und dauerhaft verbessert werden müsse3n. Die schon vorhandenen 
Sicherheitsmaßnahmen, die zusätzlich zu diversen Richtlinien umgesetzt werden, 
sind in [\textcolor{blue}{\autoref{chap:Lösungen zur Verbesserung der Sicherheit bei der MRK}}] beschrieben. \\
\\
Es wird nach der Dauer des Kontakts und nach der Möglichkeit für die Person sich 
zu befreien entschieden, welche Art der Kollision vorliegt. Die genaue 
Beschreibung dieser Kontaktsituationen ist in der ISO/TS 15066 nachzulesen. \footnote{\cite{Frauenhofer17}} \\
\\
Allgemein gesehen gibt es zwei Arten von Kollisionen, die zwischen dem Menschen 
und einem Roboter auftreten können: \\
\\
\textbf{Quasi-statische Kollisionen} \\
\\
Bei einer quasi-statischen Kollision ist der Kontakt mit mindestens 0,5 Sekunden 
definiert, wobei die betroffene Person nun in dem Zwischenfall gefangen ist. Das 
bedeutet, dass eingeklemmte Körperteile nicht aus eigener Kraft wieder befreit 
werden können. \\
\\
Die Grenzwerte für die quasi-statische Kollision werden mithilfe der 
Schmerzgrenzen in Bezug auf eine gewisse ausgeübte Kraft des Roboters ermittelt. 
Dies gilt für 29 spezifische Körperzonen und wurde 2014 vom Institut des 
Arbeitsschutzes (IFA) und der Universität Mainz an 100 Personen getestet. Die 
Testresultate wurden in der ISO/TS 15066:2016 veröffentlicht. \footnote{\cite{Frauenhofer17}} \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{Schmerzenszonen}}
		\caption{Schmerzbereiche eines Menschen (\textcolor{blue}{Quelle: \cite{Frauenhofer18}})}
		\label{fig:Schmerzenszonen}
	\end{center}
\end{figure}
\hfill \break
In \autoref{fig:Schmerzenszonen} sind die verschiedenen Druckzonen zu sehen. Die 
Maßeinheit der rechten Zahlenspalte ist N/cm2 (Newton pro Quadratzentimeter) und 
die der linken Spalte nur N (Newton). \\
Für die verunglückte Person müssen also zwei Grenzwerte eingehalten werden. Die 
maximale Kraft bei der Kollision, als auch der ausgeübte Druck des Roboters auf 
den Menschen. \\
\\
Es ist gut zu erkennen, dass die Empfindlichkeit bezüglich der Krafteinwirkung 
und dem ausgeübten Druck vom Kopf zu den Füßen abnimmt. Da das Herz bei den 
meisten Menschen im linken Brustbereich sitzt, ist diese Hälfte des Oberkörpers 
auch deutlich empfindlicher. Die Folge ist, das strengere Grenzwerte gelten. \footnote{\cite{Frauenhofer18}} \\
\\
Um sich etwas mehr unter den Grenzwerten vorstellen zu können, kann gesagt werden, 
dass eine Kraft von $65N$ einem $6,5kg$ schweren Objekt gleicht, dass in Ruhe auf 
einem Tisch liegt. Das bedeutet, dass der Grenzwert der Kraft im Kopfbereich 
schon erreicht ist, wenn ein $6,5kg$ schweres Objekt auf dem Kopf liegt. Im 
Bauchbereich wäre der Grenzwert gleichzusetzen mit einem $13kg-14kg$ scheren 
Gegenstand, der nicht bewegt wird. Dabei entsteht die Kraft rein durch die 
Erdanziehungskraft. \\
\\
\textbf{Transiente Kollisionen} \\
\\
Bei einer transienten Kollision dauert der Kontakt zwischen Mensch und Roboter 
maximal 0,5 Sekunden und die betroffene Person hat die Möglichkeit noch 
auszuweichen oder Körperteile zurückzuziehen. \\
\\
Die Grenzwerte bei der transienten Kollision werden in der Norm ISO/TS 15066 auf 
ungefähr das doppelte Maß als bei der quasi-statischen Kollision geschätzt. \footnote{\cite{Frauenhofer17}} \\
\\
\paragraph{Unvorhersehbare Bewegungen}
\hfill \break
\hfill \break
Es existieren viele verschiedene Antriebsarten für Roboter: \\
\begin{itemize}
	\item Servomotoren
	\item Schrittmotoren
	\item Hydraulische Systeme
	\item Pneumatische Systeme
\end{itemize}
\hfill \break
Alle diese Konzepte sind dafür konzipiert eine Sache so genau wie möglich zu 
bewegen. Dies reicht von einfachen Zahnrädern bis hin zu komplexen Bestandteilen 
von Robotern wie Arme oder Greifer. Jedes Ansteuerungsprinzip benötigt eine Art 
von elektronischer Schaltung, um die Bewegungen eines Roboters zu kontrollieren. \\
\\
Auch die sicherste Schaltung mit den besten Bauteilen und der besten Programmierung 
wird an einem Punkt ihrer Betriebszeit einen Fehler erzeugen. Dies könnte in 
unvorhersehbaren Bewegungen des Roboters resultieren, welche den gerade Arbeitenden 
verletzen könnte. Doch nicht nur durch elektronische Fehler, sondern auch durch 
Unstimmigkeiten in der Mechanik können zufällige Bewegungen entstehen. Servomotoren 
könnten über ihre vorgegebene Drehgrenze drehen, was bei dem Projekt RoboGlove – 
bionische Hand zu erheblichen Schwierigkeiten führen würde. Es könnten Roboterfinger 
abbrechen und Schnüre reißen. Wenn durch solch eine unvorhersehbaren Fehlfunktion 
Roboterteile beschädigt, werden ist eine sichere Zusammenarbeit für den Mensch 
nicht mehr möglich. Präventive Maßnahmen und Lösungsansätze für destruktive 
Fehlfunktionen werden in [\textcolor{blue}{\autoref{chap:Lösungen zur Verbesserung der Sicherheit bei der MRK}}]
beschrieben. \\
\\
Falls bei unvorhersehbaren Bewegungen Kollisionen entstehen, sind die gleichen 
Vorschriften wie in Punkt (Kollisionen) zu erfüllen. \\
\subsubsection{Sicherheitsstandards und Normen}
\label{chap:Sicherheitsstandards und Normen}
Normen und Sicherheitsstandards sind Anforderungen, die von jeglichen Institutionen 
in Bezug auf Produkte, Dienstleistungen und Verfahren umgesetzt werden müssen. 
Diese Richtlinien tragen maßgeblich zur bedenk losen Verwendung von 
Alltagsgegenständen bei und schaffen Klarheit im öffentlichen Warenverkehr. \\
\\
Prüfungen von technischen, und auch anderen, Dingen, können durch Normen wesentlich 
erleichtert werden, da diese eine Grundlage für das Vergleichen von spezifischen 
Eigenschaften generiert. \\
\\
Es existieren drei Kategorien in die Normen aufgeteilt werden: \\
\begin{itemize}
	\item Typ-A 
	\item Typ-B 
	\item Typ-C 
\end{itemize}
\hfill \break
Je weiter hinten der Buchstabe der Typenbezeichnung im Alphabet steht, desto 
genauer sind die zu erfüllenden Anforderungen, um sich für die gewählte Norm zu 
qualifizieren. \footnote{\cite{FHvorarlberg}} \\
\\
Folgende Normen und Sicherheitsstandards sind bei der MRK 
(Mensch-Roboter-Kollaboration) zu beachten: \\
\\
\paragraph{ISA / IEC 62443}
\hfill \break
\hfill \break
Diese internationale Norm beschreibt die Sicherheitsanforderung in Bezug auf 
Cybersecurity. Es werden die besten Praktiken beschrieben, um Sicherheitsrelevante 
Systeme gegen externe Angriffe zu schützen und dies mit der Prozesssicherheit bei 
der Mensch Roboter Kollaboration zu kombinieren. \\
\\
Dieser Standard ist der Überbegriff für viele weitere Normen. Diese beschreiben 
Unterpunkte der Sicherheit bei der Programmierung, Internetverbindung und 
generelle Vorschläge wie externe Eingriffe in das lokale Steuerungsnetzwerk 
verhindert werden können. \footnote{\cite{ISA}} \\ 
\\
\subsubsection{EU Vorschriften}
Zu den Aufgaben der europäischen Union gehört es, Richtlinien und Gesetze zu 
erlassen, die Arbeitende schützen. Dies gilt für jegliche Art eines Betriebs, 
wozu auch die Mensch-Roboter-Kollaboration gehört. \\
\\
Jeder Mitgliedstaat der EU muss diese Vorschriften umsetzen. Dies ist der Fall, 
da entschieden wurde das CE-Kennzeichen an jedem verkauften Produkt anbringen zu 
müssen. Diese Kennzeichnung dient der Sicherheit der Benutzer und muss von jedem 
Hersteller, der im europäischen Raum verkauft, eingehalten werden. \\
\\
\paragraph{EN61508}
\hfill \break
\hfill \break
Die europäische Norm EN61508 befasst sich mit der funktionalen Sicherheit 
elektrischer und programmierbarer Systeme. Diese Sicherheitsgrundnorm ist 
unabhängig von der Anwendung, also nicht spezifisch für Robotersysteme, und ist 
für die allgemeine Sicherheit von Steuerungssystemen zuständig. \\
\\
Der Fokus der Norm liegt auf dem Lebenszyklus eines Sicherheitsrelevanten 
Steuerungssystems. Zusätzlich wird auch beschrieben, wie der Entwurf elektrischer 
Systeme und der zugehörigen Software abzulaufen hat. Dies dient hauptsächlich den 
Herstellern der gerade beschriebenen Systeme. \\
\\
Für den Endanwender ist die Norm EN 62061 oder EN ISO 13849-1/-2 interessanter. 
Dies sind die Standards für funktionale Sicherheit, in denen die Sicherheitsstufen 
der einzelnen Steuerungssysteme beschrieben werden. Es sind Geräte, Sensoren und 
komplette Steuerungen in Safety Integrity Levels von 1 bis 4 eingestuft. \footnote{\cite{Pilz}}\\
\\
\paragraph{Maschinenrichtlinie 2006/47/EG}
\hfill \break
\hfill \break
In dieser Maschinenrichtlinie wird die einheitliche Inverkehrbringung 
Sicherheitsrelevanter Maschinen und Systeme geregelt. Das Ziel ist es in Europa 
den gleichen grundlegenden Sicherheitsstandard zu erreichen. Anforderungen dieser 
Norm sind zum Beispiel: \\
\begin{itemize}
	\item Die mechanisch und elektrisch sichere Gestaltung von Maschinen (sichere Steuerkreise, etc…)
	\item Die Gewährleistung einer sicheren Bedienung und Inbetriebnahme
	\item Die möglichst schwere Umgehbarkeit von Sicherheitseinrichtungen an Maschinen zu sichern
\end{itemize}
\hfill \break
Diese Maschinenrichtlinie ist ein Teil des Verfahrens, um das CE-Kennzeichen zu 
bekommen. \footnote{\cite{TÜVsüd}}\\
\\
\subsubsection{Nationale Vorschriften (Österreich)}
Als Mitgliedsstaat der europäischen Union, muss Österreich alle in Brüssel 
erlassenen Normen und Standards umsetzen. Nationale Abweichungen dieser Richtlinien 
können, nach Absprache mit der EU vorgenommen werden. In Bezug auf die maschinelle 
und interne Sicherheit von elektrischen und Sicherheitsrelevanten Systemen existieren 
solche Abänderungen nicht. \\
Europäische Richtlinien müssen als nationales Gesetz angesehen werden und dürfen 
nicht umgangen werden! \footnote{Fachlehrer Baumgartner} \\
\\
\subsection{Lösungen zur Verbesserung der Sicherheit bei der MRK}
\label{chap:Lösungen zur Verbesserung der Sicherheit bei der MRK}
\subsubsection{Sensortechnologien}
Abstandssensoren sind für die sichere Verwendung von Robotern essenziell. Ohne 
diese Sicherheitsmaßnahmen zur Vermeidung von Kollisionen, wäre die 
Mensch-Roboter-Kollaboration nicht zu realisieren. \\
\\
Eine einfache und sehr vielfältige Methode Abstände zu messen sind 
Ultraschallsensoren, die an verschiedenen Positionen eines Roboters angebracht 
sind. Weitere Technologien umfassen Infrarotsensoren, Lasersensoren und 
Kontaktsensoren. Letzteres kommt bei der MRK aufgrund des Kontaktes nicht in 
Frage. \\
\\
Folgende Tabelle zeigt einen Überblick der genannten Technologien: \\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{Tabelle_Sensorübersicht}}
		\caption{Flexsensor (\textcolor{blue}{Quelle: \cite{Generationrobots}})}
		\label{fig:Tabelle_Sensorübersicht}
	\end{center}
\end{figure}
\hfill \break
\paragraph{Ultraschallsensoren}
\hfill \break
\hfill \break
Diese Art der Sensoren funktionieren mithilfe der Schallausbreitung im Raum. Ein 
Ultraschallsignal (etwa $40kHz$) wird ausgesendet und die Reflexionen wieder 
empfangen. Da die Schallgeschwindigkeit mit $1236 km/h$ konstant ist, kann durch
die vergangene Zeit die Entfernung eines Objekts oder eines Hindernisses berechnet 
werden. \\
\\
Der effektive Abstrahlbereich der Ultraschallwellen beträgt zirka 30\textdegree. 
Aufgrund dessen müssen entweder mehrere Sensoren verwendet werden, oder eine 
bewegliche Vorrichtung entworfen, auf der der Ultraschallsensor montiert wird. 
Die Positionsbestimmung ist durch den breiten Abstrahlwinkel der Wellen relativ 
ungenau. Das bedeutet, dass Objekte nicht genau im Raum geortet werden können. 
Bei der MRK ist eine genaue Objekterkennung allerdings notwendig, da nur von 
Bedeutung ist, ob ein Objekt im Weg ist oder nicht. Der Sensor muss also nur dazu 
fähig sein den Roboter bei auftretenden Hindernissen zu stoppen, ganz egal wo 
genau sich das störende Objekt genau befindet. \footnote{\cite{Generationrobots}} \\
\\
Sollte der Winkel, mit dem die Ultraschallwellen auf ein Objekt treffen, zu spitz 
sein, so funktioniert die Objekterkennung nicht mehr, da die reflektierten 
Strahlen nicht wieder zurück zum Empfänger des Sensors geleitet werden. \\
\\
Die Struktur des zu erkennenden Objekts spielt ebenfalls eine Rolle bei der 
Qualität des Empfang Signals. Generell kann angenommen werden, dass Materialien 
die Geräuschdämmend sind, wie zum Beispiele Teppiche, schlecht reflektieren und 
daher die Objekterkennung erheblich erschwert ist. Dies könnte bei dem Gewand 
einer Person ebenso der Fall sein. \\
\\
Weiß der Roboter nach dem Stoppen vor einem Hindernis (einem Mensch) allerdings 
nicht genau wo er sich im Raum befindet, muss dieser von einem Mitarbeiter wieder 
in die Ursprungssituation zurückgebracht werden. So kann ein erneuter sicherer 
Start erfolgen. Dies nennt man auch \textquote{Perceptual Aliasing} und beschreibt die 
zweideutige Situation eines Roboters aufgrund von Informationsmangel. Die nächste 
sichere Bewegung ist nicht eindeutig, daher wird ein Mensch benötigt, um den 
Betrieb wieder zu starten. \footnote{\cite{Generationrobots}} \\
\\
\subsubsection{Softwarebasierte Sicherheitsmaßnahmen}
Bei der Programmierung von Sicherheitsrelevanten MRK-Systemen muss auf einige 
Aspekte Acht gegeben werden. Dies beinhaltet vor allem die biomechanischen Limits, 
die im Punkt Kollisionen erläutert werden. Die Schwierigkeit besteht darin, die 
Performance des Roboters nicht zu beeinträchtigen, allerdings nicht zu schnelle 
und riskante Bewegungen zu verwenden und somit Menschen zu gefährden. \footnote{\cite{Frauenhofer21}} \\
\\
Um dies zu verhindern, müssen folgende Punkte beachtet werden: \\
\begin{itemize}
	\item Auf mögliche Interaktionspunkte mit dem Menschen langsam zufahren 
	(Greifen, Quetschen, …)
	\item Überwachung des Kraftaufbaus beim Greifen von Objekten
	\item Die Bewegungsabläufe sollten gut geplant sein und den Personen im Umfeld bekannt sein
\end{itemize}
\hfill \break
Dies sind nur wenige Punkte, die bei der Programmierung beachtet werden müssen. 
Die Devise lautet jedoch: Je mehr die Menschen über die nächsten Bewegungen des 
Roboters bescheid wissen, desto geringer ist die Gefahr einer potenziellen 
Kollision. Somit sollte die Sicherheitseinrichtungen in der Software nur im 
äußersten Notfall aktiviert werden. \footnote{\cite{Frauenhofer21}} \\
\\
\subsubsection{Physische Sicherheitsmaßnahmen}
\paragraph{Roboterbezogen}
\hfill \break
\hfill \break
Bei der Konstruktion eines Roboters muss unbedingt auf die Abschirmung 
potenzieller Gefahrenquellen in Bezug auf die Mechanik geachtet werden. Dies gilt 
für Elemente die Objekte Greifen, Gelenke, mit denen sich der Roboter bewegt und 
diverse andere Schlitze und scharfe Kanten, an denen sich Personen entweder durch 
Berührung verletzen können, oder Körperteile in das Innere des Roboters gelangen 
könnten. \footnote{\cite{Frauenhofer22}} \\
\\
Diese äußere, mechanische Sicherheit kann durch ein abgerundetes Design erreicht 
werden. Alle Komponenten des Roboters sollten rund gestaltet sein und bewegliche 
Komponenten sollten zu mindestens einen Schutz haben, oder zur Gänze im Inneren 
des Roboters verbaut sein. \\
\\
Je weniger Möglichkeiten der Mensch hat mit dem Roboter in Berührung zu kommen, 
desto besser. Dies gilt auch wenn alle Sicherheitsmaßnahmen eingehalten werden. \footnote{\cite{Frauenhofer22}} \\
\\
\paragraph{Umgebungsbezogen}
\hfill \break
\hfill \break
Der Bereich, indem ein kollaborativer Roboter tätig ist, muss unbedingt 
gekennzeichnet sein. Dies sollte nicht nur mit einem Hinweisschild geschehen, 
sondern auch mit, am Boden angebrachten, Markierungen. Eine Grafik der aktuellen 
Bewegungsabläufe hilft ebenfalls sehr bei der Vermeidung von Kollisionen. \\
\\
Durch die übervorsichtige Behandlung der MRK-Arbeitsbereiche, können unnötige 
Unterbrechungen der Roboterarbeit vermieden werden, wodurch die Effizienz des 
Roboters nicht ungewünscht verringert wird. \footnote{\cite{Frauenhofer23}} \\
\\
Der Zugang zum MRK-Bereich sollte durch physische Hindernisse wie Zäune, Scheiben 
oder Mauern erschwert werden. Einzig die, mit Robotern arbeitenden, Personen 
sollten Zugang zu diesen kritischen Umgebungen haben. Eine organisierte Auslegung 
des Arbeitsplatzes ist essenziell, um einen effizienten und sicheren Betrieb für 
den Menschen zu garantieren. Dies ist vor allem in Hinblick auf die 
sicherheitsrelevanten Einrichtungen wie Notschalter und Bewegungsregler des 
Roboters relevant. \footnote{\cite{Frauenhofer23}} \\
\\
\subsection{Fazit}
MRK (Mensch-Roboter-Kollaborationen) sind in Zukunft essenziell, um die effiziente 
und effektive Herstellung von Produkten zu gewährleisten. Durch maschinelle 
Helfer werden Arbeitsprozesse beschleunigt, Menschen entlastet und unterstützt. \\
\\
So spannend die Mensch-Roboter-Zusammenarbeit auch klingt, so viele Gefahren gibt 
es allerdings auch. Es ist unbedingt notwendig die schon vorhandenen 
Sicherheitsaspekte zu verstehen und anzuwenden. Dies gilt in Bezug auf den 
Arbeitsplatz, die sichere Entwicklung von Software und das Anbringen von 
kollisionspräventiven Sensoren. \\
\\
Der Mensch muss zu jeder Zeit die Kontrolle über die Maschine haben, da sonst 
lebensgefährliche Situationen entstehen könnten. Um jederzeit über dem Roboter 
zu stehen, muss für jeden Betrieb ein individuelles, ausgeklügeltes 
Sicherheitssystem gegen Cyber-Angriffe entwickelt werden. Fakt ist nämlich, dass 
durch die immer komplexer werdende Technologie die Angriffsfläche für kriminelle 
im Internet immer größer wird. Jedoch muss das gesamte System auch gegen Angriffe 
von innen durch Mitarbeiter oder unerwünscht eingedrungene Personen immun sein. \\
\\
Werden diese Sicherheitsmaßnahmen eingehalten und mit Hausverstand agiert, so 
steht der erfolgreichen MRK nichts mehr im Weg. \\
\\

\newpage
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\section{Übersicht der eingesetzten Technologien}
\label{chap:Theoretische Grundlagen des Diplomprojekts}

\subsection{Flexsensor [\textcolor{blue}{Schweitzer}]}
\label{chap:Flexsensor}
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{Flexsensor}}
		\caption{Flexsensor (\textcolor{blue}{Quelle: \cite{Flexsensorabbildung}})}
		\label{fig:Flexsensor}
	\end{center}
\end{figure}
\hfill \break
Ein Flexsensor (Biegesensor) misst die Biegung des aus Kunststoff bestehenden 
Streifens. Die Kohlenstoffbeschichtung macht diesen dann zu einem variablen 
Widerstand. Je mehr der Flexsensor gebogen wird, desto größer wird der Widerstand. 
Die Biegung kann somit gemessen werden. Diese Information wird dann in ein 
elektrisches Signal umgewandelt, was auch für das Einlesen in den Mikrocontroller 
nötig ist. Diese Flexsensoren können beispielsweise auf einem Handschuh angenäht 
werden, um zu messen, wie sehr ein Finger abgebogen wurde. \\
\\

\subsection{Servomotor [\textcolor{blue}{Schweitzer}]}
\label{chap:Servomotor}
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{Servomotor}}
		\caption{Servomotor (\textcolor{blue}{Quelle: \cite{Servoabbildung}})}
		\label{fig:Servomotor}
	\end{center}
\end{figure}
\hfill \break
Ein Servomotor ist ein kleiner Elektromotor. Er besteht aus einer Steuereinheit, 
sowie einer Antriebseinheit. Ein Servo kann die Winkelposition einstellen, die 
Drehgeschwindigkeit variieren und dadurch auch die Beschleunigung beeinflussen. 
Dies funktioniert über einen Sensor, der die Positionsbestimmung durchführen kann. 
Der Servo kann über die Software festlegen, wie sich dieser drehen soll. Durch 
Sollwerte wird angegeben, wie weit sich dieser drehen soll. Für die Ansteuerung 
von einzelnen 3D-gedruckten Fingern ist ein Servo die optimale Wahl, da dieser 
die an ihm befestigten Schnüre spannen oder entlasten kann. \\
\\

\subsection{ESP-NOW [\textcolor{blue}{Schweitzer}]}
\label{chap:ESP-NOW}
Das ESP-NOW Protokoll macht es möglich, dass man Daten problemlos per 
Funkstrecke versenden kann. Dabei kann dieses auf dem ESP32 und ESP8266 
verwendet werden, da nur diese dafür ausgewählt wurden. Der Hersteller 
$"$Espressif$"$ hat dieses Protokoll entwickelt. Es können bis zu 250 Bytes 
pro Sendevorgang ausgetauscht werden. Dies ist auch bis zu einer maximalen Anzahl 
von zwanzig ESP32/ESP8266 Slaves möglich. Das Mischen der beiden genannten 
Boards ist möglich. Dabei kann auch jeder der ESPs jeweils als Transmitter, 
Receiver oder Transceiver verwendet werden. Ein Vorteil dieser Übertragungsmöglichkeit 
ist, dass die dafür benötigten Bibliotheken in der Arduino IDE zu finden 
sind. Diese sind nämlich schon standardmäßig im Paket für den ESP32 und 
ESP8266 vorhanden. \\
\\
Als Erstes muss die MAC-Adresse des jeweiligen ESPs identifiziert werden. 
Bei Bedarf kann diese auch geändert werden. Es wird hierfür also kein 
Router benötigt. Diese besteht aus sechs Bytes. Angegeben wird sie im 
Hexadezimalsystem, wobei zwischen Zweierblöcken von Buchstaben und Zahlen 
jeweils ein Doppelpunkt steht. Um auf alle WIFI-Funktionen nutzen zu können, 
muss auch die Bibliothek für WIFI eingebunden werden. Wichtig ist, dass WIFI 
zuvor aktiviert wurde, da sonst keine Daten übertragen werden können. Durch 
den Aufruf der Funktion esp\_now\_init$()$ kann ESP-NOW initialisiert werden, 
mit esp\_now\_deinit$()$ kann es wieder rückgängig gemacht werden. Durch die 
Funktion esp\_now\_add\_peer$()$ können neue Geräte, an die man dann etwas sendet, 
in die Liste der Geräte aufgenommen werden. Zu beachten ist, dass Kanäle von 0 bis 14 vorhanden 
sind, wobei 0 für den aktuellen Kanal steht. Darüber wird dann auch gesendet, 
außer man stellt einen spezifischen Kanal ein, auf dem sich das lokale Gerät 
befindet. \\
\\
Um Daten zu senden, muss die Funktion esp\_now\_send$()$ aufgerufen werden. 
Dadurch können dann Daten gesendet werden. Die Funktion esp\_now\_register\_send\_cb$()$ 
ist dafür da, um die Sende-Callback-Funktion zu registrieren. Es wird ein 
Wert zurückgeliefert, der angibt, ob die Daten erfolgreich gesendet wurden oder 
nicht. Bei einem erfolgreichen Sendevorgang wird ESP\_NOW\_SEND\_SUCCESS zurückgeliefert. 
Dies passiert, wenn sie erfolgreich am MAC-Layer der Empfängerseite empfangen wurden, ansonsten 
ESP\_NOW\_SEND\_FAIL. Warum eine Fehlermeldung ausgegeben wird, kann nicht 
nur einen Grund haben. Beispielsweise existiert die angestrebte MAC-Adresse 
nicht, die Kanäle sind nicht identisch oder der Action frame geht bei der 
drahtlosen Übertragung verloren. Um doppelte Daten auszuschließen, ist es 
möglich, dass man eine Sequenznummer verwendet, um zu überprüfen, ob es eine 
fehlerbehaftete Übertragung sein könnte. Ein zu kurzes Intervall zwischen 
dem Senden der verschiedenen Daten kann dazu führen, dass eine Störung 
auftreten kann. Die Sende-Callback-Funktion kann dadurch gestört werden. Es 
sollte deshalb auf jeden Fall der Moment abgewartet werden, bis die Sende-Callback-Funktion 
eine Antwort geliefert hat. Dabei wird diese Funktion jedes Mal mit hoher 
Priorität beim Wifi-Task ausgeführt. In der Callback-Funktion sollen auf 
jeden Fall nur die wichtigsten Operationen abgearbeitet werden. \\
\\
Um Daten zu empfangen, muss die Funktion esp\_now\_register\_recv\_cb$()$ aufgerufen 
werden. Dies ist dafür verantwortlich, um die Empfangs-Callback-Funktion zu 
realisieren. Genauso, wie beim Sender, wird hierzu der WIFI-Task verwendet, 
weshalb nur die nötigsten Operationen abgearbeitet werden sollen. \\
\\
Mit der Funktion esp\_wifi\_config\_espnow\_rate$()$ kann die ESP-NOW Datenrate angegeben 
werden. Dabei muss beachtet werden, dass die gewünschte Schnittstelle bereits 
konfiguriert wurde. Eine Energiesparen Funktion kann über 
esp\_wifi\_connectionless\_module\_set\_wakre\_interval$()$ festgelegt werden. Hier 
meist durch eine Wand, in seltenen Fällen sogar durch zwei, abhängig von der Dicke 
kann man dann einstellen, wann sich der ESP einschalten soll. \\
\\
Im Freien, ohne störende Wände oder Möbel, kann ESP-NOW Daten auf jeden Fall 100 
bis 250 Meter weit übertragen. In geschlossenen Räumen funktioniert die Übertragung 
und anderen störenden Einflüssen. \footnote{\url{https://wolles-elektronikkiste.de/esp-now\#range}, (Stand: 21.02.2024)} \\
\\
Das OSI-Modell wird bei dem ESP-NOW Modell von sieben Schichten auf 
zwei reduziert. Daten müssen somit nicht den Network-Layer, den 
Transport-Layer, den Session-Layer, den Presentation-Layer und 
den Application-Layer durchlaufen. Nur der Data-Link-Layer (SLIP/PPP/MTU), 
sowie der Physical-Layer (802.11b/g/n), werden verwendet. 
Der große Vorteil liegt außerdem 
darin, dass man einige Dinge nicht berücksichtigen muss. Es gibt keine 
Paketköpfe oder Entpacker auf jeder Schicht. Dies führt zu einer schnelleren 
Reaktion, zu weniger Overhead und die Paketverluste werden dadurch in überlasteten Netzen 
reduziert. Dies führt zu einer deutlichen Verbesserung der möglichen
Verzögerung, indem diese sehr niedrig gehalten werden kann. \footnote{\url{https://www.espressif.com/en/solutions/low-power-solutions/esp-now}, (Stand: 21.02.2024)} \\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.0}
		{\includegraphics[width=0.8 \linewidth]{ESPNOW_Model}}
		\caption{ESPNOW - Model}
		\label{fig:ESPNOW_Model}
	\end{center}
\end{figure}

\subsubsection{OSI-Modell}
\label{chap:OSI-Modell}
Das OSI-Modell ist standardisiert und ermöglicht die Kommunikation zwischen den 
verschiedensten Computersystemen. OSI (Open Systems Interconnection) wurde von der 
ISO (International Organization for Standardization) erfunden. 
Es besteht aus 7 Schichten (application layer, presentation layer, session layer, 
transport layer, network layer, data link layer und physical layer). Wichtig ist, 
dass jede einzelne Schichte eine andere Aufgabe erfüllt. Durch das System der 
einzelnen Schichten kann die Fehlersuche vereinfacht werden, da man die jeweiligen 
durchforsten kann. Zu beachten ist allerdings, dass diese untereinander ebenfalls 
Daten austauschen und untereinander kommunizieren können. Dabei ist jede Schicht 
nach international standardisierten Protokollen definiert. Das bedeutet, dass gewisse 
Regeln zur Kommunikation eingehalten werden müssen. Dabei ist es möglich, dass sich 
ein Protokoll über mehrere Schichten verteilt. \\
\\
Beim Sender und Empfänger werden diese sieben Schichten jeweils einmal angewandt. \\
\\

\paragraph{Physical Layer}
\label{par:Physical Layer}
\hfill \break
\hfill \break
Beschreibt die mechanische und funktionale Schnittstelle zum Übertragungsmedium. Die 
Datenübertragung der physischen Geräte, wie Schalter, Kabel, usw. ist hiermit gemeint. 
Daten werden in einen Bitstrom umgewandelt. Zu beachten ist, dass das Übertragungsmedium 
an sich nicht zur 1. Schicht gehört, nur die Datenübertragung bei Einschalten des 
physischen Geräts gehört in diese.\\

\paragraph{Data Link Layer}
\label{par:Data Link Layer}
\hfill \break
\hfill \break
Beschreibt die Sicherungsschicht, die eine stabile und funktionierende Verbindung 
zwischen Endgerät und Übertragungsmedium herstellt. Der Data Link Layer verarbeitet 
Pakete vom Network Layer, spaltet diese in kleinere Teile namens Frames und ist für 
den Datentransfer zwischen zwei Geräten im selben Netzwerk verantwortlich. Die 
physikalische Adressierung von Datenpaketen wird hier durchgeführt. Außerdem werden 
auch eine Fehlererkennung, Fehlerbehebung und Datenflusskontrolle angewandt. \\

\paragraph{Network Layer}
\label{par:Network Layer}
\hfill \break
\hfill \break
Beschreibt den regulierten Datentransfer zwischen zwei verschiedenen Netzwerken. Hier 
werden einzelne Segmente auf dem Sendergerät von dem Transport Layer in Fragmente 
aufgeteilt und auf dem Empfängergerät dann wieder zusammengefügt. Die logische Adressierung 
findet ebenfalls statt. \\

\paragraph{Transport Layer}
\label{par:Transport Layer}
\hfill \break
\hfill \break
Beschreibt das Bindeglied zwischen den transportorientierten und den anwendungsorientierten 
Schichten. Wie immer, werden die Daten in kleinere Bestandteile zerlegt. Header-Informationen 
und eine Fehlerkontrolle werden von den Segmenten beinhaltet, falls nicht alle Daten 
erfolgreich angekommen sind oder fallengelassen wurden, kann dies hilfreich sein. \\

\paragraph{Session Layer}
\label{par:Session Layer}
\hfill \break
\hfill \break
Beschreibt die Verbindung zwischen den Endsystemen. Session nennt man den zeitlichen 
Bereich zwischen dem Starten und Beenden der Kommunikation. Wichtig ist auch, dass 
dieser Layer dafür verantwortlich ist, dass genug lange Daten übertragen werden können 
und die Verbindung nicht schon zuvor beendet wird. Für die Effizienz soll allerdings 
nach einem abgeschlossenen Vorgang die Verbindung unterbrochen werden. \\

\paragraph{Presentation Layer}
\label{par:Presentation Layer}
\hfill \break
\hfill \break
Beschreibt die Aufbereitung der Daten, sodass der Nutzer diese verstehen kann. Damit 
ist gemeint, dass beispielsweise verschlüsselte Daten zuerst entschlüsselt werden 
müssen, bevor sie der Nutzer verstehen kann. Die Komprimierung und Dekomprimierung 
von Daten werden hier auch durchgeführt. \\

\paragraph{Application Layer}
\label{par:Application Layer}
\hfill \break
\hfill \break
Beschreibt die Bereitstellung von Funktionen für Anwendungen und die Verbindung zu 
den unteren Schichten. Die Dateneingabe und Datenausgabe werden hier ebenfalls 
durchgeführt. Softwareanwendungen sind auf den Application Layer angewiesen (http, SMTP, …). 
Diese Protokolle sind für die Kommunikation notwendig und standardisiert. \\

\paragraph{ESP-NOW Schichten}
\hfill \break
\hfill \break
Es gibt bei ESP-NOW zwei Schichten, den Data Link Layer und den Physical Layer 
[siehe \textcolor{blue}{\autoref{chap:OSI-Modell}}]. Dabei beruht der Physical Layer auf dem IEEE 802.11b/g/n Standard. 
Da jedoch nicht so viele Schichten, wie bei dem OSI-Modell vorhanden sind, gibt es 
mehrere Möglichkeiten, wo Fehler liegen können und es ist nicht so leicht den Fehler 
an der richtigen Stelle zu suchen. \\

\paragraph{IEEE 802.11b/g/n Standard}
\label{par:802.11b/g/n Standard}
\hfill \break
\hfill \break
Es ist ein internationaler Standard für die drahtlose Kommunikation, der von 
Electrical and Electronics Engineers (IEEE) entwickelt wurde. Besonders wird Wert auf 
die geringe Datenrate und dem daraus folgend geringen Stromverbrauch Wert gelegt. Der 
802.11b Standard hat eine maximale Datenübertragungsrate von 11Mbit/s, 802.11g eine 
maximale Datenübertragungsrate von 54Mbit/s und 802.11, kann bis zu 600Mbit/s übertragen. 
Der letztgenannte Standard ist der einzige, der auch das 5GHz-Band nutzen kann, alle 
drei können jedoch das 2,4GHz-Band zum Datenaustausch verwenden.  \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{ESP_NOW_Theorie}}
		\caption{ESPNOW - Theorie}
		\label{fig:ESP_NOW_Theorie}
	\end{center}
\end{figure}

\subsection{OPV Technologien [\textcolor{blue}{Szabo}]}
\label{chap:OPV Technologien}
Ein Operationsverstärker, kurz OPV, ist ein analoger Gleich- und Wechselspannungsverstärker, der sich durch seine üblicherweise sehr hohe 
Verstärkung auszeichnet. Der elektroische Grundbaustein ist ein Differenzverstärker, der durch äußere Beschaltungen angepasst werden kann.
In der grundlegendsten Funktion, verstärkt ein OPV die Differenz der beiden Eingangsspannungen am $"$+$"$ und $"$-$"$ Anschluss. Das Ergebnis
dieses Verstärkungsprozesses wird anschließend über $"$Vout$"$ ausgegeben. \\
\\
Operationsverstärker können mit einem sogenannten $"$Single-Supply$"$ oder $"$Dual-Supply$"$ versorgt werden. Dies bezieht sich auf
die Art der Versorgungsspannung. \\
\\
\subsubsection{Single-Supply}
Bei dieser Art der Versorgung, wird ausschließlich eine positive Spannung und das Groundpotential genutzt. Das bedeutet, dass der OPV
theoretisch einen maximalen Ausgangsbereich von GND bis VCC haben kann. Negative Spannungen können nicht ausgegeben werden. \\
\\

\subsubsection{Dual-Supply}
Beim Dual-Supply Betrieb, wird der OPV von einer positiven und negativen Spannung versorgt. Das bedeutet, dass der OPV nun die Fähigkeit
besitzt auch negative Spannungen auszugeben und der Ausgangsspannungsbereich somit größer als beim Single-Supply ist.

\subsubsection{Rail-to-Rail Technologie}
Hat ein OPV die sogenannte \textquote{Rail-to-Rail Technologie}, so ist die Rede von Spannweite des Ausgangsspannungsbereichs. Bei diesem Feature
ist der Operationsverstärker dazu fähig fast bis auf das positive und negative Versorgungspotential Spannung auszugeben. Dies ist oft 
von Vorteil, da dadurch die Versorgungsspannungen nicht übermäßig hoch sind und somit die Schaltungen mit niedrigeren Spannungen arbeiten
kann. Dies ist auch für die Benutzer der entsprechenden Endgeräte sicherer.\\
\\
In [\textcolor{blue}{\autoref{fig:RAILtoRAIL_OPV}}] sind die Ausgangsspannungsbereiche eines normalen OPVs, in blau, und eines OPVs mit Rail-to-Rail Technologie,
in Orange, dargestellt. \\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{RAILtoRAIL_OPV}}
		\caption{OPV Ausgangsspannungbereiche}
		\label{fig:RAILtoRAIL_OPV}
	\end{center}
\end{figure}

\subsection{Analog-Digital-Wandler [\textcolor{blue}{Schweitzer}]}
\label{chap:Analog-Digital-Wandler}
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{ADC_Blockschaltbild}}
		\caption{Blockschaltbild Analog-Digital-Wandler}
		\label{fig:ADC_Blockschaltbild}
	\end{center}
\end{figure}
\hfill \break
Ein ADC (Analog-Digital-Converter) wandelt kontinuierliche analoge Signale 
(physikalische Größen) in digitale Signale um. Dies ist notwendig, damit ein 
Prozessor die Werte verarbeiten kann. Deshalb kommen ADCs in elektronischen 
Schaltungen häufig vor. \\
\\
\textbf{Abtastung:} \\
Es werden kontinuierliche analoge Signale mit einer bestimmten 
Abtastrate abgetastet. Das kontinuierliche Signal wird hierbei zu einem 
zeitdiskreten, wobei die Amplitude stets kontinuierlich bleibt. \\
\\
\textbf{Halteschaltung:} \\
Die nach der Abtastung vorhandenen Messwerte werden in der Halteschaltung so 
lange zurückgehalten, bis ein neuer die Halteschaltung erreicht. \\
\\
\textbf{Quantisierer:} \\
Die Messwerte werden hier in diskrete Amplitudenwerte aufgeteilt. Das Signal 
ist ab dem Quantisierer zeitdiskret und besitzt nun eine diskrete Amplitude. \\
\\
\textbf{Codierer:} \\
Der Codierer wandelt dann das quantisierte Signal in ein binäres um. Am Ende ist 
dann ein digitales Signal in Binärform vorhanden. \\
\\

\subsection{Multiplexer [\textcolor{blue}{Schweitzer}]}
\label{chap:Multiplexer}
Untenstehend kann man noch anhand einer einfachen Logikschaltung eines 2-zu-1 
Multiplexers die Funktionsweise eines Multiplexers. Grundsätzlich wird über elektrische 
Signale einer von mehreren Eingangssignalen an den Ausgang durchgeschaltet. Meist 
funktioniert dies durch Halbleiterelemente. Das Steuersignal schaltet noch zusätzlich. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.0}
		{\includegraphics[width=0.8 \linewidth]{Multiplexer_Beispiel}}
		\caption{Multiplexer Beispiel}
		\label{fig:Multiplexer_Beispiel}
	\end{center}
\end{figure}
\hfill \break

\subsection{PWM-Signale [\textcolor{blue}{Schweitzer}]}
\label{chap:PWM-Signale}
Ein PWM-Signal ist ein Rechtecksignal mit konstanter Frequenz. Die Pulsweite ist allerdings variabel. Mit der Pulsweite wird angegeben, wie lange ein Signal auf 
"High", also 1, gesetzt ist (danach wird das Signal auf "LOW", also 0, gesetzt). Analoge Systeme können mit digitalen Signalen gesteuert werden. Die Spannung kann 
durch die Veränderung der Pulsweite verändert werden. Durch ein PWM-Signal kann die Geschwindigkeit eines Gleichstommotors gesteuert werden. Das Tastverhältnis, 
also das Verhältnis von der Pulslänge zu der Periodenlänge, wird in Prozent angegeben. \\
\\

\subsection{I2C Funktionsweise [\textcolor{blue}{Schweitzer}]}
\label{chap:I2C Funktionsweise}
\textbf{Funktionsweise:} \\
I2C beschreibt eine Möglichkeit, über die zwei verschiedene Geräte miteinander 
kommunizieren können. Die Daten werden hintereinander gesendet und dies über zwei 
Datenleitungen. Es kann dabei mit bis zu 128 Teilnehmern kommuniziert werden. Am Ende 
interpretiert der I2C-Bus die Daten und steuert den Ablauf. Bei unserem Projekt ist 
der ESP32 der Master und die Flexsensoren beispielsweise die Slaves. Der Master ist 
dann der wichtige Bestandteil, da dieser für alle anderen Slaves derjenige ist, der 
sagt, was welches Bauteil machen soll. Dabei hängen alle Geräte beziehungsweise 
Bauteile an zwei Leitungen. Eine heißt SDA (serial data) und ist für die serielle 
Übertragung der Daten verantwortlich. Jedoch ist zu erwähnen, dass diese bidirektional 
benutzt wird. Das heißt es kann in beide Richtungen gesendet werden (Master zum 
Slave und umgekehrt). Es muss aber der Master regeln, also entweder Daten senden 
oder welche von einem Slave anfordern. Die zweite Leitung heißt SCL (serial clock) 
und ist für den Takt zuständig, der für alle per I2C verbundenen Geräte gilt. Es 
wird also ein synchroner Bus verwendet. \\
\\
\textbf{Beispiel Protokoll:} \\
Die Daten sind grundsätzlich in Datenpaketen verpackt, jedes besteht aus 1 Byte. 
Wenn nichts kommuniziert wird, dann hat SDA und SCL den Wert 1. Nachdem eine 
Start-Condition gesendet wurde, durch die alle Slaves wissen, dass sie nun auf den 
Master jederzeit reagieren sollen, wird die Adresse des Slaves gesendet, mit dem 
nun Daten ausgetauscht werden sollen. 7 Bit werden hierfür standardmäßig verwendet. 
Danach wird ein weiteres Bit gesetzt. Dieses kann den Wert 0, was Schreiben bedeutet, 
oder 1, was lesen bedeutet, haben. Nun ist der Slave an der Reihe. Dieser muss 
ebenso 0, wenn die Kommunikation bereitsteht, an den Master zurücksenden. Der Master 
sendet dann oder empfängt Daten vom Slave. Sobald alle Daten versendet wurden, 
kommt die Bestätigung. Der ganze Vorgang des Senden und Empfangens wird am Ende 
dann durch die Stop-Condition beendet. SDA wird hier auf 1 gesetzt, währenddessen 
SCL auch den Wert 1 besitzt. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{I2C}}
		\caption{I2C Adressierung (Quelle: \textcolor{blue}{\cite{I2Cabbildung}})}
		\label{fig:I2C}		
	\end{center}
\end{figure}
\hfill \break

\subsection{UART Funktionsweise [\textcolor{blue}{Schweitzer}]}
\label{chap:UART Funktionsweise}
Der Arduino, beziehungsweise der ESP, werden über die serielle Verbindung UART 
(Universal Asynchronous Receiver and Transmitter) vom Computer angesprochen. 
Dabei stellt diese Verbindung eine asynchrone Datenübertragung mit fester Baudrate, 
Datenbits, Paritätsbits und Stoppbits dar. Es sind zwei Datenleitungen vorhanden, wobei 
eine für das Senden (TX) und die andere für das Empfangen (Rx) von Daten zuständig ist. 
Die Start- und Stopbits geben an, wann gesendet werden soll und wann dies nicht 
mehr geschehen soll. Sobald der Sender ein Startbit erhält, beginnt die Übertragung 
der Daten, aber beim Empfangen des Stopbit wird diese unterbrochen. Es wird 
dadurch keine Clock benötigt, da die Baud Rate dies regelt, allerdings ist zu 
beachten, dass diese maximal 10\% von jeder des anderen Geräts abweichen darf. 
Die Baud Rate gibt an, wie viele Symbole pro Sekunde übertragen werden. Dabei 
kann ein Symbol ein einzelnes Bit oder eine Gruppe von Bits sein. Die Baudrate 
gibt also an in welchem Abstand jeweils ein Symbol gesendet wird (1s/Baudrate) 
oder eben im Umkehrschluss auch, wie viele Symbole pro Sekunde gesendet werden 
(Baudrate/1s). \\
\\
\textbf{Beispiel Protokoll für 8-Bit Packet} \\
Es ist ein Startbit vorhanden (LOW), dann noch 8 Datenbits (inklusive einem 
Paritybit, das Fehler identifizieren kann) und ein oder zwei Stopbits (HIGH). 
Zur Kontrolle, ob es eine gerade oder ungerade Anzahl von Highbits gibt, wird 
ein Paritybit mitgesendet, das angibt, ob die Anzahl dieser gerade oder ungerade 
ist. Es gibt klarerweise keine hundertprozentige Sicherheit, aber man kann sich 
mehr auf die Nutzbarkeit der Daten verlassen. Bei der UART-Kommunikation bedeutet 
ein Paritybit von 0 (odd), dass die Summe der Highbits eine ungerade Zahl ist. Ein 
Paritybit von 1 (even) hingegen zeigt an, dass die Summe der Highbits eine gerade 
Zahl ist. Üblicherweise werden zwei Stopbits am Ende einer Übertragung gesendet, 
um eine verlängerte Ruhephase zu gewährleisten. 
Dies führt zu einer stabileren Synchronität und Erhöhung der Robustheit gegen 
Signalstörungen. Bei UART wird das LSB (least significant bit) immer ganz rechts 
in den Daten gefunden. Sollte das Paritybit nicht stimmen, dann wird vom 
Empfänger an den Sender eine Anfrage mit der Bitte um erneutes Senden gesendet, 
da der Datensatz nicht stimmt. \\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{UART}}
		\caption{UART erklärendes Diagramm}
		\label{fig:UART}		
	\end{center}
\end{figure}

\subsection{WiFi [\textcolor{blue}{Schweitzer}]}
\label{chap:WiFi}
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{WiFi_Logo}}
		\caption{WiFi Logo (Quelle: \textcolor{blue}{\cite{WIFIabbildung}})}
		\label{fig:WiFi_Logo}
	\end{center}
\end{figure}
\hfill \break
WLAN (Wireless Local Area Network) ist eine Technologie, die Geräte drahtlos in einem lokalen Netzwerk verbindet. Es wird häufig verwendet, um einen Zugang zum Internet herzustellen. Mobile Geräte wie Smartphones, Tablets und Laptops werden meistens über WLAN mit dem Internet oder untereinander verbunden.
WIFI (Wireless Fidelity) ist eigentlich ein Markenname, der oft fälschlicherweise als Synonym für WLAN verwendet wird. 
Innerhalb eines WLANs können Datenpakete gesendet und empfangen werden. Der Vorteil dieser drahtlosen Verbindung liegt darin, dass die Geräte keine physische Verbindung per Datenkabel benötigen. Sie können innerhalb einer bestimmten Reichweite miteinander kommunizieren.
Die Reichweite eines WLANs kann durch verschiedene Faktoren beeinflusst werden. Beispielsweise können physische Hindernisse wie Wände oder Möbel das Signal abschwächen. Auch andere drahtlose Geräte oder Netzwerke können Interferenzen verursachen und die Signalqualität beeinträchtigen. \\

\newpage
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------

\section{Grundlegendes Systemkonzept [\textcolor{blue}{Szabo}]}
\label{chap:Grundlegende Systemkonzepte}

\subsection{Gesamtsystemkonzept}
\label{chap:Gesamtsystemkonzept}

\subsubsection{Systembeschreibung}

	\begin{figure}[H]
		\begin{center}
			\scalebox{1.2}
			{\includegraphics[width=0.8 \linewidth]{Blockschaltbild_Gesamtsystem}}
			\caption{Blockschaltbild des Gesamtsystems}
			\label{fig:Blockschaltbild_Gesamtsystem}		
		\end{center}
	\end{figure}

Das Gesamtsystem ist in [\textcolor{blue}{\autoref{fig:Blockschaltbild_Gesamtsystem}}] grafisch veranschaulicht. Die linke Hälfte zeigt das Konzept des 
Handschuhs (Eingabe) und die rechte Hälfte die Roboterhand (Ausgabe). Die grundlegende Konzeptionierung der Bewegungserfassung 
besteht darin, dass mithilfe von Sensoren die Fingerbeugung aller fünf Finger gemessen wird. Anschließend werden die Sensordaten
ausgewertet und verarbeitet. Die resultierenden Informationen werden anschließend über eine drahtlose Verbindung an das zweite 
Subsystem, nämlich der Roboterhand, übertragen. Dort wird das Gesendete empfangen, weiterverarbeitet und interpretiert. Die Aktorik
setzt die digitalen Anweisungen in mechanische Bewegungen um, wodurch die Roboterhand gesteuert wird. Im Ausgabesystem ist auch 
ein User-Interface enthalten. Die diversen Funktionen werden in späteren Punkten näher erläutert.

\subsection{Eingabesubsystem}
\label{chap:Eingabesubsystem}

	\begin{figure}[H]
		\begin{center}
			\scalebox{0.8}
			{\includegraphics[width=0.8 \linewidth]{Blockschaltbild_Handschuhsystem}}
			\caption{Blockschaltbild des Eingabesubsystems}
			\label{fig:Blockschaltbild_Handschuhsystem}			
		\end{center}
	\end{figure}

Der Handschuh ermöglicht dem Benutzer die Roboterhand zu steuern. Dies geschieht 
durch Flexsensoren, die an den Fingern des Handschuhs angebracht sind. Wird ein 
Finger gebeugt, so ändert sich der Widerstandswert des Sensors. Diese Änderungen 
werden von einem Mikrokontroller erfasst, der per Kabel über UART die Werte 
kontinuierlich ausliest. Anschließend wird die kabellose Übertragung über den 
Funkstandard ESP-NOW realisiert. Das Senden an die Roboterhand wird vorbereitet. 
Damit der Handschuh funktioniert, bedarf es einer Spannungsversorgung. Diese wird 
in Form einer Batterie oder eines Akkus vorgesehen sein, funktioniert aber allenfalls 
über ein USB-C Kabel. Für einen möglichen stationären Betrieb kann der Handschuh 
auch mit einem Netzteil betrieben werden. Die Passform des Handschuhs soll 
möglichst komfortabel sein, um eine möglichst lange Benützung zu ermöglichen. 
Dies setzt eine gut überlegte Integration der Elektronik voraus. Die Flexsensoren 
sollen fest auf dem Handschuh befestigt sein. Die Widerstandswerte sind ansonsten 
bei jedem Mal biegen unterschiedlich, wenn die Flexsensoren nicht an einer Stelle 
am Handschuh bleiben, sondern sich verschieben. Diese Montage wird bei diesem 
Projekt auch bestmöglich beachtet. Der Handschuh ist so gebaut, dass er auch von 
Personen ohne elektronische Ausbildung und ohne Vorwissen bedient werden kann. 
Das liegt daran, dass nur die Finger gebeugt oder gestreckt werden müssen. Jede 
Handbewegung kann also gemacht werden, die Werte werden per Software automatisch 
richtig verarbeitet. \\

\subsection{Ausgabesubsystem}
\label{chap:Ausgabesubsystem}

\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Blockschaltbild_Roboterhandsystem}}
		\caption{Blockschaltbild des Ausgabesubsystems}
		\label{fig:Blockschaltbild_Roboterhandsystem}		
	\end{center}
\end{figure}
\hfill \break
Sind die Daten des Eingabesubsystems empfangen, müssen diese in ein geeignetes Format für die Steuerung der Aktorik, also den Servomotoren,
umgewandelt werden. Dies geschieht mit dem Mikrokontroller. Angebunden an das Ausgabesubsystem, ist ein Graphical-User-Interface, 
welches in [\textcolor{blue}{\autoref{chap:User Interface}}] näher erklrärt wird. \\

\newpage
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\section{Mechanische Realisierung [\textcolor{blue}{Al-Maytah}]}
\label{chap:Mechanische Realisierung}

\subsection{Handschuh}
\subsubsection{Anforderungen}
Für eine korrekte Erfassung der Daten erfordert das Eingabesubsystem nicht nur ein 
zuverlässiges Messsystem oder eine effiziente Datenkorrektur per Software, 
sondern auch eine mechanische Komponente, welche die Sensorik entsprechend an den 
Fingern des Nutzers positioniert. Auch ist es wichtig, dass der Handschuh eine notwendige Biegung der Sensoren ermöglicht und damit keine Behinderung für die eigentliche Messung darstellt.
Die Bewegung des Nutzers darf durch den Handschuh nicht eingeschränkt werden und soll so widerstandslos wie möglich sein.
Demnach soll eine an die Hand montierbare physische 
Komponente entworfen werden, welche dies erfüllt.
\\
\\
\subsubsection{Überlegungen}
Die erste Überlegung war es unter anderem einen Stoff-Handschuh, besser gesagt einen 
Arbeitshandschuh, als Basis dieser Komponente zu nutzen, auf diesem sollen die 
Flex-Sensoren entsprechend angebracht werden. Wichtig ist, dass die Sensoren sich 
mit dem Finger mitbiegen sowie auch bewegen und dies der Fingerstellung entsprechend. \\
\\
\subsubsection{Versuche}
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{Flexsensorhandschuh}}
		\caption{Handschuhkonzept mit Sensor}
		\label{fig:Flexsensorhandschuh}		
	\end{center}
\end{figure}
\hfill \break
Der initiale Versuch war es einen Stoff-Handschuh zu nutzen und an dessen Finger die Sensoren anzunähen. Jeder Flex-Sensor ist somit mit seinem Anfang, dem 
Punkt, an dem auch die Anschlüsse des Sensors sind, fest vernäht und fixiert. Weiters 
wurde er auch mit einer Naht ummantelt, in der er sich begrenzt nach vor und zurück 
bewegen kann. Er wird durch diese Ummantelung somit ständig am Finger gehalten, kann 
sich jedoch auch frei in ihr bewegen. \\
\\
\subsubsection{Testergebnisse}
\begin{itemize}
	\item Der Handschuh wirkt äußerst einschränkend auf die Hand des Nutzers, dies 
	ist darauf zurückzuführen, dass er äußerst dick ist.
	\item Aufgrund dieser Dicke kann beim Anwinkeln des Fingers der Sensor nicht 
	entsprechend geknickt werden, um eine ausreichendes Messergebnis zu liefern.
\end{itemize}
\hfill \break
Nach weiteren Überlegungen kam es zu einem neuen Konzept, ohne einen Handschuh als 
Basis. Dieses Konzept schränkt die Bewegungen des Nutzers weniger ein als es das vorherige tat. \\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{Ringkonzept}}
		\caption{Veranschaulichung des Ringkonzepts}
		\label{fig:Ringkonzept}		
	\end{center}
\end{figure}
\hfill \break
Bei dieser Realisierung, wird auf jeden Finger ein Aufsatz montiert, welcher eine ringartige Anschnallmöglichkeit und einen Flexsensor beinhaltet.
Wie in der Abbildung ersichtlich besteht die Anschnallmöglichkeit aus zwei Ringen, Nummer (1) und (2), mit jeweils einer Führung auf diesen. Durch diese verläuft der Sensor (3), fixiert ist er an dem vordersten Ring, in der Grafik (1)
und bewegt sich durch die Führung des Rings (2). In der Grafik lässt sich das Seitenprofil der Ringe am Daumen besser erkennen.
Aufgrund dieser Montage kann der Sensor deutlich stärker gebogen werden, was dafür sorgt, dass aus mechanischer Sicht die besten Gegebenheiten für eine Messung geschaffen werden. \\

\newpage
\subsection{Roboterhand}
\subsubsection{Der Grundgedanke}
Der Grundgedanke der Mechanik in der Roboterhand ist, alle drei Glieder eines Fingers,
darunter das Fingergrundglied, das Fingermittelglied und das Fingerendglied mit 
ausschließlich der Bewegung eines einzelnen Servomotors auf- oder zuzuklappen. 
Umsetzbar ist dies durch ein Zugsystem, welches ein Aufklappen und ein Zuklappen 
des Fingers ermöglicht. Gezogen werden durch den Finger der Roboterhand ein oder mehrere 
Schnüre, ähnlich wie bei einer Marionette. Diese Schnüre bringen den Finger je nach 
Verlängern oder Verkürzen zum Bewegen. Ebenso ist je nach Zug wählbar in welcher 
Stellung der Finger sich befinden soll. Befestigt wird dies an einem mit dem Servomotor 
gesteuertem Zugmechanismus. \\

\paragraph{Fertigung und CAD}
\label{par:Fertigung und CAD}
\hfill \break
\hfill \break
Der Entwurf eines Modells ist mit ständiger Weiterentwicklung verbunden, sind in 
solch einem Modell mechanische Komponenten vorhanden, nimmt die Fertigungsschleife 
ersichtlich mehr Komplexität an und erfordert die Möglichkeit in kürzester Zeit 
rasch Anpassungen und Optimierungen am Entwurf ausgiebig zu testen. Speziell 
während der Entwicklung der mechanischen Komponente einer Roboterhand ist auf 
viele Faktoren zu achten, es ergeben sich laufend neue Erkenntnisse sowie auch 
Problematiken, welche eine Lösung erfordern. Sei es mangelnde Stabilität unter 
hoher Belastung, zu viel Reibung oder gängige Konstruktionsfehler. \\
\\
Dank dem neuen Fertigungsverfahren des 3D-Drucks ist es möglich Versuchsaufbauten 
in einem CAD-Programm zu entwerfen, diese folglich zu drucken und dementsprechend 
auf ihr Verhalten zu testen. \\
\\
Ein CAD-Programm ist eine Software, welche zur Erstellung von zweidimensionalen 
oder auch dreidimensionalen Modellen dient, CAD steht für Computer-Aided 
Design(engl.) und bedeutet übersetzt „Computerunterstütztes Entwerfen“. Neben 
dem reinen Entwerfen von Modellen haben solche Programme auch die Eigenschaft 
das Modell je nach Material auf Stabilität, die Maximalbelastung oder sonstige 
Verhaltensmuster zu testen. \\
\\
Das 3D-Verfahren arbeitet mit den exportierten Modell-Dateien eines CAD-Programms 
und setzt diese in ein greifbares Modell um. \\
Darunter gibt es mehrere Fertigungsmethoden. Die Methode FDM(Fused Deposition Modeling), welche von uns gewählt wurde ist die 
gängigste. Dieses Verfahren arbeitet hauptsächlich 
mit Kunststoffen. Dabei zeichnet ein Extruder mit eingeführtem Filament schichtweise 
ein Modell auf eine Druckplatte und formt damit ein reales Objekt. Kunststoffe, 
die für dieses Fertigungsverfahren verwendet werden, sind PLA, ABS, PETG und weitere. \\
Die Vorteile des FDM-Drucks sind, dass die Druckgeräte sowie das Filament billig 
zu erhalten sind, und dass das Verfahren einfach und nicht besonders komplex 
ist, sowie auch schnell. \footnote{\url{https://filamentworld.de/3d-druckverfahren/}}\\
\\
In der initialen Entwicklungsphase des Projekts „Bionic-Hand“ kommen zwei private 3D-Drucker zum Einsatz, welche das FDM-Verfahren nutzen. Der sich daraus erschließende 
Vorteil ist eine effektive und besonders rasche Prototypenherstellung. Von großer 
Bedeutung ist die Möglichkeit, jederzeit ein Modell in den Drucker zu laden und damit 
innerhalb weniger Stunden ein neues Versuchsobjekt zu erhalten. \\
Im Laufe der ersten Versuchsaufbauten war die Druckqualität nicht sehr relevant, denn 
der Fokus lag auf der Zeitersparnis und hauptsächlich auf dem Gewinn von Erkenntnissen, 
sowie auf dem Verständnis der in der CAD-Software entworfenen Mechanismen. \\

\subsubsection{Versuchsaufbau}
\label{chap:Versuchsaufbauten}
In diesem Versuchsaufbau war es das Ziel mit einem einfachen Testmodell Erkenntnisse über 
den Mechanismus zu erhalten und dadurch mehr aus ihm zu lernen. 
Dafür wurde in der CAD Software Fusion360 [\textcolor{blue}{\autoref{chap:Fusion 360}}] ein erstes Testmodell entworfen. \\

\paragraph{Aufbau}
\hfill \break
\hfill \break
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Fingerversuch}}
		\caption{Darstellung des Versuchsmodells}
		\label{fig:Fingerversuch}		
	\end{center}
\end{figure}
\hfill \break
Das Modell besteht aus den drei Gliedern eines Fingers, sowie einer Halterung für einen vorgesehenen
Servomotor und aus den im Inneren vorhandenen Führungen. \\
\\
Zwischen jedem Fingerglied befindet sich ein enstprechender Abstand, verbunden sind diese durch einen Steg. Dieser hat den Zweck sich beim Ziehen an der Schnur zu biegen, durch 
die Führungen wird eine Biegung an diesem Steg ermöglicht. Die Schnur wird an einer Halterung am Servomotor befestigt und dadurch bei Rotation des Servos 
entsprechend gespannt. Die Fingerglieder haben eine nach außen gewölbte Form und sind 
in Richtung des Stegs verjüngt, dies ermöglicht dem Finger sich auf noch engerem Raum 
zusammenzuziehen.

\paragraph{Versuchsresultat}
\label{par:Versuchsresultat}
\hfill \break
\hfill \break
Das Versuchsresultat war lehrreich und bot einen breiten Einblick in den angepeilten Faltmechanismus. 
Dabei gab es zahlreiche Erkenntnisse über die Reibung, Stabilität und mechanische Abnutzung
sowie aber auch über das Verhalten der Gesamtmechanik bei Belastung. \\
\\
Eine der Erkenntnisse war es, dass die Schnur eine gewisse Reißfestigkeit benötigt. 
Getestet wurden dabei mehrere Schnüre unter anderem auch Nylonschnüre. Als besonders 
stabil haben sich dann Angelschnüre bewiesen.
Festgestellt wurde, dass ein mechanischer Rückzug benötigt wird, welcher den 
Finger wieder in seine Ursprungsposition, ausgestreckt, versetzt. Anfangs war dafür 
der Steg vorgesehen, dieser hat sich jedoch über die Zeit abgenutzt und hat den 
Finger nicht in die Ursprungsposition befördert. Eine der möglichen Lösungen sind 
Gummikordeln, elastische Schnüre, welche am „Fingerrücken“ platziert werden und sich 
bei Biegen des Fingers spannen. Daraus resultiert: Je kürzer die Zugschnur im Finger, desto länger die 
Gummikordel. \\

\subsubsection{Entwicklungsstufe: initial}
\label{chap:Entwicklungsstufe: intitial}
\paragraph{Konzept Einführung}
\hfill \break
\hfill \break
Die erste Testhand zielt darauf ab ein Modell, welches durchgängig erweitert 
werden kann, zu schaffen. Mit Rücksicht auf etwaige Testergebnisse des 
Versuchsresultats [siehe \textcolor{blue}{\autoref{par:Versuchsresultat}}] soll ein Modell geschaffen werden, 
welches den im Versuch aufgetretenen Problematiken trotzen kann, unter anderem 
dem schwachen Rückzug und der nicht reißfesten Schnur. \\
\\
Als konkrete Lösung, um für mehr Zuverlässigkeit im Zusammenhang mit dem Zugsystem 
zu sorgen, wurde für diesen Aufbau eine Angelschnur gewählt, diese soll laut Hersteller äußerst reiß- und schnittfest sein. \\
\\
Im Versuch [siehe \textcolor{blue}{\autoref{chap:Versuchsaufbauten}}] hat sich erwiesen, dass ein Steg aus dem Kunststoff PLA, welcher die 
Fingerglieder verbindet, nicht genügend Kraft aufbringt, um den Finger wieder in 
seine Ursprungsposition zu bewegen. Demnach wird eine Kraft benötigt, welche 
ständig dem Zug der Angelschnur entgegenwirkt und den Finger entsprechend 
austreckt. \\
In diesem Modell wird daher ein Elastomer, ein elastisches Material in Form 
eines Bandes mit ausreichender Kraft gewählt. \\

\paragraph{Realisierung und Zusammenbau}
\label{par:Realisierung und Zusammenbau}
\hfill \break
\hfill \break
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Hand_1}}
		\caption{initiales Grundkonzept}
		\label{fig:Hand_1}		
	\end{center}
\end{figure}
\hfill \break
Das Konzept wird anhand einer Testhand realisiert, diese setzt sich im Wesentlichen 
aus zwei Komponenten zusammen: dem Motorblock, welcher für die Antriebsmechanik 
zuständig ist, und der Roboterhand, welche die eigentliche Bewegungen der Motoren 
in der Bionic Hand umsetzt. \\
\\
Das komplexeste Modell ist die Roboterhand, die aus mehreren Elementen besteht, 
darunter die Handfläche sowie die einzelnen Finger, die sich jeweils in drei Glieder 
unterteilen lassen. Der Mechanismus in jedem Finger erfüllt dieselbe Funktion: Durch 
Ziehen an der Schnur verkürzt sich ihre Länge, was dazu führt, dass sich der 
jeweilige Finger faltelt. \\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Finger_1}}
		\caption{Querschnitt der Finger}
		\label{fig:Finger_1}		
	\end{center}
\end{figure}
\hfill \break
Im Detail betrachtet beschränkt sich der Mechanismus 
des Fingers nicht nur auf das bloße Ziehen an ihm. Der Finger unterteilt sich in weitere 
Elemente. Er besteht aus drei Gliedern, von denen jedes eine Abschrägung an beiden 
Kanten die zum nächsten Glied ausgerichtet sind, aufweist. Durch die Verjüngung der 
Kanten, kann beim sogenannten Falten des Fingers dafür gesorgt werden, dass sich der 
Finger auf kleineren Raum zusammenziehen oder auch falten kann. \\
\\
Wie in [\textcolor{blue}{\autoref{fig:Finger_1}}] ersichtlich, wird hier der Querschnitt aller Finger dargestellt, 
dabei ist es nicht von Relevanz, welches der jeweils drei Fingerglieder hier genommen wird. 
Alle Glieder, das untere, das mittlere sowie das obere Glied haben eine 
gemeinsame Eigenschaft: Durch jedes verlaufen drei Tunnel. Der oberste Tunnel 
hat den Zweck einen Durchgang für die Angelschnur zu schaffen, an dieser wird gezogen 
und das bewirkt das Falten des Fingers. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1}
		{\includegraphics[width=0.8 \linewidth]{Fingerskizze1}}
		\caption{Faltmechanismus der Entwicklungsstufe: initial}
		\label{fig:Fingerskizze1}		
	\end{center}
\end{figure}
\hfill \break
In den beiden unteren Tunneln oder auch Kanälen, 
welche einen ersichtlich größeren Durchmesser besitzen, verläuft das 
Elastomer, ein elastisches Band. Durch Falten des Fingers, welcher durch das Ziehen an der 
Angelschnur ausgelöst wird, verlängert sich die Strecke, auf der sich das elastische 
Band spannt. Dies löst gegengleich zum Zug eine gegenwirkende Spannung aus. 
Anhand der durch das Band entstandenen Zugkraft behält der Finger seine Position bei, 
er wird somit gesichert, um nicht weiter in Zugrichtung der Angelschnur zu kippen und 
wiederum von der Angelschnur gesichert um nicht in Richtung des Bandes zu kippen. Neben der 
Funktion des Rückzuges verbinden die beiden Bänder alle aneinander liegenden 
Fingerglieder sowie auch das unterste Glied mit dem Handflächenelement. Dabei 
spielt auch die Position der Tunnel für das Band eine wesentliche Rolle, denn 
diese verhindern durch ihre parallele Anordnung an den unteren äußeren Seiten 
des Gliedes, dass sich die Glieder nach rechts oder links neigen. 
Ebenso befindet sich an dem inneren Teil des Gliedes, welches die Fingerkuppe 
nachstellt, beim Fingerabdruck eine runde Einkerbung sowie ein rechteckiger Kanal. 
Diese Eigenschaft des Modells hält die Möglichkeit eines optionalen Kraftsensors frei. 
Mit so einem Sensor könnte bei Integration auch die Druckkraft 
gemessen werden. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Handfläche_1}}
		\caption{Querschnitt der Handfläche}
		\label{fig:Handfläche_1}		
	\end{center}
\end{figure}
\hfill \break
Verbunden sind alle Finger mit dem Element der Handfläche, dieses Element fungiert 
lediglich als Verbindungskomponente zwischen allen Fingern und dem Daumen. 
Im Querschnitt der Handfläche [siehe \textcolor{blue}{\autoref{fig:Handfläche_1}}] lässt sich erkennen, dass diese von innen einen 
Hohlraum beinhaltet. Dieser Hohlraum hat jeweils einen Kanal zu jedem der Finger, 
sowie Daumen. Dort soll später die Angelschnur durchgeführt werden. Nahe dem 
Handgelenk befindet sich eine große Öffnung, diese ist für alle fünf Schnüre 
gedacht und hat ausreichend Größe für die Schnüre und eventuell auch für die Kabel der 
optionalen Kraftsensoren. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Halterung_1}}
		\caption{Ständer für die Handkomponente}
		\label{fig:Halterung_1}		
	\end{center}
\end{figure}
\hfill \break
Weiters wurde eine Halterung für die Roboterhand modelliert, diese soll mit 
der Roboterhand verbunden werden. Ihr Zweck ist, die Hand in eine erhöhte und 
leicht geneigte Position zu bringen. Durch das Neigen der Hand werden die fünf 
Angelschnüre bereits in Richtung Antriebsmechanik gerichtet, auch wird bewirkt, 
dass die Hand auf ihrer Höhe nicht unter dem Drehkopf des Servomotors positioniert 
wird. Für die Montage der gesamten Roboterhand auf der Halterung wird eine 
Aufsteckvorrichtung verwendet. Auf dem Gerüst sind fünf Pins mit einer 
Abschrägung und diese können in die Roboterhand mit Einkerbungen aufgesteckt 
werden. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Motorblock_1}}
		\caption{Servomotoren-Halterung und Umlenkungen}
		\label{fig:Motorblock_1}			
	\end{center}
\end{figure}
\hfill \break
Letztlich beinhalt das Modell der Roboterhand ein Element, welches hier als 
Motorblock bezeichnet wird. Dieses Element trägt diesen Namen, da es alle 
für die Antriebsmechanik relevanten Komponenten beinhaltet. \\
Das Modell setzt sich aus einer Grundplatte, der fünf Halterungen für die 
Motoren und jeweils einer passend angeordneten Umlenkung zusammen. \\
Die Halterungen besitzen eine Einkerbung in die der Servomotor eingesteckt 
werden soll, parallel dazu befindet sich eine 90° Umlenkung, welche dazu dient, 
dass, falls seitlich von unten die Schnur eingeführt wird, diese nach oben zum 
Servomotor geführt wird. \\
\\
\textbf{Zusammenbau} \\
\\
Wie bereits erwähnt, soll dieser Prototyp mit dem FDM-Druckverfahren gefertigt 
werden. Für den ersten Versuch wurden dabei ausschließlich die Glieder des 
Zeigefingers für den Druck gewählt. \\
Die drei Fingerglieder wurden mit einem Band und der Schnur befestigt. 
Der erste Versuch, in dem ausschließlich der Faltmechanismus und sein 
Verhalten bei Zug am Finger in Erfahrung gebracht werden, hat weitlaufende 
Erkenntnisse geliefert. Diese haben zu einem frühzeitigen Abbruch weiterer 
Tests geführt. Die sich dabei erschlossenen Problematiken und Erkenntnisse 
werden in [\textcolor{blue}{\autoref{par:Fazit und Ergebnisse}}] erläutert. \\
\\

\paragraph{Fazit und Ergebnisse}
\label{par:Fazit und Ergebnisse}
\hfill \break
\hfill \break
Der Grundstein für eine bewegliche Hand, welche Finger mit einem 
Faltmechanismus inkludiert, wurde mit diesem ersten Entwurf bereits gelegt. 
Dennoch haben sich in der Realität anhand eines einzelnen Versuchs 
entsprechend viele unbekannte Problematiken ergeben, die zu einem Verwurf des 
Konzepts geführt haben. \\
\\
Die entstandenen Problematiken:
\begin{itemize}
	\item Da die einzelnen Fingerglieder bei ihren Verbindungen aneinander 
	aufliegen und sich beim Falten mehr oder weniger aneinander abrollen, 
	entsteht zusätzlich mehr Reibung. Dies führt dazu, dass für den Mechanismus mehr Zugkraft benötigt wird.
	\item Demnach ist die Verbindung für immer jeweils zwei Glieder über zwei 
	parallel versetzte Bänder nicht die effizienteste Lösung oder gar die zuverlässigste. 
	Der gewünschte Effekt, dass sich der Finger einklappt, beziehungsweise 
	faltet, ist geschaffen, jedoch hat der Finger keine Stabilität. Würde man 
	ihn nach hinten biegen wollen, obwohl er bereits zu 50\% eingefaltet ist, 
	hätte man ein Spiel, mit dem es möglich wäre ihn zu formen. Beim Anhängen 
	einer Last direkt an der Fingerkuppe oder auf das mittlere Fingerglied 
	müsste somit ausschließlich die Zugschnur dafür sorgen, dass der Finger 
	weiterhin seine Form beibehält. Sinnhafter wäre es somit, die Fingerglieder 
	so zu modellieren, dass sich der Finger nicht nach außen falten oder in 
	diesem Fall besser gesagt biegen lässt, sondern ausschließlich nach innen. 
	Weiters ist auch bei der Verbindung anzumerken, dass der Finger sich auch 
	nach links oder rechts biegen kann. Diese Funktion ist jedoch nicht 
	erwünscht und muss mechanisch blockiert werden, die alleinige die Verwendung der 
	Bänder ist dabei zu schwach um dies zu verhindern.
	\begin{figure}[H]
		\begin{center}
			\scalebox{1.2}
			{\includegraphics[width=0.8 \linewidth]{Fingerskizze2}}
			\caption{Skizzierung der unregelmäßigen Faltmechanik}
			\label{fig:Fingerskizze2}			
		\end{center}
	\end{figure}
	\hfill \break
	\item Der folgende Text bezieht sich auf [\textcolor{blue}{\autoref{fig:Fingerskizze2}}]. \\
	Eine Fehlkonstruktion waren wie bereits erwähnt die Flächen zwischen den 
	beiden Fingergliedern, welche zu einem für mehr Reibung gesorgt haben als auch den einzelnen 
	Gliedern, aufgrund ihrer Form, nicht ermöglicht haben 
	sich aneinander abzurollen. Dies führt dazu, dass sich der Finger bei ausreichend 
	Zugkraft rapide einklappt und nicht gleichmäßig abrollt.  Wobei dies von großer 
	Bedeutung ist, da somit nicht bei linear ansteigender Zugkraft für eine 
	gleichmäßige Faltung gesorgt werden kann.
	\item Ebenso führt auch der Durchgang, welcher für die Zugschnur ist, zu 
	einem Problem. An jedem Ausgang des Tunnels reibt die Schnur stark an den 
	Rändern und dies führt zu mehr Reibung, sowie zu einem Schaden am Finger.
	Somit muss zusätzlich mehr Kraft angewendet werden.
\end{itemize}
\hfill \break
\textbf{Fazit} \\
\\
Wie in [\textcolor{blue}{\autoref{par:Realisierung und Zusammenbau}}] erwähnt, wurde aufgrund 
dieser Erkenntnisse der weitere Zusammenbau der Hand vorzeitig beendet und das 
Modell der Hand erstmalig verworfen. \\
Dennoch ist dieser Versuch äußerst lehrreich für die Entwicklung eines weiteren 
Prototypen, denn Reibung, Stabilität und die dadurch benötigte Kraft sind nun 
weitere Einflussfaktoren, auf diese in weiteren Designs mehr geachtet werden 
muss. \\
Auch hat sich gezeigt, dass der Faltmechanismus umsetzbar ist, jedoch ein Konstrukt 
erfordert, welches dem Finger ermöglicht sich in einem gleichmäßigen Verhältnis 
zur Zugkraft zu falten. \\
\\

\subsubsection{Entwicklungsstufe: InMoov}
\label{chap:Entwicklungsstufe: InMoov}
\paragraph{Einführung}
\hfill \break
\hfill \break
Im Versuch der Entwicklungsstufe \textquote{initial} haben sich zahlreiche Problematiken und 
Erkenntnisse ergeben, demnach erfordert die Weiterentwicklung der Hand 
die Unterstützung externer Fachkenntnisse.
Nach Recherche im Internet hat sich ergeben, dass der französische 
Bildhauer Gael Levin bereits 2012 für einen damaligen Kunden eine Handprothese 
entworfen hat und damit den Grundstein für sein heutiges Projekt 
InMoov gelegt hat. InMoov ist der erste Open-Source 3D druckbare humanoide 
Roboter im 1:1 Maßstab und ist gedacht für Forschung an Universitäten, in 
Laboratorien und auch für private Zwecke. \\
Ein großer Vorteil des Projekts ist es, dass bereits viele Erkenntnisse und 
Wissen in dieses eingeflossen sind. Ziel ist es, diese 3D druckbare Hand 
selbst zu realisieren, je nach Anforderung zu modifizieren und anhand dessen 
eine weitere Versuchshand zu schaffen. \\
\\
\paragraph{Mechanismus}
\label{par:Mechanismus_zweite_Hand}
\hfill \break
\hfill \break
Der Mechanismus der zweiten Versuchshand, welche den Namen \textquote{Entwicklungsstufe: InMoov} trägt, ist äußerst umfangreich und weist meist bessere Lösungen für Features der ersten Versuchshand, aus [\textcolor{blue}{\autoref{chap:Entwicklungsstufe: intitial}}], auf. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1}
		{\includegraphics[width=0.8 \linewidth]{Fingerskizze3}}
		\caption{mechanische Verbindung der einzelnen Fingerglieder}
		\label{fig:Fingerskizze3}			
	\end{center}
\end{figure}
\hfill \break
Die Problematik, dass wie beim vorherigen Modell die beiden Glieder aneinander reiben und sich nicht parallel zur Zugkraft kontinuierlich umrollen, ist hier nicht vorhanden, da die Konstruktion von Grund auf andere Eigenschaften aufweist. 
Denn die jeweiligen Glieder werden hier nicht mit Bändern verbunden, sondern mit einer Schraube, welche die beiden Glieder, die ineinander gehen, verbinden. Durch diese Verbindung sind die Finger stabil, können nicht nach links und 
rechts kippen und sich ausschließlich vom ausgestreckten Zustand nach innen falten. Auch wird mechanisch ein Falten in die andere Richtung blockiert. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.1}
		{\includegraphics[width=0.8 \linewidth]{Fingerskizze4}}
		\caption{Der InMoov-Faltmechanismus}
		\label{fig:Fingerskizze4}			
	\end{center}
\end{figure}
\hfill \break
Am tatsächlichen Faltmechanismus hat sich bis auf eine Anpassung am Elastomer nicht viel geändert, denn der Rückzug erfolgt nicht mehr traditionell per elastischem Band. Diese Umsetzung des Faltmechanismus ist jedoch von großer Bedeutung, da 
nur der Rückzug sowie die Faltung von ein und demselben Motor ausgelöst wird. Im Detail funktioniert der Mechanismus wie folgt: Am Servomotor wird eine runde Vorrichtung montiert, diese hat an der Außenkante 
eine beidseitige Verjüngung, an dieser soll die Schnur entlanglaufen. Nun verlaufen beide Schnüre, die für den Ein- sowie Auszug verantwortlichen Schnüre, jeweils auf einer Seite an dieser runden Vorrichtung und sind an dem Ende dieser montiert. 
Dreht sich nun der Motor um 90\textdegree, gibt er mehr Schnur her und verkürzt die zweite Schnur. Bei diesem Vorgang müssen jedoch beide Schnüre so gespannt sein, dass keine der beiden nachgibt und sich bei Bewegung des Motors lockert. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Inmoovhand}}
		\caption{Inmoovhand und ihre Komponenten (\textcolor{blue}{Quelle: \cite{Inmoovhand}})}
		\label{fig:Inmoovhand}			
	\end{center}
\end{figure}
\hfill \break
Das Modell der Handfläche, an dem alle Finger und weitere Komponenten zentral zusammenkommen, setzt sich selbst aus insgesamt vier tatsächlichen Elementen und zwei Hilfselementen zusammen. \\
Das Hauptelement ist in dem Fall die Handfläche, dies ist das größte und zentralste Element. Durch dieses verlaufen 15 Kanäle, die mittleren fünf dienen optionaler Sensorik. Die oberen fünf Kanäle sind für die Schnüre, 
welche dem Einfalten dienen, die unteren Kanäle dienen den Schnüren für den Rückzug. \\
Um die Hand noch dynamischer zu gestalten, besitzen der Ringfinger sowie der kleine Finger ein zusätzliches Element, welches sich bei Zug auf wenige Grad mitfaltet. Der Daumen hat eine ähnliche Funktion. \\
Als Hilfselement werden hier die Stifte zur Verbindung zwischen dem Hauptelement sowie den weiteren Elementen bezeichnet. \\
\\
Ein ebenso neuer und optionaler Mechanismus ist der des Handgelenks, dieser ermöglicht es der Hand um ihre eigene Achse zu rotieren. Umgesetzt wird dies mit einem Servomotor, welcher mit einer Übersetzung anhand zweier Zahnräder die Hand rotiert. \\
\\
Montiert wird dieser Handgelenksmechanismus auf ein Unterarmkonstrukt, dieses besteht aus mehreren einzelnen Teilen um den Druck auf einem kleinen Drucker zu ermöglichen. Grundsätzlich sind alle Modelle des Projekts \textquote{InMoov} für einen Drucker 
mit eine Druckfläche von 12x12cm ausgelegt. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{Roboterhand_Version2}}
		\caption{Realisierung der Entwicklungsstufe: InMoov}
		\label{fig:Roboterhand_Version2}			
	\end{center}
\end{figure}
\hfill \break
Im Unterarm befindet sich an der Innenseite eine Umlenkung, die die Schnüre über den Rotationsmechanismus des Handgelenks lenkt. Dies verhindert vor allem eine Reibung zwischen den Schnüren und dem Servomotor für das Handgelenk, welcher in der 
idealen Strecke zwischen Schnur und Zielmotor steht. \\
\\
Weiters werden daraufhin die Schnüre zum Motorblock der Antriebsmechanik für den Faltmechanismus der Finger geführt. In diesem Block befinden sich fünf Motoren für die Finger.
Dort wird der bereits beschriebene Mechanismus der beiden Schnüre umgesetzt. \\
\\
Wurde ein Modell in einer CAD-Software wie beispielsweise Fusion 360 [\textcolor{blue}{\autoref{chap:Fusion 360}}] entworfen und soll nun in ein reales greifbares Objekt umgewandelt werden, so benötigt man eine sogenannte Slicer-Software. Die Bezeichnung \textquote{Slicer} stammt dabei vom englischen 
Wort Slice (engl.) und bedeutet so viel wie Scheibe. Dies liegt daran, dass diese Software das 3D-Modell in einzelne Scheiben mit einer Sichthöhe geringer als 1mm teilt, denn wie bereits in [\textcolor{blue}{\autoref{par:Fertigung und CAD}}] erklärt, geht das 3D-Druck Verfahren 
FDM so beim Schaffen eines realen Objekts vor. \\
Gewählt wird die Open-Source Software Ultimaker Cura, in der Version 5.6.0, in dieser kann man zahlreiche Optionen wählen: Die Sichthöhe der einzelnen Scheiben, in Fachsprache \textquote{Layers}, die Druckgeschwindigkeit, die Fülldichte, ob Stützstrukturen für den 
Druck vorhanden sein sollen oder nicht. Durch das Regeln dieser Optionen wird die Druckqualität beeinflusst. Druckt der Drucker zu schnell, so leidet die Qualität und es können Fehler im Druck auftauchen, ist die Schichthöhe zu hoch ist der Druck, 
äußerst ungenau und weist eine unschöne Textur an seiner Oberfläche auf. \\
Auch können Faktoren, wie die Drucktemperatur oder das Filament, gewählt werden. Je nach Filament gibt es bereits im Vorhinein konfigurierte Optionen. \\
\\
Sind nun alle gewünschten Werte angepasst, kann \textquote{gesliced} werden dabei wird nun von der Software das Objekt in einzelne Scheiben geteilt und ein g-code File erstellt, welches dem Drucker daraufhin Anweisungen gibt. \\
\\
Ein Druck dauert in der Regel mehrere Stunden, dies variiert jedoch je nach Drucker – neuere schaffen das selbe Ergebnis in 20\% der eigentlichen Druckzeit. \\
Nach einiger Zeit ist der Druck fertig und kann von der Druckplatte gelöst werden, vorhandene Stützstrukturen können im Bestfall einfach vom Druck gelöst werden. \\
\\
Für den Zusammenbau der InMoov Hand werden neben dem Druck auch weitere Elemente benötigt, die nicht aus dem 3D-Drucker stammen. 
Als Auflistung die zusätzlich benötigten Komponenten:
\begin{itemize}
	\item 16 Stück M3x20mm Schrauben
	\item 16 Stück M3-Muttern
	\item Superkleber
	\item Angelschnur: 3 Meter
\end{itemize}

\paragraph{Fazit und Ergebnisse}
\hfill \break
\hfill \break
Der Versuchsaufbau hat nur kurzfristig und teilweise funktioniert. Für einen kurzen Moment konnten alle Finger, sowie der Daumen geöffnet und geschlossen werden. Der Faltmechanismus hat sich zwar bewiesen, jedoch mit einigen Unstimmigkeiten. \\
Während des Testens sind zwei Punkte besonders auffällig gewesen: Zu einem die Stabilität mit und ohne Belastung, sowie die Spannung der jeweils beiden Schnüre. Unter die Stabilität fallen in diesem Fall das gesamte Gerüst vom einzelnen Finger 
bis zum Motorblock, die Antriebsmechanik und ihre Halterung für die Umwicklung. Zum anderen die Schnüre, welche einige Probleme und demnach auch Schäden verursacht haben. \\
\\
\textbf{Problematik-1: \textquote{Unstimmigkeiten bei dem Umwickeln der jeweils beiden Schnüre}} \\
Wie in [\textcolor{blue}{\autoref{par:Mechanismus_zweite_Hand}}] erläutert, sollen sich beide Schnüre um eine runde Halterung wickeln und dabei je nach Drehung den verbundenen Finger ein -oder auffalten. Damit dieser Mechanismus funktioniert, müssen beide Schnüre 
ständig unter Spannung stehen, da sonst die Gegenwirkung des Systems nicht vorhanden ist und der Finger überklappen kann. \\
Es gab mehrere Lösungsversuche, unter anderem den Servomotor in 5\textdegree Schritten von 0 bis 180\textdegree zu approximieren und dabei während jedes Schrittes die Schnüre nachzuspannen, jedoch blieb auch dies erfolglos. \\
\\
\textbf{Problematik-2: \textquote{Instabilität der Halterungen auf dem Motor}} \\
Die Angelschnur hat neben ihren Vorteilen auch einen trivialen Nachteil, denn sie ist sehr dünn und daraus folglich unter Spannung äußerst schneidend. Stand die Schnur unter zu hoher Spannung, hat dies dazu geführt, dass diese sich 
selbst aufgrund der zu hohen Reibung durch die Halterung am Motor geschnitten hat und ihn dabei meist auch horizontal zerteilt halt. Nach Erkenntnis dieses Problems gab es drei grundlegende Lösungsversuche:

\begin{itemize}
	\item \textbf{Lösungsversuch 1:} \\
	Hier wurde versucht, das gedruckte Objekt selbst härter und dicker zu drucken. Umgesetzt wurde das durch Erhöhen der Fülldichte von 25\% auf 65\%, dadurch ist das innere Modell dichter. Weiters wurde auch die Wandstärke 
	und -dicke erhöht. \\
	Das Ergebnis war ernüchternd, bereits nach neuem Anspannen führte es wieder zum selben Problem und die Halterung hielt nicht stand.
	\item \textbf{Lösungsversuch 2:} \\
	Nach genauerem Hinblick wurde klar, es liegt am Druckverfahren, denn wie bereits erklärt druckt der Drucker in einzelnen Schichten. Das Problem: Die Schnur liegt parallel zu den einzelnen Schichten und genau zwischen diesen Schichten 
	liegen die Schwachpunkte des Modells. Somit wurde die Entscheidung getroffen, das Modell so zu drucken, dass die Schnur und die einzelnen Schichten nicht parallel zueinander liegen, bewirkt wurde dies, indem die Halterung in einem 45\textdegree 
	Winkel gedruckt wurde.
\end{itemize}
\hfill \break
Der zweite Lösungsversuch ist somit erfolgreich und die Schnur schneidet oder halbiert nicht mehr die Halterung. Jedoch nicht perfekt, denn die Schnur reibt an der gerippelten Oberfläche der Halterung. In diesem Fall muss ein anderes Material als 
PLA und damit auch ein anderes 3D-Druckverfahren verwendet werden. Ergeben hat sich der SLS (engl. Selective Laser Sintering). Dies ist ebenso eine additive Fertigungstechnologie, dabei verschmilzt ein Laser selektiv Pulverpartikel und das 
schichtweise, um daraus dann das gewünschte 3D-Objekt zu fertigen. Finalerweise entstanden dann für das Projekt Halterungen aus dem Material Nylon mit Glasfaserverstärkung. \\ %\footnote{\url{https://sls3d.de/wissen/was-ist-selektives-lasersintern/\#:\~:text=SLS\%20\%E2%80%93%20engl.,(3D\%2DDruck)\%20aufzubauen}, (Stand: 24.02.2024)} \\
\\
\textbf{Problematik-3:} \\
Zwar sind Angelschnüre sehr stabil und stark, tendieren jedoch unter ständiger Reibung trotz ihrer achtfachen Flechtung mit der Zeit zu reißen. Die Strecke von Fingerkuppe bis zum Motor beträgt dabei je nach Finger zwischen 20-30cm, 
auf dieser Strecke reibt sich die Schnur an mehreren Stellen des Modells auf. Da dieses Problem erst mit der Zeit auftritt und somit mit der Hand dennoch ausgiebig getestet werden kann bis zum nächsten Riss, wurde dieses Problem im Versuchsaufbau der 
zweiten Hand noch nicht behandelt. \\
\\
\textbf{Problematik-4: } \\
Ein weiteres Problem ist die Befestigung der Schnur am Fingerende, der Fingerkuppe. Diese hat zwei Bohrungen bzw. Löcher, zwischen diesen werden beide Schnüre befestigt. Das Problem ist, da diese Schnüre so klein sind und dauerhaft 
unter Spannung stehen, dass die Fläche zwischen den Löchern meist einreißt und die Schnüre nicht mehr befestigt werden können. \\
\\
Das Modell löst einige Probleme und schafft neue Ansätze. Der Faltmechanismus wurde grundlegend erweitert, der Rückzug wird nun nicht mehr per Elastomer, sondern mit einer zweiten Schnur bewirkt.
Die einzelnen Fingerglieder sind tatsächlich mechanisch durch eine Schraube miteinander verbunden. \\
All dies führt zu präziseren und genaueren Bewegungen, der Faltmechanismus erfolgt annähernd linear zur Zugkraft. Trotzdem hat sich herausgestellt, wie brüchig das Modell ist, besonders an den Fingern. Reibung ist weiterhin ein großes Thema und 
wird durch die zweite Schnur im Faltmechanismus noch trivialer. \\
Ziel ist es, im dritten Versuchsmodell die Problematik mit der Reibung zu verringern und daraus folglich auch ein stabileres Modell zu ermöglichen.\\
\\

\subsubsection{Entwicklungsstufe: Silikon}
\label{chap:Entwicklungsstufe: Silikon}
\paragraph{Das Konzept}
\hfill \break
\hfill \break
Nachdem die vorherigen Versuche erwiesen haben, welche Problematiken sich aus einem festen Modell aus PLA ergeben, stand ein großes Umdenken im Raum. Auf Vorschlag einer Betreuungskraft stellte sich heraus, dass das Modell elastischer sein muss und 
ein hartes Material nicht immer die beste Lösung ist. Der Vorschlag war Silikon in das Modell der Hand zu integrieren, in einem ähnlichen Projekt wurde so bereits eine Hand realisiert. Ähnlich wie bei dem Modell aus [\textcolor{blue}{\autoref{chap:Entwicklungsstufe: intitial}}] bestanden 
dort die einzelnen Glieder aus einzelnen Teilen, zwar aus Silikon, waren jedoch auch per Elastomer verbunden. Die Handfläche bestand bei dem Modell aus dem Vorschlag dennoch aus hartem Kunststoff. \\
\\
Für das Projekt \textquote{Bionic-Hand} ergab sich eine neue Ebene und Vielfalt der Möglichkeiten. Die neue Idee ist es, die gesamte Hand vollständig aus Silikon zu entwickeln und somit Problemen wie der Reibung und Brüchen unter starker Last aus dem 
Weg zu gehen. \\
\\
Genauer lässt sich das neue Konzept wie folgt beschreiben: Die gesamte Hand besteht aus dem Material Silikon, seien es die einzelnen Finger, der Daumen und die Handfläche. Daraus ergeben sich mehrere Vorteile. Zu einem ein hoher Grip (engl.), aufgrund des 
Silikons hat die Hand beim Greifen mehr Griff und Objekte können gehalten werden, ohne aus der Hand zu rutschen. Der nächste Vorteil ist, dass die Hand anpassbarer wird und sich aufgrund ihrer elastischen Struktur genau um das Objekt stülpen kann, 
dies ist eine große Verbesserung im Vergleich zu der festen Hand aus hartem Kunststoff. \\
Eine Hand aus Silikon springt von selbst wieder in ihre Ursprungsposition zurück, dies liegt an den Eigenschaften des Materials, dadurch wird sich ein externer Elastomer erspart, der Rückzug erledigt sich von selbst. Die Fingerglieder der Hand sollen 
ähnlich wie bei den vorherigen Modellen eine Verjüngung zueinander haben und durch Zug an der Schnur der Finger sich falten. Reibung dürfte nach Überlegungen nicht mehr existieren, da die Schnur bei Bewegung das Material eher bewegt und nicht wirklich 
reibt. Befestigt wird die Silikonhand dann an einer Vorrichtung am Handgelenk. \\
\\

\paragraph{Gussform}
\label{par:Gussform}
\hfill \break
\hfill \break
Eine Herausforderung von diesem Versuchsmodell ist das Verfahren des Silikongusses.  Um das Verfahren des Silikongießens zu verstehen, wird eine Gussform in der CAD-Software entworfen. \\
\\
Als Testobjekt wurde ein einfacher Finger, welcher einen Faltmechanismus ermöglicht, entworfen. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Silikon_Testfinger1}}
		\caption{Innenseite des Silikonfingers}
		\label{fig:Silikon_Testfinger1}			
	\end{center}
\end{figure}
\hfill \break
Im oberen Teil des Fingers verläuft durch jedes einzelne Glied ein Kanal für die Zugschnur, die Verbindung zwischen den einzelnen Gliedern wird durch einen Steg geschaffen. Bei Zug an der Schnur faltet sich dann der Finger an den dünneren Punkten, dem Steg, zwischen den Fingergliedern. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Silikon_Testfinger2}}
		\caption{Außenseite des Silikonfingers}
		\label{fig:Silikon_Testfinger2}			
	\end{center}
\end{figure}
\hfill \break
Um diese Fläche optional nochmals im Nachhinein zu verdicken und dadurch zu beeinflussen, wie stark der Rückzug ist, wurden zwei Einkerbungen in das Modell des Fingers implementiert. Durch das Aufgießen mit Silikon dieser rechteckigen Einkerbungen 
an den Biegungspunkten kann dies bewirkt werden. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Silikon_Testfinger_Gussform}}
		\caption{Gussform des ersten Gussversuchs}
		\label{fig:Silikon_Testfinger_Gussform}			
	\end{center}
\end{figure}
\hfill \break
Der ganze Finger wird in eine Gussform gegossen, diese besteht aus zwei Teilen, um den Finger leicht aus der Form lösen zu können, ohne dabei die beiden Objekte zu beschädigen. \\
Verbunden sind beide Teile der Form mit einem Steckmechanismus, wie in der [\textcolor{blue}{\autoref{fig:Silikon_Testfinger_Gussform}}] ersichtlich. Am oberen Teil der Gussform befindet sich ein Loch. In dieses wird das flüssige Silikon später gegossen, das Loch wurde extra groß 
dimensioniert, damit gleichzeitig auch die Luft im Innenraum entweichen kann. \\
\\
Das hier verwendete flüssige Silikon besteht aus zwei Komponenten, welche als Teil A und Teil B bezeichnet werden. Teil A ist die Hauptkomponente des Silikons und Teil B ist die Härtekomponente, zusammen vermischt führt dies zu einem festen elastischen 
Material. \\
\\
Das Ergebnis nach dem ersten Guss: Während des Entwurfs der Gussform wurde nicht daran gedacht, dass das Loch für den Einguss auf derselben Höhe wie die höchste Fläche oder Decke des Innenraums sein muss. Durch diesen Fehler hat sich ab dieser Höhe 
ein Luftraum gebildet, welcher nicht mit Silikon gefüllt wurde. \\
\\
\textbf{Verbesserung:} \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Silikon_Testfinger_Verbesserung}}
		\caption{Gussform des zweiten Gussversuchs}
		\label{fig:Silikon_Testfinger_Verbesserung}			
	\end{center}
\end{figure}
\hfill \break
Dies wurde durch eine Form, in der der Finger aufrechtstehend gegossen werden soll, verbessert. Das Loch ist somit am Anfang des Fingers und die Luft kann vollständig entweichen. Eine kleine Anpassung ist, dass neben dem Steckmechanismus auch eine 
Verschraubungsmöglichkeit geschaffen wurde um die beiden Teile der Gussform stärker aneinander zu pressen, dies verhindert das Austreten von Silikon während des Gusses. \\
Gezeigt hat sich nach dem Guss, dass das fertige Objekt aus Silikon sich auch in andere Richtungen biegen lässt als ausschließlich in die Faltrichtung. Um alle anderen Richtung außer die gewünschte zu verhindern, benötigt der Finger einen 
Stabilisator von innen, ähnlich dem Finger des Menschen, welcher einen Knochen hat. \\
\\

\paragraph{Gelenke}
\hfill \break
\hfill \break
Um zu verhindern, dass sich der Finger nach links, rechts, oder nach hinten biegt, also nicht in die Richtung in die er sich falten soll, wird im Inneren des Fingers etwas benötigt, das nur das Biegen in die Faltrichtung erlaubt. Somit benötigt man ein 
mechanisches Gelenk, welches durch den gesamten Finger verläuft. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Gelenke1}}
		\caption{innere Ansicht des Fingergelenks}
		\label{fig:Gelenke1}			
	\end{center}
\end{figure}
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Gelenke2}}
		\caption{äußere Ansicht des Fingergelenks}
		\label{fig:Gelenke2}			
	\end{center}
\end{figure}
\hfill \break
Das Gelenk besteht aus drei Komponenten, verbunden sind diese durch eine Schraube, exakt an dem Punkt an dem sich der Finger beim Falten biegt. Durch eine mechanische Blockade kann sich das Gelenk ausschließlich in Faltrichtung falten. \\
Mit einer Erweiterung wird das gesamte Modell in der Gussform befestigt und positioniert, nach dem Guss findet sich dann das Gelenk eingegossen im Finger. \\
\\
\textbf{Ergebnis:} \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Gelenke_real}}
		\caption{Silikonfinger mit eingegossenem Gelenk}
		\label{fig:Gelenke_real}			
	\end{center}
\end{figure}
\hfill \break
Während des Gusses ist Silikon ausgetreten, obwohl bereits im Vorhinein vorgesorgt wurde, dass dies nicht passiert – wie beispielsweise durch die Verschraubmöglichkeiten, mit denen beide Teile aneinander gepresst werden sollen oder die Steckvorrichtung. 
Gelöst wurde dies mit Klebebändern, die zum Abdichten verwendet wurden. \\
Trotz der Komplikationen hat sich der Versuch als erfolgreich herausgestellt, denn der Finger funktioniert im Zusammenspiel mit dem Gelenk wie erwartet. \\
\paragraph{Entwurf einer neuen Gussform}
\hfill \break
\hfill \break
Nachdem sich gezeigt hat, dass ein einzelner Finger umsetzbar ist, war der nächste Schritt eine gesamte Hand zu entwerfen. Für diese wird somit ein vollständiges Gelenksgerüst für die gesamte Hand benötigt, ein Modell einer Hand sowie eine dafür entworfene 
Gussform. \\
\\
Grundsätzlich ist das Ziel die gesamte Hand aus Silikon zu verwirklichen und diese aus Silikon zu gießen. Der Faltmechanismus funktioniert dabei wie in [\textcolor{blue}{\autoref{par:Mechanismus_zweite_Hand}}], mit der zusätzlichen Eigenschaft, dass die Finger früher 
in der Handfläche beginnen, damit sich diese besser um das gewünschte Objekt falten kann. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Silikonhand_3Dmodell2}}
		\caption{Modell der Silikonhand mit integrierten \textquote{Knochengelenken}}
		\label{fig:Silikonhand_3Dmodell2}			
	\end{center}
\end{figure}
\hfill \break
Ohne nun bereits auf das Gerüst einzugehen, ist in dieser Grafik zu sehen, dass die Handfläche zwischen den Fingern kein Material hat. Dies schafft auch die optionale Möglichkeit die Finger mit einem weiteren Mechanismus seitlich zu bewegen. \\
In [\textcolor{blue}{\autoref{fig:Silikonhand_3Dmodell2}}] ist ebenso die sich von den anderen Fingern unterscheidende Anordnung des Daumens ersichtlich, dieser liegt seitlich und soll sich beim Falten ähnlich wie der echte Daumen des Menschen verhalten. \\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Skelett1}}
		\caption{aktuelle Version des Gelenks}
		\label{fig:Skelett1}			
	\end{center}
\end{figure}
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Skelett2}}
		\caption{vorherige Version des Gerüsts}
		\label{fig:Skelett2}			
	\end{center}
\end{figure}
\hfill \break
Das Gerüst hat dabei eine triviale Neuerung, denn es wurde sich an den tatsächlichen Knochen eines Menschen orientiert, damit soll für mehr Ähnlichkeit zur Anatomie der menschlichen Hand gesorgt werden. \\
\\
Im Unterschied zu einer vorherigen Version des Gerüsts, ist zu erkennen, welche Vorteile die neue gegenüber der alten hat. Unter anderem ist diese viel flexibler und hat keine große und starre Handwurzel. 
Ein weiterer Unterschied ist die Verbindung der einzelnen Knochen in jedem Finger. Anders wie bei der alten Version werden hier keine Schrauben zur Verbindung einzelner Gelenksteile sondern Gummikordeln verwendet. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{Fingerglieder}}
		\caption{Verbindung der einzelnen Glieder mit Gummikordeln}
		\label{fig:Fingerglieder}			
	\end{center}
\end{figure}
\hfill \break
Diese neue Form der Verbindung war notwendig um die einzelnen Elemente der Knochen platzsparend und effektiv zu verbinden. Zwar wurde kurzzeitig eine Verbindung anhand einer Schraube getestet, dies zeigte jedoch, dass das mit der Größe der Knochen 
und dem Raum im Finger nicht umsetzbar wäre. Zwar blockiert dieser Mechanismus nicht Bewegungen in alle anderen Richtungen außer die Faltrichtung, schafft jedoch mehr Flexibilität für den Finger – dennoch wurde jeder Finger so modelliert und an den 
Krümmungsstellen so verstärkt, dass er sich hauptsächlich in die Faltrichtung biegt. \\
\\

\paragraph{Gussform und Gussversuch der gesamten Hand}
\hfill \break
\hfill \break
Für den Guss der gesamten Hand wird ähnlich wie bei dem Finger aus [\textcolor{blue}{\autoref{par:Gussform}}], eine Gussform benötigt, diese Gussform hat jedoch ein größeres Spektrum an Anforderungen. Mitunter muss berücksichtigt werden, dass das \textquote{Skelett}, auch 
bekannt als das Gelenksgerüst, präzise in der Mitte eines Fingers platziert werden muss. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Gussform1}}
		\caption{unteres Element der Gussfom}
		\label{fig:Gussform1}			
	\end{center}
\end{figure}
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Gussform2}}
		\caption{oberes Element der Gussform}
		\label{fig:Gussform2}			
	\end{center}
\end{figure}
\hfill \break
Zu sehen sind in den beiden Grafiken vier Teile der Gussform. Dies ist darauf zurückzuführen, dass die Druckfläche des Druckers sonst überschritten werden würde. Daher muss jeweils der untere und der obere Teil der Form halbiert werden. Zu der 
unteren Hälfte der Gussform in der linken Grafik gehört das rote und braune Element und zu der oberen gehören wie in der rechten Grafik sichtbar das beige und graue Element. Befestigt werden die beiden Teile jeweils mit vier Stiften in Form einer 
Steckvorrichtung. Sichtbar ist ebenso zwischen dem unteren und dem oberen Element der Gussform eine weitere Steckvorrichtung, durch diese werden beide Hälften der Form verbunden. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Gussform3}}
		\caption{Gussform mit Halterung}
		\label{fig:Gussform3}			
	\end{center}
\end{figure}
\hfill \break
Wie in dieser Veranschaulichung ersichtlich wird in aufrechtem Zustand der Gussform das Silikon in das obere Loch eingegossen. Wie in [\textcolor{blue}{\autoref{par:Gussform}}] an einem Versuch zu sehen ist, ist es von großer Bedeutung, dass das Eingussloch an der höchsten 
Stelle des Innenraums liegt. Um sicherzustellen, dass die Hand stets aufrecht bleibt und während des Härteprozesses des Silikons gesichert in ihrer Position bleibt, wurde eine Halterung entworfen, auf welche die Form gesteckt werden kann. Das Loch 
wurde möglichst groß modelliert, damit die im Innenraum verbleibende Luft der Gussform ausreichend entweichen kann. \\
\\
\textbf{Resultate des Gussversuchs:} \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Silikonhand_Fehlversuch}}
		\caption{Silikonhand Fehlversuch}
		\label{fig:Silikonhand_Fehlversuch}			
	\end{center}
\end{figure}
\hfill \break
Der Gussprozess ist nicht einwandfrei verlaufen, mitunter lag dies hauptsächlich an den Lücken zwischen den einzelnen Elementen. Aufgrund des FDM-Druckverfahrens sind zwischen den einzelnen Flächen entweder Rillen oder versetzte Schichten und dies 
führt dazu, dass diese nicht exakt aufeinander aufliegen. Dort fließt das Silikon dann meist aus der Gussform aus. \\
Um diesem Problem entgegenzuwirken, ohne das Model aus Kostengründen neu drucken zu müssen, gab es folgende Lösungsversuche:
\begin{itemize}
	\item Ein Versuch war es, mit einem dichtenden Klebeband diese Freiräume von außen abzudichten. Dies hat kaum zu einer Verbesserung beigetragen. Das Band hat dem Druck vom Silikon meist nicht standgehalten und hatte keine ideale Haftung an 
	den äußeren Wänden der Gussform.
	\item Weiters wurde versucht mit einer Dichtmasse abzudichten, doch selbst diese konnte das Modell nicht vollständig abdichten. Zwar wurde es besser, jedoch besonders an komplexeren Bereichen, wie bei dem Daumen gab es keine bemerkbare Verbesserung.
\end{itemize}
\hfill \break
Letztlich konnte kein nutzbares Ergebnis mit der Gussform erzielt werden. Die Versuche das Modell abzudichten waren nur teilweise erfolgreich. Wie an dieser Abbildung ersichtlich konnten die Finger zwar gegossen werden, jedoch konnte das Silikon 
nicht die \textquote{Handfläche} halten ohne auszurinnen. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Silikonhand_Fehlversuch2}}
		\caption{Notkonzept: Handfäche aus hartem Kunststoff (PLA)}
		\label{fig:Silikonhand_Fehlversuch2}			
	\end{center}
\end{figure}
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Silikonhand_Fehlversuch3}}
		\caption{Realisierung des Notkonzepts}
		\label{fig:Silikonhand_Fehlversuch3}			
	\end{center}
\end{figure}
\hfill \break
Jedoch gab es einen Notlösungsversuch um das vorhandene Material zu retten, dafür wurden die Finger abgeschnitten bis zu dem Punkt, an dem der Guss nicht gelungen ist, daraufhin vermessen und ein Modell wurde modelliert. Dieses ersetzt die Handfläche 
aus Silikon mit einer 3D gedruckten und auf diese können die bestehenden Silikonfinger auf eine Einkerbung für diese gesteckt werden. In der Abbildung ist der Unterschied zwischen Silikon und Kunststoff anhand der Farben zu sehen, dunkelgrau steht 
für das 3D gedruckte Modell und die beige Farbe für das Silikon. Zu sehen sind auch fünf Kanäle, durch diese soll die Angelschnur gehen und an den Fingern ziehen. \\
\\
In der Praxis hat sich dann herausgestellt, dass die Finger sehr weich sind und daher ihr eigenes Gewicht kaum halten können. Der Faltmechanismus funktioniert jedoch nicht ausreichend und auch nicht in gewünschtem Maße. Lösen könnte man die 
Instabilität der einzelnen Fingern mit härterem Silikon. Grundsätzlich wurde moderat hartes Silikon gewählt, mit dem Härtefaktor 25A, das doppelte somit 50A oder mehr wären notwendig um die Finger stabil zu halten. \\
\\
Die Problematik mit dem Guss, dass das Modell sich nicht in einem gießen lässt und die Erkenntnis beim Notmodell, dass die Finger nicht stabil bleiben, haben gezeigt, dass dieses Konzept für unser Projekt nicht tauglich ist. Aufgrund dieser 
Ergebnisse wird das Konzept vorerst verworfen, dennoch soll Silikon weiterhin ein Bestandteil der zukünftigen Modelle bleiben, besonders aufgrund des Griffs, der damit gesichert werden kann. \\
\\

\subsubsection{Entwicklungsstufe: Hybrid} 
\label{chap:Entwicklungsstufe: Hybrid}
\paragraph{Erfahrung und Konzepterläuterung}
\hfill \break
\hfill \break
Aus den Versuchen der letzten Kapitel konnte einiges an Erfahrung gesammelt werden. Nun ist klar, worauf bei dem Modell einer Hand geachtet werden muss. \\
Wie in [\textcolor{blue}{\autoref{chap:Entwicklungsstufe: intitial}}] hat sich gezeigt, dass sich die einzelnen Fingerglieder kontinuierlich um die anderen falten müssen. Auch hat sich im Kapitel der Entwicklungsstufe Inmoov gezeigt, wie wichtig es ist für ein Modell zu sorgen, das einer hohen 
Last standhält und nicht brüchig ist. In den letzten Versuchen hat sich gezeigt, dass die Zugschnur an sämtlichen Stellen auf Reibung trifft. \\
\\
Entdeckt wurde eine erweiterte Version der Hand aus [\textcolor{blue}{\autoref{chap:Entwicklungsstufe: InMoov}}] von Gael Levin. Diese hat sämtliche Optimierungen, unter anderem der zu bemängelnden Stabilität der vorherigen Version oder auch des problematisches Mechanismuses der 
Zugschnüre. Im neuen Modell der \textquote{i2Hand} sind die Fingerglieder besonders an ihren Schwachstellen verstärkt worden, somit kann verhindert werden, dass die Verbindungen der einzelnen Glieder bei hoher Last oder gar der Montage brechen. Die 
Verbindungen haben vorgesehene Einkerbungen für den Kopf der Schraube oder eine Mutter, somit steht an den Seiten der Finger nichts ab. \\
Der Faltmechanismus besteht nicht mehr aus zwei Schnüren, sondern reduziert sich ausschließlich auf die Zugschnur, diese hat eine eigene Führung mit abgerundeten Kanten um die Reibung zu reduzieren. Der Rückzug wird durch eine Zugfeder verursacht, 
diese erstreckt sich durch den gesamten Finger und ist am Anfang und seinem Ende montiert. \\
\\
Doch nicht alles war ideal an dem Modell der neuen Hand, denn der Motorblock wurde nicht optimiert und nutzt weiterhin den Mechanismus, bei dem sich die Zugschnur um einen Aufsatz auf dem Motor wickelt. Daher muss eigens ein neuer Mechanismus 
entworfen werden. In diesem soll die Drehbewegung des Servomotors in eine geradlinige Zugbewegung übersetzt werden. \\
\\
\paragraph{Erster Entwurf}
\hfill \break
\hfill \break
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Motorblock_v2}}
		\caption{Rekonstruktion des Motorblocks}
		\label{fig:Motorblock_v2}			
	\end{center}
\end{figure}
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Motorblock_v2_Mechanismus}}
		\caption{Mechanismus mit Zahnrad und Zahnstange}
		\label{fig:Motorblock_v22}			
	\end{center}
\end{figure}
\hfill \break
In der [\textcolor{blue}{\autoref{fig:Motorblock_v2}}] ist ein Gerüst zu sehen, dieses wird in Kombination mit den fünf Motoren, den zugehörigen Zahnstangen und Zahnrädern als Motorblock bezeichnet. Auf jeden Motor wird ein Zahnrad befestigt. Dreht sich dieses Zahnrad, bewegt es die 
in der Fassung platzierte Zahnstange. Der Mechanismus nennt sich \textquote{Rack and Pinion} (engl.) und wurde so dimensioniert um mit einer Drehung von 180\textdegree die Zahnstange um 60mm zu bewegen. \\
\\
Nach dem Druck und einer ersten Inbetriebnahme hat sich die Funktionalität des Mechanismus erwiesen. Der Motor dreht sich und wandelt dies in eine geradlinige Zugbewegung um, auf der Zahnstange wird dann die Angelschnur montiert und somit kann an 
dieser kontrolliert gezogen werden. \\
\\

\paragraph{Verbesserungen – zweiter Entwurf}
\hfill \break
\hfill \break
Neben der Funktionalität hat sich gezeigt, dass das Modell in einer deutlich kleineren Form und raumeffizienter entworfen werden kann. Dafür spricht, dass sich die Zahnstange nur um 30mm bewegen muss um den Finger ausreichend zu falten. 
Dadurch konnte der Durchmesser des Zahnrades um ein Vielfaches verkleinert werden und dies bewirkt, dass die Halterung auch kleiner ausfällt. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1}
		{\includegraphics[width=0.8 \linewidth]{Zahnstangenmechanismus_Unterarm}}
		\caption{Verbesserung der ersten Rekonstruktion}
		\label{fig:Zahnstangenmechanismus_Unterarm}			
	\end{center}
\end{figure}
\hfill \break
In diesem Modell ist zu sehen, dass alle Servomotoren auf einer Höhe liegen. Diese werden auf einer Servohalterung (2) montiert, welche dann auf der Platte (1) montiert wird. Aufgrund der Toleranzen des 3D-Drucks können die Halterungen mit 
Langlöchern adjustiert werden. Das Modell wurde mit der Rücksicht entworfen, Schrauben und Muttern im Modell zu versenken. \\
\\

\paragraph{Realisierung und Aufbau}
\hfill \break
\hfill \break
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{Handv2_real}}
		\caption{Roboterhand Etnwicklungsstufe Hybrid}
		\label{fig:Handv2_real}			
	\end{center}
\end{figure}
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{Handv2_real_Zugfeder}}
		\caption{Rückzugsmechanismus der Entwicklungsstufe Hybrid}
		\label{fig:Handv2_real_Zugfeder}			
	\end{center}
\end{figure}
\hfill \break
Die realisierte Hand, welche eine von Gael Levin erweiterte Version der Hand aus 
[\textcolor{blue}{\autoref{chap:Entwicklungsstufe: InMoov}}] ist, weist auch in der Realität eine 
deutlich höhere Stabilität als die der vorherigen Hand auf. Besonders die 
Verbindung der Fingergelenke und deren Wandstärke hat sich bereits bei der Montage 
als äußerst stabil erwiesen. Zu Schwierigkeiten kam es beim Einbauen der Zugfeder, 
welche für den Rückzug des Fingers verantwortlich ist, da diese sich schwer durch 
die Führungen ziehen ließ und währenddessen gespannt werden musste. Auch wurden 
Fingerkuppen aus Silikon in einer entsprechenden Form gegossen, welche für mehr 
Grip sorgen sollen. \\
\begin{figure}[H]
	\begin{center}
		\scalebox{1}
		{\includegraphics[width=0.8 \linewidth]{Unterarm_real}}
		\caption{Mechanismus der Entwicklungsstufe Hybrid}
		\label{fig:Unterarm_real}			
	\end{center}
\end{figure}
\hfill \break
In der [\textcolor{blue}{\autoref{fig:Unterarm_real}}] sind die gedruckten Komponenten des Motorblocks 
zu sehen, die Montage ist jedoch nur durch ein Zusammenspiel von Software und 
Hardware möglich. Der Servomotor muss in die Position 0 gestellt werden, folglich 
wird die Zahnstange mit gespannter Schnur entsprechend positioniert, daraufhin 
darf erst das Zahnrad montiert werden. Für die Zahnstangen war eine Anpassung 
notwendig, da diese etwas zu dick für die Führungen waren. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1}
		{\includegraphics[width=0.8 \linewidth]{Arm_real}}
		\caption{Mechanismus Entwicklungsstufe Hybrid mit Oberarmerweiterung}
		\label{fig:Arm_real}			
	\end{center}
\end{figure}
\hfill \break
Neben dem Entwurf und der Realisierung des Unterarms wurde zusätzlich aus 
Eigeninitiative der von Gael Levin gefertigte Oberarm und das dazugehörige 
Schultergelenk gedruckt und an ein entsprechendes Gerüst befestigt. Jedoch ist diese 
Erweiterung nicht motorisiert worden, dies hat den Grund, dass das Diplomprojekt
von der Abteilung abgenommen und im Robotik-Unterricht erweitert werden soll. \\
Dabei können zahlreiche Erweiterungen vorgenommen werden, wie unter anderem die 
Ausstattung mit Motoren an vier möglichen Gelenken und weitere mechanische 
Anpassungen. \\
\paragraph{Versuche}
\hfill \break
\hfill \break
Bei dieser finalen Entwicklungsstufe hat sich gezeigt, dass die Erkenntnisse der 
vorherigen Stufen zu einem nun stabilen und zuverlässigen Modell geführt haben. 
Die Versuchsergebnisse haben folgende Informationen geliefert: \\
\\
\begin{itemize}
	\item Die neue Mechanik ist äußerst präzise, sei es der Motorblock oder der 
	Faltmechanismus. Die Finger können äußerst akkurat auf eine gewünschte 
	Position gestellt werden.
	\item Der Griff, welcher durch die Fingerkuppen aus Silikon [siehe \textcolor{blue}{\autoref{fig:Handv2_real}}] geschaffen wird, 
	ermöglicht es passende Objekte fest zu greifen. Getestet wurde dies mit einer 
	250ml Flasche, einem Handschuh, einer menschlichen Hand und auch mit Werkzeug, 
	wie einem Schraubendreher. 
	\item Die Reibung konnte erheblich reduziert werden, besonders hilfreich waren 
	dabei noch zusätzlich gefräste Umlenkungen [siehe \textcolor{blue}{\autoref{fig:Handv2_real}}], welche die Zugschnur auch 
	ausrichten. 
\end{itemize}

\subsubsection{Fazit und Reflexion}
Die Entwicklung der Mechanik hatte viele Höhen und Tiefen, war jedoch äußerst 
lehrreich. Jede Entwicklungsstufe hat ihre Erkenntnisse mit sich gebracht, jedoch 
auch gezeigt, dass sich einige Probleme nicht eliminieren sondern ausschließlich 
minimieren lassen. Während des Prozesses der Entwicklung hat der Faltmechanismus 
einige Änderungen und Anpassungen erhalten, von der bloßen Verbindung mit 
Gummikordeln bis zu einer separaten Verbindung der Fingerglieder und einem 
Rückzug mit einer Zugfeder. Die letzte Entwicklungsstufe darf nun als Konzept 
betrachtet werden, welches alle positiven Eigenschaften der vorherigen Modelle 
vereint und daraus eine optimale Hand für unsere Anforderungen geschaffen hat. \\

\newpage
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\section{Hardware Realisierung  [\textcolor{blue}{Szabo}]}

\subsection{Eingabesubsystem}

\subsubsection{Grundlegende Voraussetzungen}
Die Hardware des Eingabesubsystems muss einige Kriterien erfüllen, um schlussendlich voll funktionfähig in das Gesamtsystem eingebaut 
werden zu können. Zunächst ist die Größe der Schaltung, als mit der wichtigste Punkt zu nennen. Da es bei diesem Projekt nicht nur
um die Funktionalität, sondern auch um ein ergonomisches Benutzererlebnis geht, sollte die entgültige Platine auf dem Handschuhrücken
nicht größer als 4cm x 4cm sein. Beim Design der Elektronik muss durch die Größenrestriktion natürlich darauf geachtet, dass durch
diese keine Einbußen in Bezug auf die korrekte und sichere Funktion des Projektteils entstehen. Übermäßige Wärmeentwicklung ist 
ebenfalls zu vermeiden, da diese auf lange Zeit unangenehm für den Endnutzer ist. Die Versorgung der Schaltung
sollte möglichst über einen kleinen und portablen Akku geschehen, um dem Benutzer das bestmögliche Erlebnis zu bereiten. Dieses Feature ist
allerdings optional und ist daher nicht garantiert zur Verwendung bereit. Über einen USB Anschluss soll der Mirkokontroller programmierbar sein und die Schaltung
auch für Test -und Wartungszwecke versorgt werden können. Das Maximalgewicht darf 500g nicht übersteigen. \\

\subsubsection{Überlegungen, Simulationen und Berechnungen}
\label{chap:Überlegungen, Simulationen und Berechnungen}
\paragraph{Bewegungserfassung der Fingerbeugung}
\hfill \break
\hfill \break
Die Bewegungen des Benutzers müssen gemessen werden können. Das bedeutet, dass eine Form von Messschaltung notwendig ist um die  
Beugung der Finger interpretieren zu können. Dies könnte man durch das Messen des Beugungswinkels realisieren. Allerdings hat 
jeder Finger drei Gelenke, wodurch man diese auch bei der Roboterhand individuell steuern müsste. Die zweite Möglichkeit wäre, 
durch eine visuelle Aufnahme die Bewegung des Handschuhs und dadurch des Benutzers aufzuzeichnen. Da dies allerdings nur in dafür vorgesehenen, 
mit Kameras ausgestatteten, Räumen funktionieren würde, ist dies für uns auch keine sinnvolle Möglichkeit. Schließlich haben 
wir uns für die Erfassung der Fingerbewegungen mittels Flexsensoren entschieden. Diese ändern den Widerstand je nach der 
aktuell vorherrschenden Beugung. Bei dieser Art der Bewegungserfassung muss man nicht jedes Fingergelenk einzeln steuern und 
braucht auch keine externen Kameras. Somit ist bei dieser Methode der Datenerfassung ein sehr flexibler Verwendungsbereich 
des Handschuhs gewährleistet. Um die Änderungen der Widerstandsstreifen messen und verarbeiten zu können ist nun eine Schaltung 
notwendig. Diese muss Wertdifferenzen erkennen und in ein geeignetes Format zur Weiterverarbeitung mit einem Mikrokontroller
umwandeln können. \\
\\
\paragraph{Auslesen der Sensoren}
\label{par:Auslesen der Sensoren}
\hfill \break
\hfill \break
Das Auslesen der Flexsensoren kann durch einen einfachen Spannungsteiler erfolgen. Dabei ist die Genauigkeit
allerdings nicht optimal und ist daher nicht für unsere Anwendung geeignet. Als Lösung für dieses Problem haben wir an eine 
OPV-Messschaltung gedacht. Diese soll mit einem Shuntwiderstand die Spannungsdifferenz messen, die sich bei einer Veränderung 
des flexiblen Widerstands ergibt. Durch eine geeignete Verstärkung des OPVs kann diese mit einer Referenzspannung verglichen 
werden. \\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.25}
		{\includegraphics[width=0.8 \linewidth]{Simulation_Spannungsmessung_Flexsensoren}}
		\caption{LTspice Simulation der Flexesnor - Messschaltung}
		\label{fig:Simulation_Spannungsmessung_Flexsensoren}		
	\end{center}
\end{figure}
\hfill \break
Die Flexsensoren (Rflex) beziehen ihre Versorgung über einen Shunt-Widerstand (Rs). Je nach Belastung, ändert sich der 
Spannungsabfall an diesem (Je größer die Beugung des Sensors, desto kleiner ist der Spannungsabfall). Die Spannungsdifferenz 
am Shunt-Widerstand wird von einem Operationsverstärker verstärkt. Bei der Auswahl des OPVs sind einige Punkte zu beachten, um 
eine korrerkte und genaue Erfassung der Fingerbeugung zu gewährleisten. \\
\\
Folgende Kriterien müssen folglich bei der Wahl des Operationsverstärkers beachtet werden:
\begin{itemize}
	\item Ausgangspegel bei gewählter Versorgungsspannung: \\
		  \\
		  Zunächst wurde das Kriterium der Versorgungsspannung betrachtet. Da wir maximal 5V Gleichspannung in der gesamten 
		  Schaltung verwenden wollen, muss der OPV mit dieser geringen Spannung immer noch verstärken. Da am positiven 
		  Verstärkereingang eine maximale Spannung von 3.3V anliegt, muss dies bei Verstärkern mit einer geeigneten Supply Range 
		  auch mit nur 5V Versorgungsspannung gewährleistet sein.
	\item Referenzspannung: \\
		  \\
		  Ein weiteres Kriterium ist das vorhanden sein eines Referenzspannungsanschlusses. Da der OPV keine Rail-to-Rail 
		  Technologie besitzt, muss der Ausgangsspannungspegel auf ein gewisses minimum angehoben werden. In unserem ist dies 
		  +1V. Würde diese Refernzspannung nicht vorhanden sein, so würde der OPV falsche Werte erzeugen, da dieser erst ab einer
		  verstärkten Spannung am Ausgang von ca. 750mV korrekt funktioniert.

\end{itemize}
Aufgrund dieser Kriterien und der Notwendigkeit von Genauigkeit und geringer Störungseigenschaften, viel die Wahl des 
Operationsverstärkers auf den INA129 instrumentation amplifier. \\
\\
Der Shunt-Widerstand wurde nicht berechnet. Dieser wurde einfach durch probieren inder Simulation bestimmt. \\
\\
Ein Tiefpassfilter (Rf und Cf) ist hinter den Ausgang des OPVs geschaltet, um mögliche Spannungsstörungen (Ripple), zusätzlich
zu dem ohnehin schon sehr störungsarmen Ausgangssignal des INA129, herauszufiltern. Der zu GND geschaltete Widerstand (R1), 
entlastet den Eingang des folgenden ADCs. Der Tiefpassfilter wurde folgendermaßen dimensioniert. \\
\\
\paragraph{Berechnung des Tiefpassfilters}
\hfill \break
\hfill \break
\hspace*{1cm} $f_{g} = 20 kHz $ \hspace*{1cm} $\tau = \frac{1}{\omega_{g}} = \frac{1}{2\pi * 20 kHz} $ \\
\\
\hspace*{1cm} $f_{g} = \frac{\omega_{g}}{2\pi} $ \hspace*{1.7cm} $\tau = R * C $ \\
\\
\hspace*{4.25cm} $ C = 68 nF $ \hspace*{1cm} $ R = \frac{\tau}{68nF} = 117 \Omega $ \\
\\
Der zum Kondensator parallel geschaltete Widerstand wurde bei der Berechnung des Filters nicht berücksichtigt,
da dieser die Grenzfrequenz bei der physischen Anwendung nur unmerkbar beeinflusst. Die Komplexität stünde mit der 
zusätzlich erzielten Genauigkeit in keiner Relation. \\
\paragraph{Berechnung der OPV Verstärkung und Dimensionierung des Shuntwiderstands}
\hfill \break
\hfill \break
\hspace*{1cm} Verstärkungsgleichung laut Datenblatt: $ G = 1+\frac{49.4k\Omega}{R_{g}} $ \\
\\
\hspace*{1cm} Gain gewählt mit 46. \hspace*{1cm} $ R_{g} = 1.1k\Omega $ \\
\\
Die Verstärkung wurde so gewählt, dass diese mit dem Shunt-Widerstand für den ADC optimal geeignet ist.
Der Shunt-Widerstand wurde mithilfe der Simulation in [\textcolor{blue}{\autoref{fig:Simulation_Spannungsmessung_Flexsensoren}}]
gewählt. \\
\\
Der Shuntwiderstand wurde nicht wirklich berechnet. Dieser wurde durch probieren in der Simulation ermittelt. Eine Berechnung
des Shunts wäre nicht wirklich Zielführend gewesen, da diese normalerweise bei Schaltungen mit hohen Strömen verwendet werden. 
Da sich die Flexsensoren allerdings in einem Widerstandsbereich von $25k\Omega$ - $125k\Omega$ befinden, benötigen diese nicht
viel Strom, wodurch schon zu erwarten war, dass ein relativ hoher Wert benötigt wird. Schlussendlich wurden $240\Omega$ gewählt,
da dieser Widerstand bei sowohl voller, als auch geringer Biegung der Flexsensoren, eine gute Spannungsdifferenz für die 
Verstärkung mit dem OPV liefert. \\
\\
\paragraph{Umwandlung der Differenzwerte in ein geeignetes Format}
\label{par:Umwandlung der Differenzwerte in ein geeignetes Format}
\hfill \break
\hfill \break
Um nun die analogen Ausgangswerte des Operationsverstärkers nach der Verstärkung der Spannungsdifferenzen am Flexsensor für
den Mikrokontroller möglichst effizient und brauchbar zu machen, ist eine Umwandlung in ein digitales Signal notwendig.
Dies Funktion wird mit mit einem ADC umgesetzt. Bei der Wahl dieses Logikbauteils, sind, wie beim OPV, einige Kriterien zu 
beachten um die korrekte Funktion der Schaltung weiterhin zu gewährleisten. \\
\\
Folgende drei Kriterien sind maßgeblich bei der Wahl der Analog-Digital-Wandlers zu beachten:
\begin{itemize}
	\item Genauigkeit, Auflösungund Aussteuerbereich: \\
		  \\
		  \hspace*{1cm} $ Aussteuerbereich = 0 - 3.3V $ \\
		  \\
		  \hspace*{1cm} bei 10Bit ADC: $ LSB = 3.22mV $ \\
		  \\
		  \hspace*{1cm} Wegen der 1V Referenzspannung des OPVs ist der Ausgangspegel 1V - 3.3V \\
		  \\
		  \hspace*{1cm} $ ADC Ausgangsstufen = \frac{2.3V}{3.22mV} = 713 $ \\
\end{itemize}
Der reale Ausgangspegel des OPVs liegt, wie bei der Simulation in [\textcolor{blue}{\autoref{par:Auslesen der Sensoren}}] ermittelt, zwischen 1.277V bis 2.416V.
Das beudeutet, dass eine Auflösung von 10Bit und ein Austeuerbereich von 0V - 3.3V ausreichend ist, um den kompletten Wertebereich
sehr genau abzudecken. Zusätzlich haben wir uns noch dazu entschieden alle Logikbauteile die eine Kommunikation mit dem Mikrokontroller
erfordern mit dem I2C Bussystem anzuschließen. Daher muss der Analog-Digital-Wandler diese Art der Kommunikation ebenfalls unterstützen.
Aufgrund dieser Auswahlkriterien ist die Wahl des Bauteils auf den MAX11611 gefallen.\\
\\
\paragraph{Vervielfachung der Schaltung für alle Flexsensoren}
\hfill \break
\hfill \break
Um die zuvor beschriebene Schaltung nun nicht für jeden Flexsensor einzeln bauen zu müssen, wäre eine Art Schalter vorteilhaft.
Dieser soll in Sekundenbruchteilen zwischen allen Sensoren durchschalten. Das bedeutet also, dass zwischen dem Shunt-Widerstand
und $R_{flex}$ in der Simulation dieses Bauteil platziert werden muss. \\
\\
Für diesen Zweck ist ein Multiplexer bestens geeignet. Folgende Kriterien muss dieser erfüllen.
\begin{itemize}
	\item Versorgung und Kanäle: \\
		  \\ 
		  Die Versorgung muss an den Rest der Schaltung angepasst sein, das bedeutet, dass entweder 3.3V oder 5V in Frage kommen.
		  Bei einer Anzahl von einem Flexsensor pro Finger, also fünf, muss der Multiplexer mindestens 5 Kanäle aufweisen, wobei 
		  mehr Kanäle für mögliche zukünftige Erweiterungen kein Problem sind. All diese Eingänge müssen auf einen Ausgang geschalten
		  werden.
	\item Ansteuerung: \\
		  \\ 
		  Die Ansteuerung muss mit einem Mikrokontroller möglich sein. Hier bleibt also die Wahl zwischen analogen und digitalen 
		  Anschlüssen, oder ein I2C Anschluss um mit dem Rest der Schaltung kompatibel zu bleiben.
\end{itemize}
Folglich viel die Wahl auf den MUX508IDR. Dieser ist ein 8:1 Channel Multiplexer, der über 5V versorgt werden kann und über drei 
Analoganschlüsse für die Auswahl des Kanals verfügt. \\
\\
Bei der Umschaltdauer wird die volle Schnelligkeit des Chips verwendet, um eine minimale Verzögerung von der Bewegung des Sensors zur Bewegung 
der Roboterhand zu gewährleisten. Die Umschaltzeit von Kanal zu Kanal beträtg ca. 100ns.
\\
\paragraph{Bewegungserfassung der Handgelenksdrehung}
\hfill \break
\hfill \break
Um die Drehung des Handgelenks zu erfassen ist ein anderer Sensor als ein Flexsensor notwendig. Dieser neue Sensor muss die 
Funktion eines Gyroskops haben und folglich die Positionen von X, Y -und Z-Achse übermitteln. Dieser Übermittlung muss per
I2C-Bus erfolgen, um die Kompatiblität mit der restlichen Schaltung zu ermöglichen. \\
\\
Ausgewählt wurder der Sensor MPU-6000, da dieser schon eingebaute ADCs hat, um die Achswerte vor der Übertragung zu digitalisieren. \\
\\
Wichtig zu beachten ist allerdings, dass dieser Sensor nur in Hardware auf der Platine integriert wurde und 
die Softwareansteuerung noch nicht vorhanden ist. Diese müsste im Zuge möglicher Erweiterungen [siehe \textcolor{blue}{\autoref{chap:Ausblick}}]
programmiert werden. \\
\\
\paragraph{Mikrokontroller}
\label{par:Mikrokontroller}
\hfill \break
\hfill \break
Bei der Auswahl des Mikrokontrollers wurden sehr viele Aspekte beachtet. Dieser ist das Herzstück der Schaltung und ermöglicht
allen Komponenten zusammen zu funktionieren und diese auch zu steuern. \\
\\
Folgende Kriterien müssen vonn dem verwendeten Mikrokontroller folglich erfüllt werden:
\begin{itemize}
	\item Performancerelevante Ressourcen: \\
		  \\
		  Zu beachten ist hierbei vor allem der vorhandene Flash-Speicher, die CPU und der On-Chip Memory. Hierbei gilt grundsätzlich 
		  natürlich je mehr, desto besser. Das gleiche gilt ebenfalls für den Flash-Speicher.
	\item Versorgung und Anschlüsse: \\
		  \\
		  Um mit der Schaltung kompatibel zu sein, muss der Mikrokontroller mit 3.3V oder 5V versorgt werden können. Zusätzlich
		  sollte der Chip möglichst wenig Leistung brauchen. Es sollten mindestens zehn I/O-Anschlüsse vorhanden sein.
	\item Unterstützte Bussysteme: \\
		  \\
		  Da die wir bei der Schaltung eunheitlich auf das I2C Bussystem setzen, muss zumindest dieses von dem gewählten Mikrokontroller
		  unterstützzt werden. Als zweite Pflichtunterstützung gilt die UART-Kommunikation. Die Funktion und Notwendigkeit dieser,
		  wird in [\textcolor{blue}{\autoref{par:Externe Anschlüsse}}] erläutert.
	\item Möglichkeiten der drahtlosen Übertragung: \\
		  \\
		  Da die Flexsensorwerte drahtlos Übertragen werden müssen, muss der Mikrokontroller eine Form dieser Übertragung unterstützen.
		  Vorzüglicherweise ist die Antenne für die Übertragung schon vorhanden, damit weitere Schaltungsteile nicht notwendig sind.
		  Hier kämen zum Beispiel Bluetooth oder Wifi in Frage.
	\item Programmierbarkeit: \\
		  \\
		  Der Chip muss mit einer schon verfügbaren Entwicklungsumgebung programmierbar sein. Wichtig ist in diesem Bezug vor allem
		  die Debugmöglichkeit, da bei einigen Mikrokontrollern ein extra Debugtool um viel Geld erworben werden muss. Eine Programmierung
		  im Terminal kommt ebenfalls nicht in Frage.
	\item Größe und Formfaktor: \\
		  \\
		  Schlussendlich dürfen sich alle Kriterien jedoch nicht zu sehr auf die Größe des Mikrokontrollers auswirken. Diese sollte
		  natürlich so klein wie möglich sein und trotzdem Bauteile wie eine Antenne aufweisen.
\end{itemize}
Nach beachtung aller Kriterien haben wir uns für einen ESP32 Mikrokontroller entschieden. Hierbei blieb allerdings die Wahl zwischen
dem reinen Chip und dem Modul, bei dem die Antenne und andere Funktionalitäten, die andernfalls selbst gebaut werden müssten,
schon integriert sind. Nach Abwägungen von Größe und Performance, haben wir uns für das ESP32-WROOM-32E-N16 Modul entschieden.
Dieses hat eine integrierte Antenne, reichlich Performance und viel Flash-Speicher. Der Formfaktor ist bei allen diesen 
Funktionalitäten immer noch im Rahmen. \\
\\

\subsubsection{Versuchsaufbauten und Messungen}
In den folgenden Punkten, werden die praktischen Tests der, in [\textcolor{blue}{\autoref{chap:Überlegungen, Simulationen und Berechnungen}}] beschriebenen Konzepte und Überlegungen, erläutert.\\
\paragraph{Messchaltung der Flexsensoren}
\hfill \break
\hfill \break
Zunächst wurde die Schaltung aus [\textcolor{blue}{\autoref{par:Auslesen der Sensoren}}] auf einem Steckbrett aufgebaut. Das Ziel der Messung ist es, den Widerstand 
bei jeder Stellung eines Flexsensoren zu wissen. Dies ist wichtig, um die Daten der Sensoren korrekt auszulesen und an die 
Roboterhand zu senden. Werden die Widerstandswerte nicht korrekt gemessen, so bewegt sich die Roboterhand nicht entsprechend 
nach den Bewegungen des Benutzers. \\
\\
Die zu messende Größe ist die Ausgangsspannung des OPVs, die sich je nach Widerstand der Last verändert. Die Last wird in 
unserem Versuchsaufbau von drei Widerständen simuliert, da wir die Flexsensoren zu dem Zeitpunkt der Messung noch nicht zu 
Verfügung hatten. Wir haben die Lastwiderstände mit $27k\Omega$, $68k\Omega$ und $118k\Omega$ gewählt, da der Widerstandsbereich der Sensoren bei 
$25k\Omega$ – $125k\Omega$ liegt. In [\textcolor{blue}{\autoref{par:Messergebnisse}}] werden die Messergebnisse dargestellt. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Steckbrettaufbau_Spannungsmessung_INA129}}
		\caption{Steckbrettaufbau der Flexesnor - Messschaltung}
		\label{fig:Steckbrettaufbau_Spannungsmessung_INA129}	
	\end{center}
\end{figure}
\hfill \break
\hfill \break
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Bild_Einstellungen_Netzteil}}
		\caption{Netzteileinstellungen}
		\label{fig:Bild_Einstellungen_Netzteil}	
	\end{center}
\end{figure}
\hfill \break
+3.3V für die Versorgung des Flexsensors (Last), simuliert mit drei normalen Widerständen.\\
+1V als Referenzspannung für den INA-129.\\
+5V zur Versorgung des INA-129.\\
\\

\paragraph{Messergebnisse}
\label{par:Messergebnisse}
\hfill \break
\hfill \break
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Oszibild_RL_27k}}
		\caption{Oszilloskopbild mit $R_{L} = 27k\Omega$}
		\label{fig:Oszibild_RL_27k}		
	\end{center}
\end{figure}
\hfill \break
Das obige Oszilloskopbild zeigt die, mit einem Tastkopf, gemessene Ausgangsspannung des Operationsverstärkers, bei einem Flexsensorwiderstand
von $27k\Omega$. Die gemessene Spannung ist rot eingekreist und beträgt 2.28V. Da bei der Simulation in LTspice mit einem Widerstand 
von $25k\Omega$ eine Ausgangsspannung von 2.416V resultierte, ist anzunehmen, dass 2.28V 
für den gewählten Widerstand angemessen sind. Daraus kann man schließen, dass die Schaltung
für diesen Widerstandswert des Flexsensors korrekt funktioniert.
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Oszibild_RL_67k}}
		\caption{Oszilloskopbild mit $R_{L} = 67k\Omega$}
		\label{fig:Oszibild_RL_67k}		
	\end{center}
\end{figure}
\hfill \break
Nun wurde die gleiche Messung erneut durchgeführt, allerdings mit einem Flexsensorwiderstand
von $67k\Omega$. Wir zu erwarten, ist die Ausgangsspannung des OPVs gesunken, da der 
Spannungsabfall am Shuntwiderstand nun geringer ausfällt. Zu erwarten war ein Spannungswert
von rund 1.5V. Dieser Pegel wurde mit 1.52V fast genau getroffen, wodurch die funktionsfähigkeit
der Schaltung weiter sichergestellt wurde.
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Oszibild_RL_118k}}
		\caption{Oszilloskopbild mit $R_{L} = 118k\Omega$}
		\label{fig:Oszibild_RL_118k}		
	\end{center}
\end{figure}
\hfill \break
Schlussendlich wurde noch ein Flexsensorwiderstand von $118k\Omega$ simuliert, um den
nahezu Maximalwert des Sensors zu simulieren. Zu erwarten waren rund 1.3V. Die Messung
bestätigt die Überlegungen, wodurch die Funktionalität dieser Schaltungskomponente bewiesen
wurde. \\
\\
Zusätzlich ist nun die Notwendigkeit einer Referenzspannung von +1V bewiesen worden, da
ohne dieser ein theoretischer Spannungspegel von nur 500mV am Ausgang des INA-129 aufgetreten
wäre.  Dies ist praktisch allerdings nicht möglich, da der OPV über keine Rail-to-Rail
Technologie verfügt, wodurch er nur eine minimale Ausgangsspannung von rund 800mV ausgeben 
kann.
\\

\newpage
\subsubsection{Schaltungsdesign}
Nach den generellen Überlegungen und Versuchsaufbauten, die zu der Entwicklung der Schaltung des Eingabesubsystems beigetragen haben, wird in diesem Punkt 
das genaue Schaltungsdesign erläutert. \\
\\
\paragraph{Externe Anschlüsse}
\label{par:Externe Anschlüsse}
\hfill \break
\hfill \break
\begin{itemize}
	\item Anschluss zur Programmierung des Mikrokontrollers: \\
		  \\
		  Für die Programmierung des Mikrokontrollers wird ein USB Anschluss benötigt. Dieser sollte möglichst kompatibel mit
		  den neuesten Computern sein, weswegen wir uns für USB-C-Typ2.0 entschieden haben. Um das Serial Signal der USB Schnittstelle
		  für den Mikrokontroller lesbar zu machen, muss dieses für die UART-Kommunikation umgewandelt werden. Hierzu muss der Mikrokontroller
		  diese auch unterstützen. Mit einer Serial-UART-Bridge, wird das Signal umgewandelt. Der Chip wird von +3.3V versorgt.
		  Von der USB-Buchse werden die beiden Datenleitungen D+ und D- mit verbunden. Anschließend wird das umgewandelte Signal 
		  über die UART-Leitungen an den ESP32 Mikrokontroller übertragen. Wichtig zu beachten ist hierbei, dass die UART-Leitungen
		  ausgekreuzt sein müssen. Die Funktion der Anschlüsse RTS und DTR wird in [\textcolor{blue}{\autoref{par:Mikrokontroller}}] erläutert. \\
		  \begin{figure}[H]
			\begin{center}
				\scalebox{0.5}
				{\includegraphics[width=0.8 \linewidth]{USB_C_Schaltplan_Handschuh}}
				\caption{USB-C-Buchse}
				\label{fig:USB_C_Schaltplan_Handschuh}				
			\end{center}
		\end{figure}
 GitHub\end{itemize}

\paragraph{Mikrokontroller} 
\hfill \break
\hfill \break
Der ESP32-Chip wird mit +3.3V versorgt. Wichtig zu beachten ist dadurch, das ein Logic-HIGH somit auch 3.3V und nicht 5V ist!
Die Versorgung wird mit einem Kondensator stabilisiert. Für alle Busleitungen, also I2C und UART, wurden Widerstände in Serie
hinzugefügt, um die Kommunikationsleitungen vor Spannungsspitzen oder Überspannung zu schützen. Die Funktion wäre auch ohne diese
gegeben. Für die Datenleitungen SDA und SCL des $I^{2}C$ Busses sind zwei $10k\Omega$ PullUp-Widerstände vorgesehen. Zusätzlich 
wird ebenfalls der Anschluss IO16 mit einem PullUp-Widerstand auf 3.3V gezogen, da dies so vom Datenblatt vorgegeben wird. 
Die Funktionen der einzelnen Anschlüsse werden in den folgenden Punkten gemeinsam mit den damit verbundenen Bauteilen näher erläutert. \\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{ESP32_Schaltplan_Handschuh}}
		\caption{ESP32 Mikrokontroller}
		\label{fig:ESP32_Schaltplan_Handschuh}	
	\end{center}
\end{figure}

\paragraph{Mikrokontroller Buttons}
\label{par:Mikrokontroller Buttons}
\hfill \break
\hfill \break
In der Schaltung sind drei Taster verbaut. Diese sind alle mit dem Mikrokontroller verbunden und erfüllen verschiedene Funktionen.
\begin{itemize}
	\item Upload Button: \\
		  \\ 
		  Dieser Button ist mit dem IO0 Anschluss des ESP32 verbunden und muss bei dem Hochladen von Code kurzzeitig gedrückt 
		  werden, um den Mikrokontroller in den Upload-Modus zu versetzen. Der Pin IO0 ist standardmäßig für diese Funktion vorgesehen
		  und sollte für nichts anderes verwendet werden. 
	\item Reset Button: \\
		  \\
		  Dieser Button ist mit dem EN (Enable) Anschluss des ESP32 verbunden. Die Funktion dieses Tasters ist es, den ESP32 jederzeit 
		  zurücksetzen zu können falls dieser abstürtzt oder ein anderweitiges Problem auftritt, durch das dieser nicht mehr korrekt
		  funktioniert.
	\item Progrmmable Button: \\
		  \\
		  Die Funktion dieses Buttons kann frei durch den programmierten Code gewählt werden. 
\end{itemize}

\paragraph{Status LEDs}
\hfill \break
\hfill \break
Die beiden Leuchtdioden sind als Statusanzeige gedacht. Eine POWER LED, die immer leuchtet wenn die Schaltung mit +5V
versorgt wird. Die Funktion der anderen LED ist, sowie bei einem Button, frei wählbar und ist deswegen mit Pin IO13 des ESP32
verbunden. \\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{LEDs_Schaltplan_Handschuh}}
		\caption{Status LEDs}
		\label{fig:LEDs_Schaltplan_Handschuh}		
	\end{center}
\end{figure}

\paragraph{Multiplexer}
\hfill \break
\hfill \break
Der Multiplexer schaltet zwischen allen Flexsensoren durch und vermeidet somit die Messschaltung fünf mal bauen zu müssen. 
Die Verbindung zum ESP32 erfolgt über drei digitale Addresspins und einen Enable Pin. Je nachdem welche Bitkombination übermittelt
wird, ändert sich die interne Schalterposition und somit der gerade aktive Kanal zur Messung eines Flexsensors. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{Multiplexer_Schaltplan_Handschuh}}
		\caption{Multiplexer}
		\label{fig:Multiplexer_Schaltplan_Handschuh}		
	\end{center}
\end{figure}

\paragraph{Operationsverstärker}
\hfill \break
\hfill \break
Für das Auslesen der Flexsensoren, wird eine Schaltung, wie in [\textcolor{blue}{\autoref{par:Auslesen der Sensoren}}] beschrieben, benötigt. Da am
Shuntwiderstand nur sehr wenig Spannungsabfall auftritt und daher die Spannungsdifferenz zwischen positivem und negativem 
Verstärkereingang sehr klein ist, muss das Signal verstärkt werden. Hierfür wird der INA129 Instrumentenverstärker verwendet.
Dieser wird mit 5V versorgt, was für einen OPV eine relativ geringe Versorgungsspannung ist. Da die maximale Eingangsspannung
der Verstärkereingänge allerdings nie mehr als 3.3V beträgt, ist dies kein Problem. \\
\\
Die +1V Spannungsreferenz ist notwendig, da der ausgewählte Operationsverstärker nicht über Rail-to-Rail Technologie besitzt. 
Die kleinstmögliche Spannungsdifferenz am Eingang des OPV, wenn der Flexsensor seinen maximalen Widerstand von
$125k\Omega$ erreicht, beträgt nur 6.3mV. Aufgrund der fehlenden Rail-to-Rail Fähigkeit, muss die Ausgangsspannung des OPV deshalb
auf mindestens 800mV angehoben werden, um eine korrekte Funktion des OPVs zu gewährleisten. Deshalb wird eine Referenzspannung
von 1V verwendet. \\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{Operationsverstärker_Schaltplan_Handschuh}}
		\caption{Operationsverstärker - Schaltung}
		\label{fig:Operationsverstärker_Schaltplan_Handschuh}		
	\end{center}
\end{figure}

\paragraph{Analog-Digital-Wandler}
\hfill \break
\hfill \break
Der Analog-Digital-Wandler ist dafür zuständig, die analogen Werte, vom Ausgang des Operationsverstärkers kommend, in digitale 
Signale umzuwandeln. Der OPV und der ADC sind über das Label toADC verbunden. Da der Chip über 3.3V versorgt wird, befindet
sich der mögliche Aussteuerbereich zwischen 0V und 3.3V. Wie im [\textcolor{blue}{\autoref{par:Umwandlung der Differenzwerte in ein geeignetes Format}}] berechnet, 
hat der ADC in unserer Schaltung ein LSB von 3.22mV. Da wir wissen, dass die kleinste Spannungsdifferenz am Shuntwiderstand 6.3mV
ist und diese auch noch mit dem Faktor 46 verstärkt wird, kann festgestellt werden, dass der ADC mehr als genau genug für unsere
Anwendung ist. Dies ist ein Vorteil, da bei der Programmierung anschließend nicht zwischen einzelnen ADC-Stufen unterschieden werden
muss, sondern immer mehrere LSBs Unterschied auftritt. Die aktualisierten Werte, werden über die beiden $I^{2}C$ Leitungen an den 
Mikrokontroller übertragen. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{ADC_Schaltplan_Handschuh}}
		\caption{ADC - Schaltung}
		\label{fig:ADC_Schaltplan_Handschuh}	
	\end{center}
\end{figure}

\paragraph{Gyroskop-Sensor}
\hfill \break
\hfill \break
Der Gyroskopsensor ist dafür zuständig die Drehung des Handschuhs in X, Y -und Z Richtung warzunehmen. Die Versorgung basiert 
auf 3.3V und die Datenübertragung erneut mittels I2C-Bussystem. Der Unterschied bei diesem Chip ist allerdings, dass mehrere ADCs
integriert sind, um die Positionsdaten der Achsen schon digitalisiert an den Mikrokontroller zu übergeben. AD0 wird dabei verwendet
um die Adresse des Mikrochips festzulegen. Diese wird später benötigt um mit dem Sensor Daten austauschen zu können.
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{Gyro_Schaltplan_Handschuh}}
		\caption{Gyroskopsensor - Schaltung}
		\label{fig:Gyro_Schaltplan_Handschuh}		
	\end{center}
\end{figure}
\hfill \break
Am Pin CLKIN hätte man die Möglichkeit einen externen Referenztaktgeber anzuschließen. Bei unserer Anwendung ist der integrierte 
Taktgeber allerdings völlig ausreichend, weswegen der Anschluss mit GND verbunden und damit deaktiviert wurde. Der CS Pin wird nur
für die SPI Kommunikation benötigt, weshalb dieser ebenfalls deaktiviert wurde. Das gleiche gilt für den Anschluss FSYNC. Die beiden
AUX-Anschlüsse könnte man verwenden, um mit anderen $I^{2}C$ fähigen Sensoren direkt zu kommunizieren. Da dies allerdings unser einziger
Sensorchip mit dieser Fähigkeit ist, bleiben die beiden Pins auch nicht verbunden. Die Kondensatoren sind vom Hersteller im Datenblatt
vorgesehen und gewährleisten einen stabilen Betrieb. \\
\\

\subsubsection{Platinendesign}
\paragraph{Erste Testplatine}
\hfill \break
\hfill \break
Die erste Testplatine wurde in der schuleigenen Werkstatt, mithilfe einer Platinenfräse,
gefertigt. Da das Design auch zu dem frühen Zeitpunkt des Projekts schon relativ kompliziert
war, gab es bei der Fertigung einige Probleme. Aufgrund schon vorhandener Erfahrung,
wurden die Bauteile mit möglichst großem Fottprint (1206) gewählt, um ein einfaches Löten
per Hand zu ermöglichen. Da es ICs aber leider nur in einer, für das Bauteil festgelegten,
Größe zu kaufen gibt, mussten Leiterbahnen mit einer Breite von nur 0.3mm verwendet
werden. Dies führte beim Löten leider zum Ablösen dieser, weshalb einige Jumper-Kabel
notwendig waren, um die kaputten Leiterbahnen zu ersetzen. Die Installation dieser Ersatzkabel,
hat einige Zeit in Anspruch genommen, wodurch der Entwicklungsprozess der Hardware
kurzzeitig verzögert wurde. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{Platine_Handschuh_oben_v1}}
		\caption{Platinenoberseite - erste Testplatine - Eingabesubsystem}
		\label{fig:Platine_Handschuh_oben_v1}		
	\end{center}
\end{figure}
\hfill \break
Zu sehen ist die Oberseite der ersten Testplatine des Eingabesubsystems. In der oberen linken Ecke des Bilds, sind die Anschlüsse für die 5 Flexsensoren zu sehen. Diese werden für Testzwecke mit 
Jumper-Kabeln verbunden, um ein schnelles Auswechseln der Sensoren und einsetzen von fixen Referenzwidersänden zu ermöglichen. Bei der Fertigung der Platne sind einige Leiterbahnen sehr dünn ausgefallen, 
weshalb einige Kabel zur erneuten Verbindung von Lötpads gebraucht wurden. Zu dem frühen Entwicklungszeitpunkt, wurde noch eine Micro-USB-Buchse verwendet, da diese größere Pins hat und das Löten somit erleichtert. \\
\\

\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{Platine_Handschuh_unten_v1}}
		\caption{Platinenunterseite - erste Testplatine - Eingabesubsystem}
		\label{fig:Platine_Handschuh_unten_v1}	
	\end{center}
\end{figure}
\hfill \break
An der Unterseite, kann der Grund für die Fehler in der Fertigung erkannt werden. Da die verwendeten ICs mit einer maximalen Leiterbahnbreite von 0.3mm verbunden werden müssen, kam es, vor allem bei der Serial-UART-Bridge in der
oberen linken Ecke des Bilds, zu Leiterbahnablösungen. Das blaue und rote Kabel stellt die Versorgung der Platine dar. 

\paragraph{Zweite Version der Platine}
\hfill \break
\hfill \break
Bei dem Design der zweiten Platinenversion, wurden schon einige Anforderungen für die Integration in das Gesamtsystem
berücksichtigt. Zu nennen sind hier beispielsweise die Abmessungen, die Konnektivität und die visuelle Darstellung 
von Parametern für den Benutzer. 

\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{Platinenlayout_Handschuh_oben_v2}}
		\caption{Toplayer des zweiten Platinenlayouts}
		\label{fig:Platinenlayout_Handschuh_oben_v2}		
	\end{center}
\end{figure}
\hfill \break
In [\textcolor{blue}{\autoref{fig:Platinenlayout_Handschuh_oben_v2}}], ist der Toplayer des zweiten Platinenlayouts in KiCad [siehe \textcolor{blue}{\autoref{chap:KiCad}}] zu sehen.
Der Großteil des Platzes wird vom Mikrokontroller, dem ESP32, eingenommen. An diesen sind alle anderen Komponenten angeschlossen. Wie in 
[\textcolor{blue}{\autoref{par:Mikrokontroller Buttons}}] erläutert, sind zwei Buttons zur Steuerung des ESPs vorgesehen. Mit einem $R$ ist der Reset-Button markiert
mit einem $B$ der Upload-Button. \\
\\
In der linken oberen Ecke der [\textcolor{blue}{\autoref{fig:Platinenlayout_Handschuh_oben_v2}}], sind die Anschlüsse für die Flexsensorem zu sehen. Recths daneben
ist die USB-C-Buchse platziert. Außer den genannten Bauteilen, sind nur mehr die beiden Leuchtdioden, zur Visualisierung für den Benutzer, auf dem 
Toplayer angebracht. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{Platinenlayout_Handschuh_unten_v2}}
		\caption{Bottomlayer des zweiten Platinenlayouts}
		\label{fig:Platinenlayout_Handschuh_unten_v2}		
	\end{center}
\end{figure}
\hfill \break
In [\textcolor{blue}{\autoref{fig:Platinenlayout_Handschuh_unten_v2}}], ist der Bottomlayer der zweiten Platinenversion zu sehen. Hier sind alle Elemente der Messchaltung
[siehe \textcolor{blue}{\autoref{par:Auslesen der Sensoren}}] verbaut. Dies beinhaltet den Multiplexer, Operationsverstärker, ADC, Gyroskopsensor, Spannungswandler
und die Serial-UART Bridge. Alle Bauteile wurden möglichst Platzsparend platziert, damit die Dimensionen der Platine gering gehalten werden können.
Die Abmessungen betragen ca. 3.5cm x 3.5cm. \\
\\
Alle Leiterbahnen wurden so breit wie möglich gemacht, um mögliche Defekte ausschließen zu können. Dies gilt für die Fertigung, als auch für mechanische
Abnützungen bei der Verwendung. \\
\\
Der größte Fehler bei diesem Platinendesign ist, dass in der Zone des Funkmoduls vom Mikrokontroller, Leiterbahnen und Bauteile platziert wurden.
Dies beeinträchtigt die Übertragung allerdings nur teilweise, indem diese nur mehr bis zu 10 Meter weit funktioniert. Dies ist allerdings zum Testen
kein Problem und wird beim nächsten Platinenlayout behoben. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{Platinenmodell_Handschuh_oben_v2}}
		\caption{Topside des zweiten Platinenmodells}
		\label{fig:Platinenmodell_Handschuh_oben_v2}		
	\end{center}
\end{figure}
\hfill \break
In [\textcolor{blue}{\autoref{fig:Platinenmodell_Handschuh_oben_v2}}], ist die bestückte Oberseite des zweiten Platinenmodells des Eingabesubsystems zu sehen. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{Platinenmodell_Handschuh_unten_v2}}
		\caption{Bottomside des zweiten Platinenmodells}
		\label{fig:Platinenmodell_Handschuh_unten_v2}		
	\end{center}
\end{figure}
\hfill \break
In [\textcolor{blue}{\autoref{fig:Platinenmodell_Handschuh_unten_v2}}], ist die bestückte Unterseite des zweiten Platinenmodells des Eingabesubsystems zu sehen. Diese wurde von JLCPCB bestückt. \\
\\

\newpage
\subsection{Roboterhand}

\subsubsection{Grundlegende Voraussetzungen}
Die Roboterhand ist die Ausgabe des Gesamtsystems und wird vom Eingabesubsystem gesteuert. Jeder Finger wird von einem Motor 
bewegt. Die ankommenden Daten müssen interpretiert und anschließend in ein geeignetes Format zur Ansteuerung der Motoren
umgewandelt werden. Zusätzlich zu dieser grundlegenden Funktionalität der Ansteuerung, müssen auch noch einige weitere Aspekte
beachtet werden. Hier sind zum Beispiel die möglichst geringe Größe der Schaltung und die trotzdem ausgiebigen Funktionen 
zu nennen. Dazu zählen visuelle Indikatoren für diverse Parameter, Schalter und Taster, Anschlüsse und Erweiterungsmöglichkeiten.
Die detailierten Entwicklungs -und Designschritte, werden in den folgenden Punkten näher erläutert. \\

\subsubsection{Überlegungen, Simulationen und Berechnungen}
\paragraph{Aktorik zur Fingerbewegung}
\hfill \break
\hfill \break
Bei der Aktorik zur Bewegung der Roboterfinger, gibt es, wie bei Sensorik zur Erfassung der Bewegungen, ebenfalls unzählige Methoden
und Konzepte zur Auswahl. Bei schon etablierten Herstellern von bionischen Händen werden fast ausschließlich lineare DC Motoren 
verwendet. Diese sind sehr hochpräzise, sehr gut gefertigt und haben für ihre Größe sehr viel Kraft. Nachteile sind allerdings
die hohen Preiseund die vergleichweise kompliziertere Ansteuerung. Außerdem sollten diese Motoren in präzise gefertigten Produkten
Anwendung finden, die möglichst wenig Reibung aufweisen und gelagerte Gelenke haben. Da wir in der Schule die Möglichkeit zur Fertigung 
eines solchen Produkts nicht haben und dies ebenfalls zu teuer wäre, haben wir uns entschieden diese Art der Aktorik, obwohl es die beste Wahl wäre,
nicht zu verwenden. Stattdessen haben wir uns für die Verwendung von Servo Motoren entschieden, die wesentlich billiger und einfacher anzusteuern sind und trotzdem mehr als
genügend Kraft haben. Der Nachteil bei diesen Motoren ist allerdings die Größe, wodurch unser Endprodukt ziemlich sicher etwas größer als gehofft
ausfallen wird. \\

\paragraph{Datenempfang}
\hfill \break
\hfill \break
Um den Datentransfer möglichst einfach zu gestallten und keine Kompatibilitätsprobleme zu haben, entschieden wir uns den gleichen Mikrokontroller
wie beim Eingabesubsystem zu verwenden. Dies ermöglicht eine relativ einfache Datenübertragung ohne zusätzliche Antennen. Werden Daten empfangen,
so wird die Software am Chip aktiv, die in [\textcolor{blue}{\autoref{chap:Realisierung: Überblick}}] näher beschrieben wird. Der
Entschluss zur Verwendung dieser \textquote{identischen} Systeme, wurde relativ rasch getroffen, da wir genug andere Schwierigkeiten haben werden und 
die Funkübertragung nicht dazu zählen soll. Genauere Designanforderungen, zum Layout der integrierten Antenne, werden in [\textcolor{blue}{\autoref{chap:Platinendesign Roboterhand}}] erklärt.

\paragraph{Ansteuerung der Motoren}
\label{par:Ansteuerung der Motoren}
\hfill \break
\hfill \break
Nachdem die Daten in Software verarbeitet wurden, müssen nun die Servomotoren angesteuert werden. Da diese über ein PWM-Signal [siehe \textcolor{blue}{\autoref{chap:PWM-Signale}}]
angesteuert werden, stellt sich die Frage ob man dies direkt über den Mikrokontroller realisiert, oder mithilfe einer PWM-Controller-Schaltung.
Da wir eine Mindestanzahl von fünf Servomotoren haben und auch für zukünftige Erweiterungen bereit sein möchten, haben wir uns für die Ansteuerung
via Servo-Controller entschieden. \\
\\
Bei der Ansteuerung der Motoren ohne Controller, ist das Problemm, dass für jeden Servomotor ein eigener Pin des Mikrokontrollers benötigt wird.
Dies ist nicht gerade Vorteilhaft, weil dadurch zwangsweise andere Funktionen des Mikrokontrollers, die nur mit bestimmten Pins funktionsfähig sind,
außer Kraft gesetzt werden. Um dieses Problem zu vermeiden verwenden wir einen PWM-Controller-Chip, dessen Auswahl im folgenden Punkt näher erläutert wird. \\
\\
\textbf{PWM-Controller-Chip}
\\
Bei der Auswahl des Mirkochips war die Ansteueurngsmöglichkeit das größte Auswahlkriterium. Da wir bei der Schaltung des Eingabesubsystems
auf die I2C-Kommunikation setzen, wollten wir dem treu bleiben und haben das gleiche bei dem gesamten Schaltungsdesign des Ausgabesubsystems
ebenfalls beachtet. Das bedeutet, dass nur Mikrochips in Frage kommen, die diese Art des Übertagungsprotokolls unterstützen. Als nächstes
ist die Anzahl der PWM Ausgangskanäle zu beachten und wie diese und der Baustein selbst adressiert werden können. Ebenfalls zu beachten war,
dass der Chip mit 5V Versorgungsspannung zurecht kommen muss. \\
\\
Die Wahl viel schlussendlich auf den PCA9685, welcher 16 PWM-Kanäle hat und über alle anderen, soeben beschriebenen, Anforderungen verfügt.
Durch die hohe Anzahl von Signal-Ausgängen bleiben wir ebenfalls für zukünftige Erweiterungen kompatibel. \\
\\

\paragraph{Positions -und Kraftmessung der Roboterfinger}
\label{par:Positions -und Kraftmessung der Roboterfinger}
\hfill \break
\hfill \break
Da mit der Roboterhand Objekte gegreift werden sollen, ohne diese zu beschädigen oder zu zerquetschen, mussten wir uns eine Schaltung überlegen,
mit der man einen, mit der Griffkraft steigenden, Parameter messen kann. Hierfür könnte man den Winkel jedes Fingers messen, wodurch
allerdings extra Sensoren notwendig wären. Außerdem ändert sich der Gelenkswinkel der Finger nicht mehr, sobald die Roboterhand
etwas festhält und nur mehr stärker zudrückt. Diese Methode der Griffkraftmessung haben wir deswegen verworfen. \\
\\
Stattdessen haben wir uns dazu entschieden den Strom zu messen, den jeder einzelne Servomotor beim Schließen des jeweiligen Fingers
benötigt. Dies ermöglicht uns jeden Motor einzeln zu regulieren und gegebenenfalls bei einer Fehlfunktion abzuschalten. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.0}
		{\includegraphics[width=0.8 \linewidth]{Schaltbild_Strommessung}}
		\caption{Schaltbild der Stromessschaltung}
		\label{fig:Schaltbild_Strommessung}		
	\end{center}
\end{figure}
\hfill \break
Diese Messung basiert auf dem gleichen Prinzip wie die der Flexsensorstellung in [\textcolor{blue}{\autoref{par:Auslesen der Sensoren}}]. Mithilfe eines 
Shunt-Widerstands wird ein Spannungsabfall gemessen, der anschließend über eine Messchaltung verstärkt und in ein Digitalsignal
umgewandelt wird. \\
\\
Je mehr Strom der Servomotor benötigt, um die gewünschte Position zu erreichen und somit dem Widerstand des Objekts in der Hand entgegen
zu wirken, desto größer ist der Spannungsabfall am Shunt-Widerstand $R_{S}$. Der Motor wird in der obigen Abbildung mit $R_{L}$ dargestellt,
da eine höher Strombedarf dem senken dieses Widerstands in der Simulation gleicht. \\
\\
Wird nun ein Spannungsabfall gemessen, so wird dieser durch den Operationsverstärker verstärkt. Die Verstärkung wird bei dieser Schaltung von 
den Widerständen $R_{1}$ und $R_{2}$ bestimmt. In Serie kommt anschließend ein Tiefpassfilter, um, sowie bei der Schaltung des Eingabesubsystems,
ungewünschte Störungen herauszufiltern. Der Widerstand $R_{3}$ entlasstet den Eingang des folgenden Bauelements, nämlich einem ADC. \\
\\
Folgendes Kriterium wurde bei der Wahl des Operationsverstärkers beachtet:
\begin{itemize}
	\item Ausgangspegel bei gewählter Versorgungsspannung: \\
		  \\
		  Zunächst wurde das Kriterium der Versorgungsspannung betrachtet. Da wir maximal
		  5V Gleichspannung in der gesamten Schaltung verwenden wollen, muss der OPV mit
		  dieser geringen Spannung immer noch verstärken. Da am positiven Verstärkereingang
		  eine maximale Spannung von 5V anliegt, muss dies bei Verstärkern mit einer geeigneten
		  Supply Range auch mit nur 5V Versorgungsspannung gewährleistet sein. Folglich wird
		  die Rail-to-Rail Technolgie [siehe \textcolor{blue}{\autoref{chap:OPV Technologien}}] tragend, um keine Referenzspannung
		  zu benötigen.
\end{itemize}
Da wir nicht bis ganz an die Grenzen des Aussteuerbereichs kommen werden (wird anhand der Berechnungen verständlich), ist der TLV232 wie für diese Anwendung gemacht. \\
\\
\textbf{Dimensionierung der Schaltung} \\
\\
Den theoretischen Widerstand der Servomotoren, haben wir uns, anhand der im Datenblatt angegebenen Stromwerte bei 5V Versorgungsspannung, mit dem ohmschen Gesetz ausgerechnet.
Dies hilft uns unter anderem auch in LTspice, da wir so verschiedene Lasten simulieren können. \\
\\
$R_{Idle} = 500\Omega$ \\
$R_{no Load} = 29.41\Omega$ \\
$R_{max. Load} = 4.16\Omega$ \\
\\
Der OPV, wurde zusammen mit dem Shunt-Widerstand so dimensioniert, dass am Ausgang, bei voller Belastung des Motors, annähernd 5V auftreten. Dabei sollten ca. $100mV$ - $200mV$ 
\"Sicherheitsabsstand\" gelassen werden, da die Rail-to-Rail Technologie auch ihre Grenzen hat und nicht undendlich genau an den Versorgungspegel ausgeben kann. Dies lässt die 
Physik einfach nicht zu. \\
\\
Es wurde ein relativ hochohmiger Shunt-Wdierstand mit $R_{s} = 165m\Omega$ gewählt, um die Leistung, die über den Widerstand verloren geht, möglichst gering zu halten. \\
\\
Mit den folgenden Formeln wude anschließend die notwendige Verstärkung des OPVs berechnet, um auf den gewünschten Ausgangsspannungsbereich zu kommen. \\
\\
$G = 1+\frac{R_{1}}{R_{2}}$ \\
\\
$V_{out} = G*(V_{in+}-V_{in-})+V_{ref}$ \\
\\
Die entgültigen Werte lauten wie folgt: $R_{1} = 100k\Omega$ \\
\hspace*{7.03cm}						$R_{2} = 6.2k\Omega$ \\
\\
Mit diesen Widestandswerten ergibt sich eine Verstärkung von $G = 17.13$. \\
\\
Da nun sichergestellt ist, dass der Ausgangsspannungspegel des OPVs bei der gewählten Verstärkung, dem gewählten Shunt-Widerstand und der 
maximalen Belastung des Servos 5V nicht übersteigt, kann ein Analog-Digital-Wandler ausgewählt werden, um das analoge Signal zu
digitalisieren. Da wir bei der Wahl von ADCs durch das Schaltungsdesign des Eingabesubsystems schon Erfahrung gesammelt haben, viel
das Aussuchen des jetzigen Wandlers nicht schwer. Entschieden haben wir uns für den identen Baustein wie bei der Sensorschaltung, 
jedoch mit dem Unterschied, dass dieser nun einen Aussteuerbereich von 0V - 5V hat, anstatt von 0V - 3.3V. Mit den folgenden Berechnungen
wurde die Auswahl nochmals überprüft und die Stufenweite bestimmt. \\
\\
Auflösung = 10 Bit, bei 0V - 5V Aussteuerbereich\\
\\
$LSB = \frac{5}{1024} = 4.88mV$ \\
\\
Durch diese hohe Auflösung, kann die Griffkraft der einzelnen Finger sehr genau geregelt werden, wodurch ein feines Greifen von Ibjekten
ermöglicht wird. \\
\\

\subsubsection{Versuchsaufbauten und Messungen}
\paragraph{Messschaltung der Griffkraftkontrolle}
\hfill \break
\hfill \break
Das Ziel der Messung ist es, herauszufinden wieviel Strom ein Servomotor, abhängig von dem gerade erzeugten Drehmoment, 
braucht. Die gemessenen Daten sollen uns bei Feinjustierung der Griffkraftregelung der Roboterhand behilflich sein. \\
\\
Der folgende Steckbrettaufbau repräsentiert die oben gezeichnete Schaltung. \\
Die Grundidee ist, dass sich der Spannungsabfall am Shunt Widerstand je nach Auslastung des Servos ändert und somit der 
Stromverbrauch gemessen werden kann. Anhand der vom OPV ausgegebenen Werte, kann folglich in Software die Ansteuerung programmiert 
werden. \\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Messschaltung_Servomessung}}
		\caption{Steckbrettaufbau der Messchaltung zur Strommessung}
		\label{fig:Messschaltung_Servomessung}		
	\end{center}
\end{figure}
\hfill \break
\textbf{Erklärung des Testablaufs}\\
Die Schaltung wird mit +5V versorgt. Der OPV \textquote{TLV232} kann, dank RailToRail Technologie, den Ausgang bis fast auf die 
Versorgungsspannung anheben. Durch die Simulation von verschiedenen Lasten am Servo mit einer Zugkraftwaage, fällt am Shunt 
Widerstand eine andere Spannung ab. Dadurch variiert die Ausgangsspannung des OPVs und im Programm kann ausgewertet werden, 
wie stark ein Finger der Roboterhand belastet wird. Je nachdem, kann dann geregelt werden. 
Wichtig zu beachten ist allerdings, dass diese Messung nicht die wahre Verwendung der Servos widerspiegelt. Für eine 
wahrheitsgetreue Ausmessung der Servobelastung, muss diese an der Hand (den einzelnen Fingern) durchgeführt werden und nicht 
in einem Testaufbau. Im folgenden Bild wird der gesamte Testaufbau gezeigt. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Testaufbau_Servomessung}}
		\caption{Testaufbau der Strommessung eines Servomotors}
		\label{fig:Testaufbau_Servomessung}		
	\end{center}
\end{figure}
\hfill \break
\textbf{Messergebnisse}\\
Die gemessenen Werte wurden in einer Tabelle dargestellt und anschließend grafisch in Diagrammen visualisiert. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.3}
		{\includegraphics[width=0.8 \linewidth]{Messtabelle_Servomessung}}
		\caption{Messtabelle Strommessung}
		\label{fig:Messtabelle_Servomessung}		
	\end{center}
\end{figure}
\hfill \break
In der linkesten Spalte, ist die Servostellung, in Grad, vom Nullpunkt des Servos gemessen, abgebildet. Gleich daneben, wurde 
der Strom aufgetragen, der mit einem Multimeter gemessen wurde. \\
\\
Da bei der Messchaltung ein Fehler aufgetreten ist, sind die Spalten $max. Spannung v. Einsch. (V)$ und $Spannung n. Einsch(V)$
nicht zu beachten! \\
\\
Die Zugkraft des Servomotors ist in Kilogramm und in Newton abgebildet. Rechts daneben ist noch eine Delay-Spalte zu sehen, die
angibt wie lange der Servo gebraucht hat, um sich dem gewählten Winkel anzunähern. Am Anfang wurde es dem Motor selbst überlassen
wie schnell er sich bewegt, jedoch führte dies zu unerwünschten Ungenauigkeiten, weshalb wir diesen Fehlerfaktor der Messung durch 
das Delay ausgeschlossen haben. \\
\\
Ebenfalls zu erkennen ist, dass sich die Zugkraft des Motors ab der halben Vollaussteuerung des Servodrehwinkels nicht mehr ändert.
Dies liegt daran, dass der 3D gedruckte Aufsatz, auf dem die Schnur zur Verbindung des Motors und der Zugkraftwaage angebracht ist,
ab ca. $45N$ Zugkraft nachgegeben hat und in Folge auch kaputt gegangen ist. Dieser Materialfehler hat uns geholfen später im
Projekt neue Aufsätze zu designen, die dem Zug des Servos standhalten. \\
\\
Die Messergebnisse wurden im folgenden Diagramm visualisiert. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.0}
		{\includegraphics[width=0.8 \linewidth]{Zugkraft_Strom_Diagramm_Servomessung}}
		\caption{Diagramm der Strommessung in Abhängigkeit der Zugkraft}
		\label{fig:Zugkraft_Strom_Diagramm_Servomessung}	
	\end{center}
\end{figure}
\hfill \break
Der nicht-lineare Anstieg der Stromwerte in Abhängigkeit der Zugkraft, ist weitestgehend auf die Ungnauigkeit des Servomotors
und die leichten Varianzen im Testaufbau zurückzuführen. Erwartet, beziehungsweise erhofft, haben wir uns einen möglichst linearen
Ansiteg, jedoch hat dies keinen wirklichen Einfluss auf die Funktion des Gesamtsystems, wenn der Kurvenverrlauf in der Software
berücksichtigt wird. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Oszibild_Servomessung}}
		\caption{Oszilloskopbild - Stromanlaufverhalten eines Servomotors}
		\label{fig:Oszibild_Servomessung}	
	\end{center}
\end{figure}
\hfill \break
An dem Oszilloskopbild ist zu erkennen, wie sich der Strom bei der Ansteuerung eines Servomotors verhält. Es ist deutlich sichtbar,
dass der Strom nicht linear steigt, sondern sich dem Spitzenwert immer weiter annähert, bis die gewünschte Position erreicht ist.
Wird kein Objekt gegriffen, so exisitert kein mechanischer Widerstand gegen den der Servo ankämpfen muss, wodurch sich der Strom
wieder auf ein Minimum senkt. Würde der Roboterfinger und somit der Motor einem Widerstand entgegenwirken, so bliebe der Strom auf
einem relativ konstanten Wert stehen bleiben. Dies ist der Fall, da ein Servo einen Gleichstrommotor eingebaut hat und dieser nicht 
nur für die Bewegung, sondern auch für das Entgegnwirken einer mechanischen Last Strom benötigt. 

\subsubsection{Schaltungsdesign}
\label{chap:Schaltungsdesign_Roboterhand}
Nach den diversen Überlegungen, Konzepten und Berechnungen, wird in diesem Punkt das genauere Schaltungsdesign erläutert. Es wird
erklärt worauf bei dem Schaltungsentwurf geachtet werden musste und mit welchen Besonderheiten, beziehungsweise Problemen, wir zu
tun hatten. 

\paragraph{Externe Anschlüsse}
\hfill \break
\hfill \break
Wie auch schon bei der Schaltung des Eingabesubsystems, setzen wir auch beim Ausgabesubsystems auf einen USB-C Anschluss.
Dieser dient zur Programmierung des Mikrokontrollers. Versorgt werden kann die Schaltung aufgrund des hohen Strombedarfs der Servomotoren
allerdings nicht. Vorteilhaft ist dies allerdings auch, da die Platine gleichzeitig mit einem Netzteil verbunden sein kann und keine 
Gefahr besteht zwei Versorgungen gleichzeitig anzuschließen. \\
\\
\textbf{Anschluss zur Programmierung des Mikrokontrollers} \\
\\
Für de Programmierung des Mikrokontroller ist ein USB-Anschluss notwendig. Da das Projekt mit den neuesten Computern
kompatibel sein soll, haben wir uns, genauso wie beim Eingabesubsystem, für einen USB-C-Typ2.0 entschieden. Das Serial-Signal
des angeschlossenen Computers, wird über die beiden Leitungen $D+$ und $D-$ übertragen. Die Anschlüsse $CC1$ und $CC2$ werden
nicht benötigt, weshalb diese mit über einen Widerstand mit $GND$ verbunden sind. $SBU1$ und $SBU2$ werden ebenfalls nicht 
benötigt. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{USB_C_Schaltplan_Roboterhand}}
		\caption{USB-C-Buchse}
		\label{fig:USB_C_Schaltplan_Roboterhand}		
	\end{center}
\end{figure}
\hfill \break
\textbf{Anschluss zur Versorgung der Schaltung} \\
\\
Da die Schaltung nicht über die USB-C-Buchse versorgt werden kann, muss dies über ein Netzteil geschehen. Für diesen Zweck
haben wir einen Connector mit zwei Pins vorgesehen. Ein Pin für die positive Versorgung und der andere für den $GND-Anschluss$
des Netzteils.  Zusätzlich dazu, wurde noch ein Jumper verbaut, der es uns erlaubt die Schaltung von der Versorgung zu trennen
ohne jedes mal das Netzteil abdrehen zu müssen. Bei der nächsten Schaltungsversion wird die Versorgung über einen Barrel Jack
erfolgen. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{Netzteil_Anschluss_Schaltplan_Roboterhand}}
		\caption{Netzteil Input Connector}
		\label{fig:Netzteil_Anschluss_Schaltplan_Roboterhand}		
	\end{center}
\end{figure}
\hfill \break

\paragraph{Serial-UART-Bridge}
\hfill \break
\hfill \break
Der Serial-UART-Chip, hat die Aufgabe das über die USB-Buchse kommende Serial-Signal in ein UART-Signal umzuwandeln.
Dies ist notwendig, da der verwendete Mikrokontroller keine Serial-Signale verarbeiten kann. Über die ausgekreuzten
Leitungen $RXD$ und $TXD$, werden die Daten zur Weiterverabeitung übertragen. Die Versorgung basiert auf $3.3V$. Die Pins
$DTR$ und $RTS$ sind über eine Transistorschaltung ebenfalls mit dem Mikrokontroller verbunden. Die $EN$ Leitung ist für 
die $RESET-Funktion$ gedacht und die $IO0$ Leitung für den Uploadvorgang von programmiertem Code. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{UART_Bridge_Schaltplan_Roboterhand}}
		\caption{Serial-UART-Bridge}
		\label{fig:UART_Bridge_Schaltplan_Roboterhand}	
	\end{center}
\end{figure}
\hfill \break

\paragraph{Mikrokontroller}
\hfill \break
\hfill \break
Der Mikrokontroller ist das Herz der Schaltung. Aufgrund der nötigen Kompatibilität in Bezug auf den Funk, haben wir uns, genauso wie beim Eingabesubsystem, für einen ESP32-Chip entschieden.
Die geneue Bezeichnung lautet $ESP32-WROOM-32E-N16$. Zu diesem Chip führen unter anderem die zuvor beschriebenen Leitungen der Serial-UART-Bridge wodurch die Anbindung an die Außenwelt ermöglicht 
wird. Von diesem Chip gehen außerdem die I2C-Datenleitungen weg, welche mit dem ADC und dem PWM-Controller verbunden sind. Um eine möglichst störungsfreie Übertragung zu gewährleisten, wurden, außer 
den offensichtlichen $10k\Omega$ Pull-Up-Widerständen, noch Serienwiderstände in den Datenleitungen beigefügt. Diese dienen dem Schutz gegen Spannungsspitzen und mindern teilweise auch die Störungen
die während dem normalen Betrieb auftreten können. \\
Die Funktionen der weiteren Pins werden in den folgenden Punkten, gemeinsam mit den dazugehörigen Bauteilen, näher erläutert. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{Mikrokontroller_Schaltplan_Roboterhand}}
		\caption{Mikrokontroller ESP32}
		\label{fig:Mikrokontroller_Schaltplan_Roboterhand}	
	\end{center}
\end{figure}
\hfill \break

\paragraph{Mikrokontroller Buttons}
\hfill \break
\hfill \break
Wie auch schon bei der Schaltung des Eingabesubsystems, werden für den ESP32 jeweils ein Drucktaster für das Hochladen von Code und das Zurücksetzen des Chips benötigt. Diese Buttons sind mit dem Mikrokontroller
und des Serial-UART-Bridge verbunden. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{Buttons_Schaltplan_Roboterhand}}
		\caption{Mikorkontroller Buttons}
		\label{fig:Buttons_Schaltplan_Roboterhand}		
	\end{center}
\end{figure}
\hfill \break

\paragraph{Versorgung}
\hfill \break
\hfill \break
Da nicht alle Schaltungsteile mit 5V versorggt werden können, muss die Spannung auf einen geeigneten Pegel umgewandelt werden. Hierzu verwenden wir einen Spannungswandler. Am Eingang und Ausgang des Bausteins
sind Stützkondensatoren zu $GND$ geschalten, um die Spannungspegel von $5V$ und $3.3V$ zu stabilisieren. Zusätzlich dazu, ist bei jedem Versorgungspin eines Schaltungsbausteins noch ein Stützkondensator vorgesehen. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{Spannungswandler_Schaltplan_Roboterhand}}
		\caption{Spannungswandler 5V - 3.3V}
		\label{fig:Spannungswandler_Schaltplan_Roboterhand}		
	\end{center}
\end{figure}
\hfill \break

\paragraph{PWM-Controller}
\hfill \break
\hfill \break
Der PWM-Controller ist das Bauteil, das für die korrekte Datenübertragung der Steuerungsdaten an die Servomotoren zuständig ist. Da wir keine Funktionen und Anschlüsse des Mikrokontrollers blockieren wollen [siehe \textcolor{blue}{\autoref{par:Ansteuerung der Motoren}}], 
haben wir den $PCA9685$ gewählt. Dieser ist per I2C-Protokoll ansteuerbar und hilft uns daher die Anzahl der elektrischen Leitungen auf ein Minimum zu reduzieren. Um die korrekte Ansteuerung des Mikrochips zu gewährleisten, existieren
natürlich auch Adresspins (A0 - A5). Diese können auf $HIGH$ oder $LOW$ gesetzt werden, um die I2C-Adresse benutzerdefiniert einzustellen. Wir haben uns dazu entschieden diese Adressierung mit Lötjumpern einstellbar zu machen. Standardmäßig
ist die Adresse auf $0 0 0 0 0 0$, kann jedoch geziehlt durch das zulöten einzelner Jumper modifiziert werden. Der Pin $OE$, ist mit dem ESP32 verbunden. Dieser Anschluss erlaubt uns den PWM-Output des Mikrochips, durch ein $HIGH$ oder $LOW$ 
Signal, ein -und auszuschalten. Es ist zu erkennen, dass der Chip die Möglichkeit bietet bis zu 16 Servomtoren anzusteuern. Bei unserer Anwendung werden bei der aktuellen Entwicklungsstufe allerdings nur 6 Anschlüsse benötigt. Versorgt wird
der Controller mit 5V. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{PWM_Controller_Schaltplan_Roboterhand}}
		\caption{PWM Controller}
		\label{fig:PWM_Controller_Schaltplan_Roboterhand}		
	\end{center}
\end{figure}
\hfill \break

\paragraph{Servoanschlüsse}
\hfill \break
\hfill \break
Jeder Servomotor ist mit einem PWM-Pin des PWM-Controllers verbunden. Durch diese elektrischen Leitungen erhalten die Motoren ihre Drehbefehle. Um kompatibel mit dem Rest der Schaltung zu sein, haben wir die Versorgungsspannung für die Motoren mit
5V gewählt. Ein höherer Spannungspegel mit 6V wäre auch möglich gewesen, allerdings ist der Aufwand die Spannung zu erhöhen mit dem daraus resultierenden Gewinn an Zugkraft nicht zu vergleichen. Aufgrund dieses Umstands, wurde der Versorgungspegel
wie beschrieben gewählt. Über den $GND-Anschluss$ jedes Servomotors, wird die Strommessung [siehe \textcolor{blue}{\autoref{par:Positions -und Kraftmessung der Roboterfinger}}] realisiert. Der Shuntwiderstandswert von $165m\Omega$ wird, aufgrund thermischer Verluste, durch zwei parallel geschaltete $330m\Omega$ 
Widerstände erzeugt, wodurch sich die Verlustleistung auf zwei Bauteile aufteilt. Die weitere Logik hinter dem $GND_servo-Anschluss$ wird im folgenden Punkt erklärt. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{Servoanschluss_Schaltplan_Roboterhand}}
		\caption{Servo Anschlüsse}
		\label{fig:Servoanschluss_Schaltplan_Roboterhand}		
	\end{center}
\end{figure}
\hfill \break

\paragraph{Strommessung zur Griffkraftkontrolle}
\hfill \break
\hfill \break

\begin{itemize}
	\item \textbf{Multiplexer} \\
	\\
	Der Multiplexer ermöglicht es, die Messschaltung der Griffkraftkontrolle nur einmal bauen zu müssen. Dies ermöglicht die Fähigkeit des Bauteils, in Bruchteilen einer Sekunde zwischen 8 verschiedenen Eingangskanälen zu wechseln.
	Die oben dargestellten Anschlüsse für die Servomotoren, müssen für jeden Motor einzeln vorhanden sein. Dank des Multiplexers, kann jeder $GND-Pin$ allerdings auch zur Messung des Spannungsabfalls am Shunt-Widerstand gemessen werden.
	Jede Leitung die mit dem Label $GND\_servo$ beschriftet ist, wird an den Multiplexer angeschlossen, der mit dem Operationsverstärker der Messschaltung verbunden ist. Durch diese Schaltungslogik, kann jeder Motor mit nur einer einzigen
	Schltung überwacht werden. Da der OPV einen sehr, sehr hohen Eingangswiderstand hat, fließt der, von den Motoren benötigte Strom, fast ausschließlich über die Shunt-Widerstände. Dies verhindert, dass der Multiplexer hohe Ströme
	schalten muss und somit Verluste auftreten. \\
	\\
	Mithilfe der Pins A0 - A2, kann der Multiplexer gesteuert werden. Durch eine Bitkombination, die in der Software variiert wird, kann somit der Eingangskanal gewählt und durchgeschaltet werden. Mit den Pin $EN$ kann das Bauteil deaktiviert,
	beziehungsweise aktiviert werden. \\
	\\
	Der Anschluss $to\_GND\_servos$, verbindet den Multiplexer mit dem Operationsverstärker $TLV232$.
	\\
	\begin{figure}[H]
		\begin{center}
			\scalebox{0.6}
			{\includegraphics[width=0.8 \linewidth]{Multiplexer_Schaltplan_Roboterhand}}
			\caption{Multiplexer Schaltung}
			\label{fig:Multiplexer_Schaltplan_Roboterhand}		
			\end{center}
	\end{figure}
	\hfill \break

	\item \textbf{Operationsversätker} \\
	\\
	Mit dem Operationsverstärker wird der Spannungsabfall am Shunt-Widerstand jedes Servos verstärkt. Der Ausgang des Multiplexers ist nun der positive Eingang des OPVs. Nach der Verstärkung des Spannungspegels, wird
	das Signal noch gefiltert, bevor es über das Label $to\_ADC$ zum Analog-Digital-Wandler übertragen wird. Für weitere Informationen zum Schaltungsdesign, siehe [\textcolor{blue}{\autoref{par:Positions -und Kraftmessung der Roboterfinger}}] \\
	\\
	\begin{figure}[H]
		\begin{center}
			\scalebox{0.6}
			{\includegraphics[width=0.8 \linewidth]{OPV_Schaltplan_Roboterhand}}
			\caption{OPV Schaltung}
			\label{fig:OPV_Schaltplan_Roboterhand}		
		\end{center}
	\end{figure}
	\hfill \break

	\item \textbf{Analog-Digital-Wandler} \\
	\\
	Das Ausgangssignal des Operationsverstärkers wird nun digitalisiert, um vom Mikrokontroller verarbeitet werden zu können. Über die beiden Datenleitungen $SDA$ und $SCL$ werden die digitalen Daten an den ESP32 übertragen. 
	Adresspins sind bei diesem Bauteil keine vorhanden, weshalb die Standardadresse aus dem Datenblatt zur Ansteuerung zu verwenden ist. \\
	\\
	\begin{figure}[H]
		\begin{center}
			\scalebox{0.6}
			{\includegraphics[width=0.8 \linewidth]{ADC_Schaltplan_Roboterhand}}
			\caption{ADC Schaltung}
			\label{fig:ADC_Schaltplan_Roboterhand}			
		\end{center}
	\end{figure}
	\hfill \break
\end{itemize}

\paragraph{Status LEDs}
\hfill \break
\hfill \break
Genau wie bei der Schaltung des Eingabesubsystems, soll den Benutzer des Produkts ein optisches Feedback über wichtige Parameter bekommen. Dies wird durch zwei Leuchtdioden umgesetzt. Eine leuchtet bei aufrechter Versorgung und die
Funktion der anderen LED kann frei gewählt werden. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{LEDs_Schaltplan_Roboterhand}}
		\caption{Status LEDs}
		\label{fig:LEDs_Schaltplan_Roboterhand}		
	\end{center}
\end{figure}
\hfill \break

\subsubsection{Platinendesign}
\label{chap:Platinendesign Roboterhand}
\paragraph{Erste Testplatine}
\hfill \break
\hfill \break
Die erste Testplatine wurde in der schuleigenen Werkstatt, mithilfe einer Platinenfräse, geffertigt. Da das Design auch zu dem frühen Zeitpunkt des Projekts schon relativ kompliziert war, gab es bei der Fertigung einige Probleme.
Aufgrund schon vorhandener Erfahrung, wurden die Bauteile mit möglichst großem Fottprint (1206) gewählt, um ein einfaches Löten per Hand zu ermöglichen. Da es ICs aber leider nur in einer, für das Bauteil festgelegten, Größe zu kaufen gibt,
mussten Leiterbahnen mit einer Breite von nur 0.3mm verwendet werden. Dies führte beim Löten leider zum Ablösen dieser, weshalb einige Jumper-Kabel notwendig waren, um die kaputten Leiterbahnen zu ersetzen. Die Installation dieser 
Ersatzkabel, hat einige Zeit in Anspruch genommen, wodurch der Entwicklungsprozess der Hardware kurzzeitig verzögert wurde. \\
\\ 
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{Platine_Roboterhand_oben_v1}}
		\caption{Oberseite erste Testplatine Ausgabesubsystem}
		\label{fig:Platine_Roboterhand_oben_v1}		
	\end{center}
\end{figure}
\hfill \break
Dies ist die Oberseite der ersten Testplatine. Es ist der ESP32 zu sehen. Rechts und links daneben die Taster zum Hochladen von Code und zum Zurücksetzen des Mikrokontrollers. Zu diesem Zeitpunkt der Entwicklung wurde noch eine Micro-USB-Buchse
verwendet, da diese weitaus leichter zu löten ist als USB-C-Buchsen. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Platine_Roboterhand_unten_v1}}
		\caption{Unterseite erste Testplatine Ausgabesubsystem}
		\label{fig:Platine_Roboterhand_unten_v1}		
	\end{center}
\end{figure}
\hfill \break
Nun ist die Unterseite der ersten Testplatine zu sehen. Es kann erkannt werden, dass einige ungeplante Modifikationen vorgenommen wurden, um die Platine ein erstes mal in Betrieb setzen zu können. Unter anderem wurden zwei Pins zum ESP32 (grüne Kabel)
neu verbunden und die Shunt-Widerstände mit 6, parallel geschalteten, $1\Omega$ Widersständen realisiert, da es Lieferschwierigkeiten mit den korrekten SMD-Widerständen gab. Über das rote und blaue, etwas dickere Kabel, wurde die Platine erstmals versorgt. \\
\\
Unter den grünen Kabeln ist zu erkennen, wie dünn die Leiterbahnen sein mussten, um diese mit den Pins der ICs verbinden zu können. In der rechten, oberen Ecke des Bildes, sind die Adress-Jumper des PWM-Controllers zu erknennen. Dieser wurde für Testzwecke 
auf dieser Platine schon integriert, obwohl nur ein Servomotor angeschlossen werden kann. \\
\\
Nach dem genauen Messen der Schaltung, wurde die korrekte Funktion bestätigt und mit dem Entwurf der zweiten Platinenversion begonnen. \\
\\

\paragraph{Zweite Version der Platine}
\hfill \break
\hfill \break

\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Platinenlayout_Roboterhand_oben_v2}}
		\caption{Toplayer zweites Platinendesign}
		\label{fig:Platinenlayout_Roboterhand_oben_v2}	
	\end{center}
\end{figure}
\hfill \break
In [\textcolor{blue}{\autoref{fig:Platinenlayout_Roboterhand_oben_v2}}], ist der Toplayer des zweiten Platinenldesigns zu sehen. Auf der Oberseite des
PCBs, sind alle Komponenten angebracht, die für Wartungszwecke zugänglich sein müssen. Dies umfasst alle Anschlüsse für die Servomotoren,
die Adressjumper des PWM-Controllers, den Reset -und Upload-Button und die beiden Status-LEDs zur visuellen Überwachung der Schaltung. 
Bei diesem Layout wurde, im Gegensatz zur ersten Testplatine, auf die größe geachtet. Diese sollte so klein wie möglich sein, muss
aber trotzdem genügend Raum für die großen Shunt-Widerstände und dicken Leiterbahnen auf dem Bottom-Layer lassen. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.6}
		{\includegraphics[width=0.8 \linewidth]{Platinenlayout_Roboterhand_unten_v2}}
		\caption{Bottomlayer zweites Platinendesign}
		\label{fig:Platinenlayout_Roboterhand_unten_v2}		
	\end{center}
\end{figure}
\hfill \break
Auf dem Bottom-Layer in [\textcolor{blue}{\autoref{fig:Platinenlayout_Roboterhand_unten_v2}}], wurden alle Komponenten platziert, die zur Messung und Verarbeitung
der Daten notwendig sind. Am unteren und rechten Rand der Platine, sind die Shunt-Widerstände zu sehen, die aufgrund der zu vertragenden
Leistung einen größeren Footprint haben. Zusätzlich dazu, sind diese nochmals parallel geschaltet, wodurch die Verlustleistung auf 
zwei Widerstände aufgeteilt wird. Um lange Leiterbahnen, auf denen ein hoher Strom fließt, zu vermeiden, wurden die Shunts sehr nah 
an den $5V$ Anschlüssen der Servos positioniert. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Platinenmodell_Roboterhand_oben_v2}}
		\caption{Oberseite zweites Platinenmodell}
		\label{fig:Platinenmodell_Roboterhand_oben_v2}		
	\end{center}
\end{figure}
\hfill \break
In [\textcolor{blue}{\autoref{fig:Platinenmodell_Roboterhand_oben_v2}}], ist das 3D-Modell der Platine für das Ausgabesbusystem zu sehen. In der rechten, oberen
Ecke der Abbildung, sind die beiden Versorgungspins der Schaltung zu sehen. Diese sind bei der zweiten Platinenversion noch Pinheader, sollen
später allerdinsg in Form eines Barrel-Jack realisiert werden. Links neben der Versorgungsanschlüssen, ist der Footprint für einen Ein -Ausschalter
zu sehen, wie in [\textcolor{blue}{\autoref{par:Externe Anschlüsse}}] zu sehen. Alle weiteren Schaltungsteile sind in [\textcolor{blue}{\autoref{chap:Schaltungsdesign_Roboterhand}}] näher
erklärt. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Platinenmodell_Roboterhand_unten_v2}}
		\caption{Unterseite zweites Platinenmodell}
		\label{fig:Platinenmodell_Roboterhand_unten_v2}		
	\end{center}
\end{figure}
\hfill \break
Zu sehen in [\textcolor{blue}{\autoref{fig:Platinenmodell_Roboterhand_unten_v2}}], ist der Bottom-Layer als 3D-Modell. Es wurde auf eine möglichst effiziente
Anordnung der Bauteile geachtet, damit die Platine so wenig Platz wie möglich in Anspruch nimmt. \\
\\
\newpage
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\section{Software Realisierung}

\subsection{Handschuh [\textcolor{blue}{Schweitzer}]}
\subsubsection{Konzepte und Überlegungen}
\paragraph{Datenübertragung}
\label{par:Datenübertragung}
\hfill \break
\hfill \break
Es gibt viele Möglichkeiten die Werte, die man von jedem einzelnen Flexsensor [siehe \textcolor{blue}{\autoref{chap:Flexsensor}}] ausliest, zu übertragen. Wichtig ist es, dass 
dies einfach und auf eine sehr stabile Weise funktioniert. Werden nämlich Daten fehlerhaft oder nur teilweise übertragen, dann 
wirkt sich das auf der Empfängerseite drastisch aus. Es könnten dadurch unerwartete Fehler passieren beziehungsweise könnte die 
Roboterhand von einem unstabilen System sehr hohe Schwankungen der Werte andauern wahrnehmen, was zu einer durchgängigen 
Belastung der Servos [siehe \textcolor{blue}{\autoref{chap:Servomotor}}] führen würde. Das ist zwar nicht allzu schlimm, aber verbraucht unnötig Ressourcen. Anfangs war Bluetooth 
die favorisierte Option, da man im Alltag immer wieder mit Geräten zu tun hat, die Bluetooth als Standard der Funkübertragung 
verwenden. Allerdings haben wir uns später dann aber für Wifi [siehe \textcolor{blue}{\autoref{chap:WiFi}}] entschieden, da angenommen wurde, dass wir große Mengen an Daten 
versenden. Dies ist nun aber nicht nötig, da nur die Widerstandswerte, die über einen ADC [siehe \textcolor{blue}{\autoref{chap:Analog-Digital-Wandler}}] umgerechnet werden, nun versendet 
werden Deshalb haben wir nach einer neuen Möglichkeit gesucht, die einfacher zu realisieren ist. Schlussendlich wurde es dann 
ESP-NOW [siehe \textcolor{blue}{\autoref{chap:ESP-NOW}}], das auf 2,4GHz funkt und am ehesten mit Wifi verglichen werden kann. Es können pro Sendung 250 Byte gesendet werden. 
Ebenso ist eine Kommunikation zwischen mehreren ESP32 in beide Richtungen möglich. Der Standard gilt allerdings wirklich nur 
für den ESP32, was allerdings aufgrund der Wahl von nur diesem letztgenannten, keine Probleme darstellt. ESP-NOW sendet auf dem 
802.11 Protokoll [siehe \textcolor{blue}{\autoref{par:802.11b/g/n Standard}}], wie auch Wifi es macht. Der Vorteil liegt aber klar in der Energieeffizienz. ESP-NOW benötigt nämlich weniger 
Energie (vor allem, weil weniger Daten maximal gesendet werden können) als Wifi und ist deshalb gerade für unseren Zweck, die 
energiebetriebene Versorgung der Senderplatine, optimal. Nicht zu vergessen ist der schnellere Verbindungsaufbau. Beim Testen 
hatten sich beide Platinen sofort miteinander verbunden. Ein großer Vorteil ist die Peer-to-Peer Kommunikation, die zwischen 
den einzelnen ESP32 möglich ist. Es wird dafür kein Router oder Access Point benötigt. Dadurch, dass es auch einfach möglich 
ist, einzustellen, welche Platine über ESP-NOW senden, empfangen oder der Transceiver sein soll, kann man sehr leicht den 
spezifischen Anwendungsfall realisieren. \\
\\
\paragraph{Programmiersprache/Entwicklungsumgebung}
\hfill \break
\hfill \break
\begin{figure}[H]
	\begin{center}
		\scalebox{0.7}
		{\includegraphics[width=0.8 \linewidth]{ESP_Datenübertragung}}
		\caption{ESP NOW Datenübertragung (\textcolor{blue}{Quelle: \cite{Hsieh}})}
		\label{fig:ESP NOW Datenübertragung}			
	\end{center}
\end{figure}
\hfill \break
Die Arduino IDE (1. \& 2. Version) [siehe \textcolor{blue}{\autoref{chap:Arduino IDE}}] wird als Entwicklungsumgebung verwendet, da diese für Mikrocontroller der Firma Arduino 
konzipiert wurde. Der ESP32 gehört auch zu den Mikrocontrollern, weshalb er ebenfalls über eigene Bibliotheken bestenfalls 
über die Arduino IDE angesteuert werden kann. Der Code wird in der Programmiersprache C oder C++ geschrieben, da diese für 
die Programmierung von Mikrocontrollern bestens geeignet ist. Mit Hilfe von verschiedenen Bibliotheken aus dem Internet wird 
die Implementierung von bestimmten gewünschten Funktionen vereinfacht. Wichtig ist allerdings dabei, dass alle benötigten 
Funktionen auch getestet und angewandt werden können. Durch kleine Testprogramme wird also jede Funktion einzeln getestet und 
dann am Schluss zu einem Programm zusammengefügt, aber erst, wenn alles fehlerfrei funktioniert hat. Der Vorteil der Arduino 
IDE besteht darin, dass die unterschiedlichsten Möglichkeiten der Konfiguration des ESP32 darüber möglich sind. Es kann 
beispielsweise die Baud-Rate geändert werden. Wichtig ist, dass es auch sowohl mit der Arduino IDE der ersten und zweiten 
Generation ohne Probleme funktioniert, die Datei mit dem Programm auf den ESP32 zu laden. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.7}
		{\includegraphics[width=0.8 \linewidth]{Beispiel_ArduinoIDE}}
		\caption{Beispiel Arduino IDE 2}
		\label{fig:Beispiel_ArduinoIDE}			
	\end{center}
\end{figure}
\paragraph{Einfache Bdienbarkeit}
\hfill \break
\hfill \break
Es ist wichtig, dass jeder, der sich ein wenig mit der Software beschäftigt, diese auch verstehen und vor allem benutzen kann. 
Es soll darauf geachtet werden, dass so viele Codezeilen wie möglich und nötig mit Kommentaren erklärt wird, sodass eine 
einfachere Bearbeitung der Software realisiert werden kann. Die Fehlerbehebung soll damit um ein Vielfaches vereinfacht werden, 
da man leicht abschätzen kann, wo ein Fehler liegen könnte. Zur effizienteren Erweiterung des Programmes soll es in 
verschiedene Blöcke aufgeteilt werden. Damit ist gemeint, dass jeder Block einzeln einmal getestet wurde, bevor dieser im 
endgültigen Programm in Betrieb gehen wird. Am Ende soll es möglich sein, dass nur der ESP32 per UART-Verbindung [siehe \textcolor{blue}{\autoref{chap:UART Funktionsweise}}], über eine 
USB-C Kabel, angeschlossen wird und man das Programm nur auf diesen hochladen muss. Die optimalen Anpassungen sollen in der 
Standardversion des Programmes dann bereits vorhanden sein. \\
\\
\paragraph{Testen}
\hfill \break
\hfill \break
Jedes Programm muss ausführlich getestet werden. Die Tests bei der Senderplatine (Handschuh) beschäftigen sich vor allem mit 
dem Auslesen der Widerstandswerte der Flexsensoren. Es soll überprüft werden, ob sich die Werte in dem von dem Benutzer 
freiwillig ausgesuchten Bereich der map Funktion liegen. Bei dem Test soll bei dem gestreckten Flexsensor der maximale Wert 
angezeigt werden und bei ganz gebeugtem Zustand (maximale Biegung am Handschuh durch Fingerbiegung) der niedrigste. Es ist 
wichtig auch zu testen, ob der Multiplexer [siehe \textcolor{blue}{\autoref{chap:Multiplexer}}] überall durchschaltet und das in richtiger Weise. Nachdem dies erfolgreich 
implementiert wurde, sollen die Werte des ADCs überprüft werden, der hinter den Multiplexer geschaltet wurde. Wenn diese Werte 
ebenfalls realistisch sind, dann können diese Werte wie vorher bereits erwähnt gemapt werden und dann in einem bestimmten Format 
über ESP-NOW an die Empfängerplatine (Roboterhand) gesendet werden. Dabei soll überprüft werden, ob auch wirklich Daten 
gesendet werden. Bei erfolgreichem Empfangen der Empfängerplatine soll die Senderplatine im Serial Monitor der Arduino IDE 
ausgeben, dass die Daten erfolgreich gesendet und empfangen wurden. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.7}
		{\includegraphics[width=0.8 \linewidth]{Beispiel_70k}}
		\caption{Beispiel maximaler Widerstand (\textcolor{blue}{Quelle: \cite{Pelayo}})}
		\label{fig:Beispiel_70k}			
	\end{center}
\end{figure}
\begin{figure}[H]
	\begin{center}
		\scalebox{0.7}
		{\includegraphics[width=0.8 \linewidth]{Beispiel_30k}}
		\caption{Beispiel minimaler Widerstand (\textcolor{blue}{Quelle: \cite{Pelayo}})}
		\label{fig:Beispiel_30k}			
	\end{center}
\end{figure}
\paragraph{Allgemeines Konzept}
\hfill \break
\hfill \break
Die Senderplatine ist so konzipiert worden, dass Flexsensoren über Drähte an die Platine angeschlossen sind. An jedem Anschluss 
befindet sich eine Leiterbahn zu einem Multiplexer. Dieser soll über die Software angesteuert werden und immer wieder im 
richtigen Abstand durchschalten. Wenn dies richtig funktioniert, dann soll die Software die Werte des ADCs auslesen, da mit 
diesen dann später gearbeitet wird. Diese Werte werden dann jeweils in folgendes Format gebracht: $"\$s:n:angepassterWert"$ 
(n…Multiplexer 0 – 4; angepasster Wert…gemapter Wert des Flexsensors). Eine drahtlose Verbindung zur Empfängerplatine 
(Roboterhand) ist über ESP-NOW herzustellen. Wenn die Verbindung von der Sender- zur Empfängerplatine erfolgreich hergestellt 
wurde, dann können die Werte, die in das vorher beschriebene Format gebracht wurden, per ESP-NOW versendet werden. Als Antwort 
soll man im Serial Monitor sehen können, ob die Werte erfolgreich empfangen wurden. \\
\\
\paragraph{Minimaler \& maximaler Widerstandswert}
\hfill \break
\hfill \break
Anfangs gingen wir davon aus, dass die Werte der Flexsensoren sehr genau ausgelesen werden können. Wir sind davon ausgegangen, 
dass jedes Mal die Werte je bestimmter Biegung sehr ähnlich sein werden. Grundsätzlich ist dies nicht falsch, jedoch gibt es 
ein Problem, das wir erst im Laufe der Zeit wahrgenommen haben. Die Flexsensoren halten nämlich nicht so gut wie gedacht auf 
dem Handschuh. Oftmals rutschen diese hin und her und der Wert, der sich je nach Biegung des Fingers bei der Messung variiert. 
Das stellt ein großes Problem dar, denn jedes Mal müsste dann ein neuer minimaler und maximaler Wert angenommen werden, was 
einen Mehraufwand verursacht. Wenn die Flexsensoren dann aber fest am Handschuh befestigt sind, es eine geeignete Lösung dafür 
gibt, dann wäre keine Einschränkung der Werte notwendig. \\
\\
Es ist nun allerdings nötig, dass minimale und maximale Werte auf jeden Fall fix konfiguriert werden. Der minimale und maximale Wert 
jedes einzelnen Flexsensors muss unbedingt festgelegt werden. Diese sind dann in der Software hardcoded. Ohne diese Vorgehensweise würde es oft der Fall sein, dass nie 
der minimale oder maximale Wert erreicht wird, egal wie viel man jeden Finger zu biegen oder strecken versucht. Durch die 
Festlegung dieser Grenzwerte ist es möglich, dass der minimale und der maximale Wert auf jeden Fall erreicht werden. Die Werte, 
die dann unter dem minimal festgelegten Widerstandswert liegen, werden auf den minimal eingestellten Wert gesetzt. Jene die 
über dem festgelegten Widerstandswert liegen, werden auf den maximal eingestellten Wert gesetzt. Somit ist es ohne Probleme 
möglich, dass Werte, die ebenso als Fehlmessungen gezählt werden können, schon im Vorhinein aus dem Wertebereich, aus dem Werte 
später drahtlos übertragen werden, herausgefiltert werden. Viel zu hohe Werte, die daraus resultierend sind, dass die Verbindung 
zum Flexsensor fehlerhaft ist, werden somit automatisch gelöscht und nicht per ESP-NOW später übertragen. Man verliert einen 
sehr kleinen Wertebereich durch diese festgelegten Grenzwerte, allerdings ist dies nicht merkbar und reduziert deutlich 
Unregelmäßigkeiten und Fehlmessungen. Wenn nun die Flexsensoren zusätzlich auch noch am Handschuh verrutschen, dann wird 
trotzdem noch eine sehr gute Messung und valide Werte zur Übertragung möglich sein. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{minimalerWert}}
		\caption{Flexsensor minimaler Wert}
		\label{fig:minimalerWert}			
	\end{center}
\end{figure}
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{maximalerWert}}
		\caption{Flexsensor maximaler Wert}
		\label{fig:maximalerWert}			
	\end{center}
\end{figure}
\hfill \break
In [\textcolor{blue}{\autoref{fig:minimalerWert}}] kann man sehen, dass der Flexsensor nicht gebogen wurde. Wenn allerdings auch eine leichte Biegung vorhanden wäre, würde noch der 
minimale Wert angenommen werden, um immer die niedrigste Grenze erreichen zu können. Das Gegenteilige gilt für [\textcolor{blue}{\autoref{fig:maximalerWert}}], wo immer der maximale 
Wert bei beinahe vollständigem Abbiegen des Fingers angenommen wird. \\
\paragraph{Toleranz bei Werten}
\hfill \break
\hfill \break
Da alle Widerstandswerte der Flexsensoren auf die Stelle genau und beinahe ohne 
Pause ausgelesen werden, wird jede kleinste Veränderung wahrgenommen. Die 
Finger der Roboterhand fangen zum Zittern an. Die gesamte Mechanik wird instabil, 
da durch diese kleinsten Änderungen diese nur noch am Zittern ist. Das könnte 
zu Schäden führen. Um dies zu vermeiden, wird ein Toleranzbereich festgelegt, 
in unserem Fall +10. Das bedeutet, dass Änderungen des digitalen Wertes erst 
ab +-10, im Vergleich zum zuletzt gesendeten Wert, wahrgenommen und an die 
Empfängerseite drahtlos übertragen werden. Dies führt zu deutlich ruhigeren 
und realistischeren Bewegungen der Finger auf der Empfängerseite. \\
\\
\paragraph{Verworfene Ideen}
\hfill \break
\hfill \break
Vollstädnige Datenkorrektur auf Senderseite (arithmetischer Mittelwert) \\
Ursprünglich wurde mit dem Gedanken gespielt, dass die eingelesenen Werte bereits auf der Senderseite mit allen Korrekturalgortihmen korrigiert werden. 
Allerdings haben wir uns dann überlegt, dass es aus energietechnischer Sicht sinnvoller ist, wenn man alle, bis auf das Setzen des minimalen und maximalen Widerstandes, auf der Empfängerseite 
anwendet. Die Datenkorrektur hätte nach folgendem System aufgebaut werden sollen: \\
\\
Die Werte jedes einzelnen Widerstands werden eingelesen. Dabei vergleicht man die ersten zehn eingelesenen Werte mit jeweils 
einem neuen Wert. Der arithmetische Mittelwert soll hierbei herangezogen werden. So würde man auch ein sehr schnelles Öffnen 
und Schließen der Hand unterbinden, da dies auch durch Fehlmessungen verursacht werden könnte. Der arithmetische Mittelwert 
liefert dann sozusagen eine Rampe in die eine oder in die andere Richtung, wenn man eine Faust im Handschuh machen würde. Dass 
der Median allerdings als viel sinnvoller betrachtet wird, das fiel uns mit der Zeit erst auf. Beim Median nehmen wir die 
letzten 5 eingelesenen Werte her und nehmen davon immer den Median. Dadurch wird der Wert genommen, der sich in der 
größentechnischen Mitte der Werte befindet. Sollte also ein extrem hoher oder extrem niedriger Wert zufällig eingelesen werden, 
obwohl dies nicht so sein sollte, dann wird dieser nicht bei der Ausgabe an den Servo berücksichtigt. \\
\\
Die Handschuhplatine wird über einen Akku versorgt. Deshalb sollte diese Platine nur für die wichtigsten beziehungsweise 
nötigsten Messungen und Berechnungen verwendet werden. Der Rest kann und soll dann lieber auf der per Netzteil betriebenen 
Roboterhandplatine durchgeführt werden, da in diesem Fall keine begrenzte Spannungsversorgung besteht, da kein Akku verwendet 
wird. \\
\\
\textbf{Verzögerung beim Senden} \\
\\
Eine Verzögerung vor dem Senden des ESP32 auf der Senderseite einzubauen war eine 
Idee, an der sehr lange festgehalten wurde. Es schien äußerst sinnvoll, eine 
gewisse selbst gewählte Zeit abzuwarten, bis man dann die Daten von der Sender- zu 
der Empfängerplatine sendet. Dies ist grundsätzlich keine schlechte Idee, allerdings 
konnte erfreulicherweise folgendes festgestellt werden: Nämlich, dass es auch ohne 
Abwarten eines bestimmten Intervalls möglich ist, die Daten zu senden. Der ESP32 auf 
der Empfängerseite kann die Daten genug schnell empfangen, ohne, dass ein bestimmter 
zeitlicher Abstand eingehalten werden muss. Das Beste daran ist, dass auch die 
Verarbeitung der Daten ohne Probleme abgearbeitet werden kann. Dies ist möglich, da 
so wenige Rohdaten, wie möglich, von der Senderseite aus übermittelt werden, sodass 
alles auf der Empfängerseite dann verarbeitet wird. Durch sehr schnelles Senden und 
Empfangen der Daten, kann die schnellstmögliche Bewegung der Roboterhand realisiert werden. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{Sendeverzoegerung}}
		\caption{Beispielhafte Verzögerung vor dem Senden}
		\label{fig:Sendeverzoegerung}			
	\end{center}
\end{figure}
\hfill \break
\textbf{Modus zum Einstellen des minimalen und maximalen Wertes jedes Flexsensors} \\
\\
Es war ursprünglich geplant, dass beim Starten des Programmes am ESP32, der mit der 
Arduino IDE verbunden ist, jeder einzelne Wert der Flexsensoren jeweils eingelesen 
wird. Der große Vorteil davon wäre, dass es bei jedem Start des Programmes, samt 
Serial Monitor in der Arduino IDE, es möglich wäre, dass neue minimale und maximale 
Werte jedes Flexsensors ausgelesen werden. Durch einen festgelegten Befehl, den man 
in den Serial Monitor eingibt, könnte somit beispielsweise ein Wert des Flexsensors 
vom kleinen Finger gemessen werden. Für das Einstellen, welcher Finger und ob der 
minimale oder maximale Wert ausgelesen werden soll, hätte es dann verschiedene 
Befehle gegeben, die man in den Serial Monitor eingegeben hätte. Jeder einzelne 
minimale und maximale Wert hätte somit ausgelesen werden sollen und bis zum Neustart 
des ESP32 erhalten bleiben sollen. \\
Dies stellte sich aber als keine sinnvolle Lösung heraus. Als Erstes ist zu erwähnen, 
dass dieselben Flexsensoren jedes Mal zum Messen des jeweiligen Fingers genutzt 
werden. Es gibt keinen Wechsel dieser, es sei denn, einer geht kaputt. In diesem 
Fall muss für diesen dann manuell der minimale und maximale Wert ausgelesen werden. 
Des Weiteren verändert sich deshalb der minimale und maximale Wert jedes Flexsensors 
nicht. Diese beiden Grenzen werden einmalig manuell ausgelesen und nun im Programm 
als eigene Variable festgelegt. Dies funktioniert dann viel besser. Bei der manuellen 
Messung wurden die minimalen und maximalen Werte öfter ausgelesen. Es wurde dann 
nach unten hin ein kleiner Spielraum gelassen, sowie auch nach oben hin. Das bedeutet, 
dass man beim Abbiegen oder Strecken des Fingers bereits den minimalen oder maximalen 
Wert kurz vor dem kompletten Abbiegen und Strecken erreicht. Dieser Schutzbereich 
garantiert, dass der minimale und maximale Wert immer erreicht werden können und die 
map-Funktion somit immer gute Werte übermitteln kann. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.7}
		{\includegraphics[width=0.8 \linewidth]{maxWert_festlegen}}
		\caption{Beispiel: maximalen Wert über Serial Monitor festlegen (Werte manuell eintragen)}
		\label{fig:maxWert_festlegen}			
	\end{center}
\end{figure}
\hfill \break

\subsubsection{Realisierung und Gliederung}
\paragraph{Realisierung}
\hfill \break
\hfill \break
\begin{figure}[H]
	\begin{center}
		\scalebox{0.5}
		{\includegraphics[width=0.8 \linewidth]{Flussdiagramm_Software_Handschuh}}
		\caption{Flussdiagramm Software Eingabesubsystem}
		\label{fig:Flussdiagramm_Software_Handschuh}			
	\end{center}
\end{figure}
\hfill \break
Der Code der Programmierung des ESP32 wurde in C/C++ geschrieben. Am Anfang werden die einzelnen Werte der Flexsensoren 
ausgelesen, die per Ansteuerung des Multiplexers und des danach sitzenden ADCs bestimmt werden. Die ESP-NOW Verbindung wird 
danach aufgebaut. Diese dient zur drahtlosen Datenübertragung. Wenn die Verbindung mit dem ESP32 der Empfängerseite erfolgreich 
war, dann werden die Daten an die Empfängerplatine (Roboterhand) gesendet. Falls dies allerdings nicht erfolgreich war, dann 
muss eine Fehlersuche durchgeführt werden. Ein oftmals auftretender Grund ist, dass die beiden ESPs zu weit auseinander liegen. 
Falls diese Schritte alle abgearbeitet wurden, dann geht das ganze Prozedere wieder von vorne los. \\
\\
\paragraph{Gliederung}
\hfill \break
\hfill \break
\footnotesize
\begin{lstlisting}
	//I2C & ADC
	#include <Wire.h>
	#include "MCP3X21.h"
	//ESP - Now
	#include <esp_now.h>
	#include <WiFi.h>	
\end{lstlisting}
\hfill \break
\normalsize
Am Anfang des Senderprogramms werden die zu inkludierenden Bibliotheken eingebunden. Diese beinhalten die I2C Kommunikation [siehe \textcolor{blue}{\autoref{chap:I2C Funktionsweise}}] für 
den ADC, die Möglichkeit ESP-NOW zu verwenden, indem auch zusätzlich die Wifi Bibliothek inkludiert wird. \\
\\
\footnotesize
\begin{lstlisting}
	// ADC - Parameter
	const uint8_t address = 0x48;
	const uint16_t ref_voltage = 3300;  // Handschuh
	MCP3021 mcp3021(address);
	
	//Multiplexer Pins
	int EN = 27;
	int A_0 = 26;
	int A1 = 12;
	int A2 = 14;		
\end{lstlisting}
\hfill \break
\normalsize
Danach werden die ADC-Parameter festgelegt, sowie die Ports zur Ansteuerung des Multiplexers. Minimale und maximale 
Widerstandswerte [siehe \textcolor{blue}{Minimale und maximale Grenze in \autoref{par:Wichtige Codezeilen}}] werden festgelegt, damit es bei einer kleinen Toleranz im ganz unteren und oberen Bereich trotzdem immer den 
minimalen oder maximalen Wert erreicht. \\
\\
\footnotesize
\begin{lstlisting}
	uint8_t broadcastAddress[] = { 0x70, 0xB8, 0xF6, 0xC4, 0xEB, 0x2D };  // Empfaenger-Adresse
	
	void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
	  Serial.print("\rEmpfangsstatus : Roboterhand:\t");
	  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "empfangen\n" : "nicht empfangen\n");
	}			
\end{lstlisting}
\hfill \break
\normalsize
Die ESP-NOW Parameter sind noch zu definieren. Also die Empfänger-Adresse, die Nummer des Flexsensors, sowie der Wert. Außerdem 
wird eine Funktion erstellt, die später dazu verwendet wird, um zu überprüfen, ob die Empfängerplatine (Roboterarm) die Daten 
erfolgreich empfangen hat. \\
\\
\footnotesize
\begin{lstlisting}
	// ADC-Setup
	Wire.begin(SDA, SCL);
	mcp3021.init(&Wire);
	pinMode(EN, OUTPUT);
	pinMode(A_0, OUTPUT);
	pinMode(A1, OUTPUT);
	pinMode(A2, OUTPUT);		  
\end{lstlisting}
\hfill \break
\normalsize
Im Setup Teil werden anfangs die Ausgänge festgelegt, die für den ADC notwendig sind, sowie die SDA und SCL. Danach wird das 
ESP-NOW-Setup erstellt. In diesem Bereich werden alle notwendigen Schritte abgearbeitet, sodass man über ESP-NOW erfolgreich 
Daten senden kann. \\
\\
\footnotesize
\begin{lstlisting}
	void loop() {
		for (int i = 1; i <= 5; i++) {
		  selectMuxChannel(i);
	  
		  uint16_t result_mcp = mcp3021.read();
		  value[i - 1] = mcp3021.toVoltage(result_mcp, ref_voltage);	
		}
	}			
\end{lstlisting}
\hfill \break
\normalsize
In der Loop wird dann der Multiplexer angesteuert und immer wieder aufsteigend durchgeschalten. Der Wert, der vom ADC, der
hinter den Multiplexer geschalten wurde, ausgegeben wird, wird dann durch eine Funktion in einen Wert umgerechnet. \\
\\
Dieser Wert wird dann in Form einer Zeichenkette, die im Format \textquote{\$s:n:angepassterWert} geschrieben wird, an den ESP32 der 
Empfängerplatine gesendet (n…Eingang des Multiplexers 0 – 4; angepassterWert…ausgelesener Wert (liegt zwischen Minimum und 
Maximum, das oben festgelegt wurde)) [siehe \textcolor{blue}{Daten in speziellem Format (als String) senden in \autoref{par:Wichtige Codezeilen}}]. Es wird dann noch im Serial Monitor ausgegeben, ob die Senderplatine (Handschuh) die 
Daten erfolgreich senden konnte oder nicht. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{Softwaremap_Handschuh1}}
		\caption{Softwaremap Eingabesubsystem}
		\label{fig:Softwaremap_Handschuh}			
	\end{center}
\end{figure}
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{Softwaremap_Handschuh2}}
		\caption{Softwaremap Eingabesubsystem}
		\label{fig:Softwaremap_Handschuh}			
	\end{center}
\end{figure}

\paragraph{Wichtige Codezeilen}
\label{par:Wichtige Codezeilen}
\hfill \break
\hfill \break
\textbf{Minimale und maximale Grenze} \\
\footnotesize
\begin{lstlisting}
int minWiderstand[5] = {1350, 1520, 1845, 1330, 1750};  
//Daumen, Zeigefinger, Mittelfinger,Ringfinger, kleiner Finger
int maxWiderstand[5] = {1900, 2000, 2135, 1900, 2050};
\end{lstlisting}
\hfill \break
\normalsize
In dem obenstehenden Code kann man zwei erstellte integer Arrays sehen. Eines ist 
für das Speichern des minimalen Widerstandwertes zuständig. Dort werden dann die 
manuell gemessenen Werte eingetragen. Das Array besitzt fünf Variablen. Die Variable 
auf Stelle 0 des minWiderstand Arrays gibt den minimalen Wert des Daumens an. 1 gibt 
den jeweiligen für den Zeigefinger an, 2 gibt den jeweiligen für den Mittelfinger an, 
3 gibt den jeweiligen für den Ringfinger an und 4 gibt den jeweiligen für den 
kleinen Finger an. Somit kann jeder Finger im Array leicht einen neuen Wert 
zugewiesen bekommen und das Programm arbeitet automatisch mit den neu zugewiesenen 
Werten bei erneutem Hochladen auf den ESP32. \\
\\
\textbf{Datenkorrektur mit minimaler und maximaler Grenze} \\
\footnotesize
\begin{lstlisting}
uint16_t result_mcp = mcp3021.read();
value[i - 1] = mcp3021.toVoltage(result_mcp, ref_voltage);

    if (value[i - 1] < minWiderstand[i - 1]) {
      value[i - 1] = minWiderstand[i - 1];
    }
    if (value[i - 1] > maxWiderstand[i - 1]) {
      value[i - 1] = maxWiderstand[i - 1];
    }
    // Anpassen des Wertes
    int angepassterWert = map(value[i - 1], minWiderstand[i - 1],
	maxWiderstand[i - 1], 0, 100);
\end{lstlisting}
\hfill \break
\normalsize
Obenstehend ist nun der Codeabschnitt zu sehen, in welchem der vom ADC verarbeitete 
Wert des Flexsensors von dem ESP32 ausgelesen wird. Dieser wird dann mit dem Wert 
des minimalen und maximalen Widerstands verglichen. Wenn der ausgelesene Widerstandswert 
unter jenem des minimal erlaubten ist, dann wird dieser auf den minimal erlaubten 
gesetzt, um grobe Fehlmessungen zu vermeiden. Das gleiche gilt für den anderen Fall, 
nämlich, wenn der ausgelesene Wert über dem maximal festgelegten liegt. Dann wird 
der ausgelesene auf den maximal zulässigen Wert gesetzt. Dies ist sehr wichtig, da 
ein zu hoher Wert meist indiziert, dass es keine Verbindung zwischen dem Flexsensor 
und den anderen Komponenten, wie dem ADC, mehr besteht. Der Wert ist dann um ein 
Vielfaches höher als gewünscht. Um eine Beschädigung auf Empfängerseite, beziehungsweise 
dem dadurch folglich falschen Ansteuern der Servos zu verhindern, ist diese Maßnahme 
notwendig. Die Servos könnten sich ansonsten zu weit drehen und eine Beschädigung an 
der Mechanik hinterlassen. \\
\\
\textbf{Toleranz zur Verminderung von Schwankungen bei gemessenen Werten} \\
\footnotesize
\begin{lstlisting}
    if(value[i - 1] <= vergleich[i - 1]-10 || value[i-1]
	>= vergleich[i - 1]+10){
      value[i-1];
    } else {
      value[i-1] = vergleich[i-1];
    }
\end{lstlisting}
\hfill \break
\normalsize
In obenstehendem Code wird der Wert des Flexsensors ausgelesen und dann mit dem 
vorherigen Wert verglichen. Man nimmt also eine Toleranz zur Hilfe, um ein starkes 
Zittern der Finger zu verhindern. Es ist wichtig dies zu begrenzen, da man bei jeder 
minimalsten Änderung des Wertes ein extremes Zittern der Finger beziehungsweise der 
Servos auslösen würde, was einen Schaden an der Mechanik auslösen kann (ganzer 
Roboterarm zittert extrem). Es wird also der Wert des Flexsensors ausgelesen und falls 
dieser nicht mindestens um 10 größer oder kleiner als der zuvor gemessene Wert ist, dann 
wird weiterhin der vorherige Wert herangezogen. Erst sobald der momentan gemessene Wert 
den zuletzt gespeicherten um 10 über- oder unterschreitet, wird der aktuell gemessene 
Wert dann an die Empfängerseite übermittelt, ansonsten der alte Wert, der in der 
Variable \textquote{vergleich} gespeichert steht. \\
\\
\textbf{Multiplexer durchschalten} \\
\footnotesize
\begin{lstlisting}
	pinMode(EN, OUTPUT);
	pinMode(A_0, OUTPUT);
	pinMode(A1, OUTPUT);
	pinMode(A2, OUTPUT);
  
  for (int i = 1; i <= 5; i++) {
	  selectMuxChannel(i);
  }
  
  void selectMuxChannel(int channel) {
	if (channel == 1) {
	  digitalWrite(EN, HIGH);
	  digitalWrite(A_0, LOW);
	  digitalWrite(A1, LOW);
	  digitalWrite(A2, LOW);
	} else if (channel == 2) {
	  
	}
  }
\end{lstlisting}
\hfill \break
\normalsize
\begin{figure}[H]
	\begin{center}
		\scalebox{1.1}
		{\includegraphics[width=0.8 \linewidth]{MUX508}}
		\caption{Multiplexer Kanäle (\textcolor{blue}{Quelle: \cite{TexasInstruments}})}
		\label{fig:MUX508}			
	\end{center}
\end{figure}
\hfill \break
In obenstehendem Codeabschnitt wird der Multiplexer richtig eingestellt. Je nach 
Channelnummer wird dann festgelegt, welcher Eingang zum ADC weitergeschalten werden 
soll. Dabei muss die in [\textcolor{blue}{\autoref{fig:MUX508}}] stehende Wahrheitstabelle berücksichtigt werden. 
Durch einige if-Bedingungen kann somit immer sichergestellt werden, dass man 
zu jeder Zeit den richtigen, gewünschten Wert auslesen kann. \\
\\
\textbf{Daten in speziellem Format (als String) senden} \\
\footnotesize
\begin{lstlisting}
String package = "$s:" + String(i-1) + ":" + String(angepassterWert);

Serial.println(package);

esp_err_t result = esp_now_send(broadcastAddress, 
        	   (uint8_t *)package.c_str(), package.length() + 1);
\end{lstlisting}
\hfill \break
\normalsize
\begin{figure}[H]
	\begin{center}
		\scalebox{1.1}
		{\includegraphics[width=0.8 \linewidth]{Paketmuster}}
		\caption{Beispiel: Paket nach bestimmtem Muster senden}
		\label{fig:Paketmuster}			
	\end{center}
\end{figure}
\hfill \break
Obenstehend sieht man nun das Format, in welchem die Daten an die Empfängerseite 
gesendet werden. Es wird ein String geformt. Dieser beginnt mit einem \$. Dies zeigt 
an, dass nun ein \textquote{Befehl} gesendet wird und man diesen verwerten soll. Danach noch 
ein \textquote{s} als Abkürzung für Servo. Der String von der Laufvariable \textquote{i} gibt dann an, 
welcher Wert nun gesendet wird, also beispielsweise \textquote{\$s:1} würde bedeuten, dass nun 
der Wert des Daumens gesendet wird. Der gibt dann eine Trennung an. Auf der 
Empfängerseite muss erkannt werden, wo die Trennung zwischen der Nummer des Fingers 
und des Wertes, zu dem sich der Servo dann hinbewegen soll, liegt. Der String von 
\textquote{angepassterWert} gibt dann den Wert an, den die Servoposition dann endgültig 
erreichen soll. Dabei ist es wichtig, dass dies allerdings auf der Empfängerseite 
dann umgesetzt wird. Auf der Senderseite wird der angepasste Wert zuvor 
möglicherweise durch die Grenzen von minimalem oder maximalem Widerstandswert 
begrenzt und dann noch mit der map-Funktion auf Werte von 0-100 gebracht, da damit 
dann auf der Empfängerseite gearbeitet wird. Gesamt schaut der String für den 
Zeigefinger mit dem angepassten Wert und einem halben Abknicken dieses also wie 
folgt aus: \textquote{\$s:2:50}. Schlussendlich wird dann der gesamte String namens 
\textquote{package} per drahtloser Übertragung über ESP-NOW von der Sender- zu der 
Empfängerplatine gesendet. \\
\\

\newpage
\subsection{Roboterhand [\textcolor{blue}{Al-Maytah}]}

\subsubsection{Grundlegende Vorraussetzungen}
Die Software des Ausgabesbusystems fungiert als Herzstück der mechanischen Roboterhand und legt damit eine Brücke zwischen den auf dem Handschuh erfassten 
humanoiden Bewegungen und der Hand des Roboters. Empfangene Daten, sei es auf drahtlosem oder direktem Wege, müssen interpretiert, analysiert und bei 
Gegebenheit auch korrigiert werden. Die Software soll in der Lage sein, Fehler frühzeitig zu erkennen und entsprechend auf diese zu reagieren. Ein Zittern 
oder ungewünschte Bewegungen der Finger sollen durch diese Algorithmen verhindert werden. Da es zwei Steuerungsmöglichkeiten gibt, per Handschuh oder 
Userinterface, muss automatisch zwischen den gewollten Modis unterschieden werden. Eine intelligente Strommessung der Aktuatoren erweitert dieses 
System und liefert dem Userinterface relevante Daten. \\
\\

\subsubsection{Realisierung: Überblick}
\label{chap:Realisierung: Überblick}
Die Vielfalt der Software fordert Struktur und eine systematische Gliederung. Empfangene Daten durchlaufen mehrere Strecken, an denen diese dann 
verarbeitet werden, um letztlich die gewünschte Bewegung des Fingers umzusetzen. \\
\\

\paragraph{Programmfluss}
\hfill \break
\hfill \break
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{Programmfluss1_Roboterhand}}
		\caption{Flussdiagramm der Software des Ausgabesubsystems}
		\label{fig:Programmfluss1_Roboterhand}		
	\end{center}
\end{figure}
\hfill \break
Das Diagramm in [\textcolor{blue}{\autoref{fig:Programmfluss1_Roboterhand}}] veranschaulicht den Fluss empfangener Daten, diese durchlaufen bedingungsabhängig verschiedene Routen und 
werden auf diesen verarbeitet und interpretiert.
\\
Zu Beginn der Software muss geklärt werden, ob ein seriell verbundenes Userinterface erkannt wurde oder nicht. Ermöglicht wird dies durch eine Anfrage, 
welche von der Roboterhand über die serielle Schnittstelle an das Userinterface gesendet wird. Dies erfolgt durch den String \textquote{\$req.UI}, welcher vom Userinterface als Anweisung zum Antworten 
interpretiert wird. Antwortet das Userinterface wie erwartet, versetzt sich die Roboterhand in den Userinterface-Modus, in der Grafik als \textquote{UI-MODE} 
gekennzeichnet. Erfolgt keine Antwort, konfiguriert sich die Hand ausschließlich darauf, auf Daten welche über das drahtlose ESP-NOW Protokoll empfangen 
werden, zu reagieren. Der Modus, in dem die Hand ist, wird als \textquote{ONLY – GLOVE} in dieser Grafik bezeichnet. \\
Ist die Hand im Userinterface-Modus, ist dennoch eine Kommunikation und Steuerung über die drahtlos verbundene Roboterhand möglich. Die Software 
unterscheidet somit, ob ausschließlich die Hand oder beides, das Unterinterface und die Hand, genutzt wird. Wird beides genutzt, gibt es jedoch auch ein 
Feedback an das Userinterface, beispielsweise Messdaten des Stromflusses. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.4}
		{\includegraphics[width=0.8 \linewidth]{Programmfluss2_Roboterhand}}
		\caption{Route des Only-Glove-Modus im Ausgabesubsystem}
		\label{fig:Programmfluss2_Roboterhand}		
	\end{center}
\end{figure}
\hfill \break
\textbf{ONLY-GLOVE Modus:} \\
\\
Dieser Modus ist im Vergleich zum zweiten einfacher und besteht nur aus einer „Datenroute“. Die über das ESP-NOW Protokoll empfangenen Daten, welche 
die erfassten Fingerpositionen mitteilen, werden auf dieser Route interpretiert und verarbeitet. In [\textcolor{blue}{\autoref{ESP-NOW und Wifi.h}}] wird 
die Anwendung dieser Komponente in dem System detailliert erläutert. \\
Wurden Daten empfangen, wird die Zustandsvariable (data\_received) auf den Wert (true) gesetzt und alle erfassten Daten werden in einem String gespeichert. 
Dieser String wird daraufhin an die Komponente \textquote{interpretiere Daten} vom [\textcolor{blue}{\autoref{par:Parser und Interpretation: drahtloser Datenströme}}] weitergegeben, 
dort werden diese interpretiert. Die extrahierte Fingerposition sowie der Index werden an die Komponente „Datenkorrektur“ übergeben, dort wird anhand 
eines Algorithmus die Sinnhaftigkeit der Daten überprüft. Eine genauere Erläuterung dieses Algorithmus ist in [\textcolor{blue}{\autoref{par:proaktiver Datenkorrekturalgorithmus}}]
zu finden. \\
Wurden die Daten überprüft und je nach Situation auch korrigiert, wird dies an den Block \textquote{Servomapping} übergeben, beschrieben in 
[\textcolor{blue}{\autoref{par:Datenaufbereitung und Anweisung für Servoaktoren}}], dort wird der Positionswert des Fingers noch auf den Motor und seine Zugcharakteristik 
gemappt. Letztlich wird dann die Position an den Motor übergeben. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.9}
		{\includegraphics[width=0.8 \linewidth]{Programmfluss3_Roboterhand}}
		\caption{Route des UI-Mode im Ausgabesubsystem}
		\label{fig:Programmfluss3_Roboterhand}		
	\end{center}
\end{figure}
\hfill \break
\textbf{User Interface Modus:} \\
\\
Dieser Modus ermöglicht es, die Hand über jeweils das Userinterface und auch den Handschuh zu steuern, jedoch getrennt voneinander. Oft wird dieser Modus 
missverstanden, da interpretiert wird, dass er ausschließlich eine Steuerungsmöglichkeit über das Userinterface bietet. \\
Welche Steuerungsmöglichkeit gewählt wird, kann über das Interface per „Switch-Button“ eingestellt werden. Das Userinterface sendet bei der nächsten 
Anfrage von der Roboterhand-Software die Information mit auf welchen Modus der Schalter gestellt wurde. \\
\\
Erhält das Userinterface eine Anfrage, antwortet dieses entsprechend mit - \$answ.here und fügt daraufhin, je nachdem welcher Modus im Userinterface gewählt 
wurde, ein .han für die Steuerung per Handschuh oder ein .ser für eine Steuerung per Interface an diesen String an. \\
Die Antwort vom Userinterface darf ausschließlich \textquote{\$answ.here.ser} oder \textquote{\$answ.here.han} sein. \\
Im Kapitel (8.3.4 Realisierung des Frontends) sind zusätzliche Beschreibungen und Veranschaulichungen des Interfaces zu finden. \\
\\
Wird nun über das Userinterface die Anweisung mitübergeben, dass die Steuerung ausschließlich per Handschuh erfolgt, werden alle empfangenen Befehle vom 
diesem ignoriert, außer die Anweisung die Steuerungsoption zu wechseln. Der Ablauf in dieser Option gleicht dem des im Only-Glove Modus. Die drahtlos 
empfangenen Daten werden interpretiert, daraufhin geprüft und eventuell korrigiert und letztlich gemappt bis sie dann an den Motor übergeben werden. 
Zusätzlich wird, direkt nachdem die Anweisungen an den Motor übergeben wurden, eine Strommessung gestartet – dessen Messergebnisse in der Form einer 
Rückmeldung an das Userinterface über die serielle Schnittstelle gesendet werden. \\
\\
Entscheidet sich der Nutzer nun doch die Roboterhand mit den vom Userinterface gebotenen Bedienungsmöglichkeiten zu steuern, wird ebenso bei der nächsten 
erhaltenen Anfrage diese Änderung übergeben. Wird diese Änderung erkannt, reagiert die Software auf alle vom Interface übergebenen Positionsanweisungen. 
Die Anweisungen landen in erster Hand in der Komponente \textquote{UI-Interpreter}, dort werden diese Anweisungen in ihre Parameter geteilt und das Programm übergibt 
diese an die folgende Komponente des \textquote{Servomappings}. Unmittelbar nachdem die angepassten Werte dem Motor übergeben wurden, wird eine Strommessung von 
der Software aus gestartet. Diese sendet die erfassten Werte des Messfensters an das Userinterface. \\
\\
\paragraph{Effiziente Gliederung essentieller Systemkomponenten}
\label{par:Effiziente Gliederung essentieller Systemkomponenten}
\hfill \break
\hfill \break
Der Programmcode wurde modular in Form einzelner Komponenten realisiert, anhand dessen wird die Möglichkeit geschaffen, diese mehrfach zu verwenden und 
die Komplexität der Software zu minimieren. Die bereits beschriebenen Routen, welche von einem Datenpaket durchlaufen werden, setzen sich aus diesen 
repetitiven Komponenten zusammen. \\
Die einzelnen Komponenten sind getrennt von dem Hauptprogramm und sind somit nicht in diesem vorhanden, jedoch werden sie mit einer .h Datei verknüpft. 
In Form einer Funktion können diese implementiert werden. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1}
		{\includegraphics[width=0.8 \linewidth]{effiziente_Gliederung}}
		\caption{Überblick der Softwarekomponenten}
		\label{fig:effiziente_Gliederung}		
	\end{center}
\end{figure}
\hfill \break
Diese Struktur des Programms bringt zahlreiche Vorteile mit sich, unter anderem, dass sich wiederholende Code-Abschnitte nun anhand der Gliederung mit 
einer Komponente effektiv implementieren lassen. Aber auch die Übersicht spielt eine große Rolle. Das Hauptprogramm ist bereits äußerst überfüllt 
mit Konfigurationsmöglichkeiten für beispielsweise die drahtlose Kommunikation beider Subsysteme. \\
\\

\subsubsection{Kommunikation - Protokolle}
\label{chap:Kommunikation-Protokolle}
Für den Datenaustausch zwischen dem Eingabe- und dem Ausgabesubsystem wird ein einheitliches Protokoll benötigt, welches auch während der Entwicklung 
ohne große Mühe interpretiert und verstanden werden kann. Dabei erleichtert ein einheitliches Protokoll die Realisierung der Komponenten, welche für das 
Interpretieren der Daten zuständig sind. Die Funktionalität beider Parser wird in [\textcolor{blue}{\autoref{par:Parser und Interpretation: drahtloser Datenströme}}]
und [\textcolor{blue}{\autoref{par:Parser und Interpretation: serieller Datenströme}}] erklärt. \\
\\

\paragraph{Drahtlose Kommunikation}
\label{par:Drahtlose Kommunikation}
\hfill \break
\hfill \break
Unter der drahtlosen Kommunikation kann der Datenaustausch zwischen dem Eingabesubsystem und dem Ausgabesubsystem, welches über ESP-NOW erfolgt, verstanden werden. 
Übergeben werden die Datenpakete auf dieser Strecke unidirektional, von dem Eingabesubsystem zu dem Ausgabesubsystem. Ein Datenpaket enthält immer jeweils 
die Position eines Fingers und dessen Index. \\
\\
Beispiel für ein Paket: \\
$\$S:1:50$ \\
\\
\$ ist der primäre Präfix von jedem gesendeten Datenpaket und die Grundvoraussetzung, dass der jeweilige Parser es überhaupt interpretiert. \\
\\
Das folgende \textquote{S} steht in diesem Fall für Servo und deutet daraufhin, dass nun ein variabler Wert folgt, welcher den Index des jeweiligen Motors angibt. 
Dieser kann in diesem Fall von 0-4 variieren und wird mit einem \textquote{:} getrennt. \\
Es ist ein verpflichtender Teil des Protokolls, dass alle variablen Werte auf diese Weise getrennt werden. \\
Nach dem nächsten \textquote{:} muss nun ein Wert zwischen 0 und 100 folgen. Dies ist ein gemappter Wert, welcher von der Software dann auf die Zugcharakteristik 
der Motoren rückgemappt wird, und gibt die Fingerstellung an. \\
\\
Das Paket aus dem Beispiel bedeutet somit: \textquote{Der Servomotor-1 soll seinen Finger auf eine Faltung von 50\% stellen}. \\
\\

\paragraph{Serielle Kommunikation}
\label{par:Serielle Kommunikation}
\hfill \break
\hfill \break
Die serielle Kommunikation beschreibt den Datenverkehr zwischen dem Ausgabesubsystem und dem Userinterface. Aufgrund der vielfältigen Funktionen und auch 
der bidirektionalen Kommunikationslinie muss das Protokoll in mehrere Abschnitte unterteilt werden. Darunter Fingersteuerungen, Gesten und das Feedback. \\
\\
Fingersteuerungen: \\
\\
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{Finger} & \textbf{Index} & \textbf{Wert (in \%)} & \textbf{Format} \\
        \hline
		Daumen & Th\_S & 0 bis 100 & \$Th\_S:Wert \\
		\hline
		Zeigefinger & In\_S & 0 bis 100 & \$In\_S:Wert \\
		\hline
		Mittelfinger & Mi\_S & 0 bis 100 & \$Mi\_S:Wert \\
		\hline
		Ringfinger & Ri\_S & 0 bis 100 & \$Ri\_S:Wert \\
		\hline
		Kleinerfinger & Pi\_S & 0 bis 100 & \$Pi\_S:Wert \\
		\hline
		Alle Finger & Al\_S & 0 bis 100 & \$Al\_S:Wert \\
		\hline
    \end{tabular}
    \label{tab:Fingersteuerung}
\end{table}
\hfill \break
Dies ist ein Überblick des Protokolls welches beschreibt, wie das Userinterface Anweisungen an das Ausgabesubsystem sendet. Das Format ist wie folgt: 
\$FINGERINDEX:WERT, der Index des Fingers übergibt welcher Finger gemeint ist, der Wert besagt auf welche Position sich der Finger stellen soll.
Es gibt auch eine Anweisung, welche alle Finger ansteuert, diese könnte beispielsweise wie folgt aussehen: \$Al\_S:50 und würde die Finger auf 50\% Faltung 
stellen. \\
Neben dem einzelnen Steuern der Finger soll auch die Möglichkeit gegeben werden Gesten an die Hand zu übergeben. \\
\\
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{Geste} & \textbf{Index} & \textbf{Format} & \textbf{Beschreibung} \\
        \hline
		Standby & St\_B & $\$G:V_{1},V_{2},V_{3},V_{4},V_{5}$ & Eine Stellung aller Finger auf 50\% \\
		\hline
		Thumb Up & Th\_B & $\$G:V_{1},V_{2},V_{3},V_{4},V_{5}$ & Die Geste Daumen hoch \\
		\hline
		Peace & Pe\_B & $\$G:V_{1},V_{2},V_{3},V_{4},V_{5}$ & Friedensgeste - Peace \\
		\hline
		Open Hand & Op\_B & $\$G:V_{1},V_{2},V_{3},V_{4},V_{5}$ & Hand öffnen \\
		\hline
		Yeah & Ye\_B & $\$G:V_{1},V_{2},V_{3},V_{4},V_{5}$ & Rockergeste \\
		\hline
		Fist & Fi\_B & $\$G:V_{1},V_{2},V_{3},V_{4},V_{5}$ & Eine faust formen \\
		\hline
    \end{tabular}
    \label{tab:Gestensteuerung}
\end{table}
\hfill \break
Das Format der Geste beschreibt sich wie folgt: $\$G:V_{1},V_{2},V_{3},V_{4},V_{5}$ – Das G sagt dem Parser, dass dies eine Anweisung ist, welche eine 
Geste beschreibt, darauf folgen fünf Werte von 0 bis 100, welche als V1 bis V5 benannt wurden, diese geben die Position in Prozent jedes einzelnen Fingers 
an. \\
\\
Aufgrund des bidirektionalen Datenverkehrs zwischen dem Ausgangssubsystem und dem Userinterface muss nun auch ein Protokoll für das Feedback geschaffen 
werden. \\
An das Userinterface werden bei aktuellstem Entwicklungsstand ausschließlich Daten der Strommessung gesendet. \\
\\
Dies erfolgt in folgendem Format: \\
\$A:INDEX:WERT \\
\\
\textbf{\textquote{A}} bedeutet für das Userinterface, dass nun mit einem Messwert der jeweiligen Ströme gerechnet werden muss. An der Stelle von \textbf{\textquote{INDEX}} ist ein Wert 
von 0 bis 5 erlaubt, welcher angibt zu welchem Motor der Strom zuzuordnen ist. Darauf folgt dann der Messwert \textbf{\textquote{WERT}}. \\
\\

\subsubsection{Individuelle Komponenten}
Wie in [\textcolor{blue}{\autoref{par:Effiziente Gliederung essentieller Systemkomponenten}}] bereits erläutert, setzt sich das Hauptprogramm aus mehreren 
Unterprogrammen zusammen, diese werden als \textquote{Komponente} bezeichnet und bringen zahlreiche Vorteile mit sich. Unter anderem ermöglichen diese, dass 
sich die jeweiligen Routen, die ein Datenpaket im Hauptprogramm durchlaufen kann, aus den einzelnen Komponenten zusammensetzen. Dadurch wird für mehr 
Überblick und Effizienz im Programm des Ausgabesubsystems gesorgt. Unter „individuellen Komponenten“ können eigens entwickelte Unterprogramme verstanden 
werden, welche in diesem Fall Korrekturalgorithmen oder Parser bzw. Interpreter sind. \\
\\

\paragraph{Parser und Interpretation: drahtloser Datenströme}
\label{par:Parser und Interpretation: drahtloser Datenströme}
\hfill \break
\hfill \break
Die Interpretation drahtloser Datenströme findet auf zwei Datenrouten im Programm ihre Anwendung. Einmal im \textquote{ONLY-GLOVE} Modus und auch im Userinterface 
Modus, sofern dieses auch auf den \textquote{GLOVE} Modus gestellt wurde. \\
\\
\footnotesize
\begin{lstlisting}
void interpretiereDaten(rueckgabe_st * rueckgabe, const uint8_t * data, int data_len)
\end{lstlisting}
\hfill \break
\normalsize
Die Systemkomponente erhält drei Parameter, der erste beinhaltet einen Zeiger auf die Struktur $rueckgabe\_st$. Dieser ermöglicht es die später extrahierten 
Daten in einer Struktur zu speichern und diese im Hauptprogramm zu nutzen. Der nächste Parameter beinhaltet einen Zeiger auf den Speicherort des 
empfangenen Datenpakets. Der dritte Parameter gibt die Länge des Datenpakets an. \\
\\
\footnotesize
\begin{lstlisting}
	if (data_len >= 5 && data[0] != '$' && data[1] != 's' && data[2] != ':') {
		rueckgabe->servoIndex = data[3] - '0';
		rueckgabe->grad = atoi((char*)&data[5]);
	}
	else {
		Serial.println("Ungueltige Daten erhalten");
	  return;
	}
\end{lstlisting}
\hfill \break
\normalsize
Das Unterprogramm prüft, ob die Grundbedingung, somit das erforderte Format wie in [\textcolor{blue}{\autoref{par:Drahtlose Kommunikation}}] beschrieben, erfüllt wird. \\
Ist dies der Fall, wird in die Struktur \textquote{Rückgabe} der extrahierte Servoindex und die gesendete Fingerposition gespeichert. \\
\\

\paragraph{Parser und Interpretation: serieller Datenströme}
\label{par:Parser und Interpretation: serieller Datenströme}
\hfill \break
\hfill \break
Sofern das Userinterface angeschlossen ist und eine Steuerung über das Interface vorgibt, kommt diese Komponente zum Einsatz. Ihr Zweck ist es die über 
die serielle Schnittstelle empfangenen Daten zu parsen.  Wie in [\textcolor{blue}{\autoref{par:Serielle Kommunikation}}] beschrieben, hat dieser Parser mit 
Datenpaketen zu rechnen, die umfangreichere Daten enthalten. Zum Beispiel Anweisungen für einzelne Finger, sowie auch Gesten. \\

\paragraph{proaktiver Datenkorrekturalgorithmus}
\label{par:proaktiver Datenkorrekturalgorithmus}
\hfill \break
\hfill \break
Aufgrund der Volatilität der Flex-Sensoren, sowie auch der Verdrahtung, welche bei Bewegung eines Fingers mitbelastet wird, besteht eine Chance, dass es 
zu fehlerhaften Messwerten kommt. Um das Eingabesubsystem möglichst performant und einfach zu halten, wird ein Filter und Prüfsystem auf das 
Ausgabesubsystem ausgelagert. Benötigt wird ein Algorithmus, welcher Fehler erkennt und diese unmittelbar sinnhaft korrigiert. \\
\\
Der proaktive Datenkorrekturalgorithmus basiert auf dem Prinzip der Verzögerung und lässt empfangene Daten einen Prozess durchlaufen, bis diese korrigiert 
und an den Motor übergeben werden. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Median}}
		\caption{Median}
		\label{fig:Median}		
	\end{center}
\end{figure}
\hfill \break
Im Fokus des Algorithmus liegt ein Array, ein zusammenhängender Speicherblock, in diesem werden alle empfangenen Daten chronologisch gespeichert. Jedem 
der fünf Finger ist solch ein Array zugeordnet, welches beispielsweise die letzten zehn Fingerpositionswerte beinhaltet. \\
\\
Parst das Ausgangssubsystem einen neuen Wert, landet dieser im Array des Fingers und alle bereits vorhandenen Werte werden um eine Position nach rechts 
geshiftet. \\
Die Elemente des Arrays haben jeweils einen eigenen Nutzen. Aus dem ersten bis zum siebten Element wird bei jeder Iteration ein Median berechnet und in 
einer externen Variable gespeichert. \\
Das achte Element ist der sogenannte \textquote{SCOPE}, dieser Wert ist die zweite Komponente einer Vergleichsoperation. Das neunte Element ist das letzte des 
Speichers, in diesem befindet sich der am aktuellsten geprüfte und je nach Umständen auch korrigierte Wert. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{0.8}
		{\includegraphics[width=0.8 \linewidth]{Median2}}
		\caption{Median}
		\label{fig:Median2}		
	\end{center}
\end{figure}
\hfill \break
In der [\textcolor{blue}{\autoref{fig:Median2}}] werden mehre Iterationen gezeigt, welche die Fehlererkennung und Eliminierung dieses veranschaulichen. Gezeigt wird hier derselbe 
Speicher, chronologisch wird gezeigt, wie von oben nach unten sich der Speicher pro Iteration ändert. Bei 1. ist zu sehen, dass sich im Scope der Wert 
„25“ befindet. Der berechnete Median beträgt 15. \\
Nun erfolgt eine Vergleichsoperation zwischen dem Wert im Scope und dem Median, überschreitet deren Differenz einen maximalen Grenzwert, muss dieser 
korrigiert werden. Da dies nicht der Fall ist, wird der Wert 25 in der nächsten Iteration auf das Element für den OUTPUT geschoben. \\
\\
Bei der nächsten Iteration, in [\textcolor{blue}{\autoref{fig:Median2}}] an Stelle 2. zu finden, wurden alle Werte nach rechts verschoben. Nun steht der Wert 987 im Scope, bei der 
Vergleichsoperation mit dem Median von 14 ist ersichtlich, dass deren Differenz die maximal konfigurierte Grenze überschreitet. Das Ergebnis: Eine 
Korrektur ist erforderlich. Die nächste Iteration zeigt, dass dieser Wert korrigiert wurde. Der als fehlerhaft identifizierte Wert wurde mit dem 
berechneten Median von 14 ersetzt. \\ 
\\
Anhand der Verzögerung der Elemente, welche im Falle des Beispiels neun Elemente beträgt, ist der Algorithmus in der Lage einen Wert anhand der zukünftigen zu beurteilen. 
Dies verhindert, dass eine rapide Änderung als Fehler identifiziert wird. Aufgrund des hohen Datenflusses sind Verzögerungen von rund zehn Elementen für 
den Gebraucher nicht wahrnehmbar. \\
\\
\paragraph{Datenaufbereitung und Anweisung für Servoaktoren}
\label{par:Datenaufbereitung und Anweisung für Servoaktoren}
\hfill \break
\hfill \break
Jeder der im Projekt verwendeten Servomotoren, der MG995R, hat im Originalzustand einen maximalen Drehwinkel von 180\textdegree - entsprechend auf diesen 
Winkel wurde der Mechanismus, wie in [\textcolor{blue}{\autoref{chap:Entwicklungsstufe: Hybrid}}] näher beschrieben, entworfen. Die Softwareansteuerung ist das letzte 
fehlende Glied, welches dafür sorgt, dass die Finger sich optimal bewegen. \\
Grundsätzlich steht keiner der Finger oder der Daumen in der gleichen Faltstellung, sobald sich der Motor um beispielsweise 30\textdegree dreht. Um ein einheitliches 
System zu schaffen, muss somit ermittelt werden bei welchem Drehwinkel der Finger bereits gestreckt oder in der maximalen Faltposition, sprich vollkommen 
eingefaltet, ist. \\
\\
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{Finger} & \textbf{min. Drehwinkel$_{ausgestreckt}$} & \textbf{max. Drehwinkel$_{max. gefaltet}$} \\
        \hline
		Zeigefinger & 104\textdegree & 0\textdegree \\
		\hline
		Mittelfinger & 140\textdegree & 20\textdegree \\
		\hline
		Ringfinger & 4\textdegree & 108\textdegree \\
		\hline
		Kleinerfinger & 0\textdegree & 108\textdegree \\
		\hline
		Daumen & 52\textdegree & 0\textdegree \\
		\hline
    \end{tabular}
    \label{tab:Servo Drehwinkel}
\end{table}
\hfill \break
Das Eingabesubsystem misst die Stellung der Flex-Sensoren und übersetzt diese dann auf einen Bereich von 0 bis 100\%, das Ausgabesbusystem empfängt 
die prozentuale Faltstellung des Fingers. \\
\\
Die Funktion \textquote{HPCA9685.Servo} erfordert einen anderen Wertebereich als der empfangene Wert von 0 bis 100 und somit müssen diese Werte gemappt werden. \\
\\
\footnotesize
\begin{lstlisting}
int value_out = map(rueckgabe.grad, 0, 100, fingerLimits[rueckgabe.servoIndex][0], 
fingerLimits[rueckgabe.servoIndex][1]);
HCPCA9685.Servo(rueckgabe.servoIndex.);
\end{lstlisting}
\hfill \break
\normalsize

\newpage
\subsection{User Interface [\textcolor{blue}{Szabo}]}
\label{chap:User Interface}

\subsubsection{Grundlegende Vorraussetzungen}
Grundvorraussetzungen die das User-Interface erfüllen muss sind eine Anzeige der aktuellen Griffkraft in kg und eine Anzeige für
den aktuellen Winkel den jeder Servomotor zur Zeit hat. Es ist zwingend notwendig, dass für die Anbindung des GUIs keine technischen
Vorauskenntnisse benötigt werden. Der Verbindungsaufbau muss daher ebenfalls fast von selbst erfolgen. Multiplatform Kompatibilibtät
und eine stabile Laufleistung sollten ebenfalls gegeben sein, um dem Endbenutzer keine Technologie aufzuzwingen, die nicht gewünscht ist.

\subsubsection{Entwicklungsumgebung}

Entschieden haben wir uns für QT. Dies ist eine C++ Entwicklungsumgebungen, die besonders Plattform unabhängig ist. Es sind keine Änderungen
des Queellcodes notwendig, um die Anwedung für MAC, LINUX oder WINDOWS kompatibel zu machen. Dies bezeichnet man auch als source 
code portability. Ebenfalls ist es relativ einfach möglich QML-Interfaces zu erstellen und diese mit umfangreichen Funktionalitäten auszustatten. \\
\\ 
Weitere Eigenschaften von Qt sind:
\begin{itemize}
	\item ein GUI-Designer
	\item ein Debugger
	\item eine 3D-Umgebung um Modelle zu animieren
\end{itemize}

\subsubsection{Konzepte und Überlegungen}
Zunächst musste überlegt werden, wie die grafische Oberfläche aussehen soll. Diese wird nämlich immer vor allen Funktionalitäten 
erstellt, um die anschließende Programmierung übersichtlicher und gegliedert durchführen zu können. Das Erstkonzept sieht folgendermaßen aus:
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{Konzept_UserInterface}}
		\caption{User-Interface Konzept}
		\label{fig:Konzept_UserInterface}				
	\end{center}
\end{figure}
\hfill \break
Zu sehen sind die ersten Überlegungen bezüglich des visuellen Layouts. Auf der rechten Seite des Bildschirms sollen die erforderlichen
Anzeigen für die Parameter der Griffkraft und des Servodrehwinkels abgebildet werden. Links und rechts oben sollen diverse Knöpfe 
und Schieberegler zur weiteren Navigation und Kontrolle des UIs platziert werden. Optional kann noch ein 3D-Modell und Regler für 
die externe Steuerung der Roboterhand hinzugefügt werden. Diese Features sind allerdings nicht gefordert. \\
\\
\subsubsection{Realisierung des Frontends}
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{UI_Oberfläche}}
		\caption{UI Benutzeroberfläche}
		\label{fig:UI_Oberfläche}				
	\end{center}
\end{figure}
\hfill \break
Die Benutzeroberfläche wurde mit der Beschreibungssprache $QML$ programmiert. Mit dieser können sehr einfach Tabellen und benutzerdefinierte
Anordnungen erstellt werden, mit denen folglich ein visuell ansprechendes GUI kreiert werden kann. \\
\\
\subsubsection{Erläuterung der Grafikoberfläche}
\textbf{Einstellung des Steuermodus} \\
Links oben in [\textcolor{blue}{\autoref{fig:UI_Oberfläche}}], sind zwei Elemente zu sehen. Der obere Schalter, ein sogenannter $Toggle-Switch$, ist dafür zuständig
zwischen zwei Kontrolmodi für die Roboterhand zu wechseln. In der gezeigten Stellung, kann das Ausgabesubsystem ausschließlich vom Eingabesubsystem,
mithilfe der angebrachten Flexsensoren gesteuert werden. Wird dieser Schalter betätigt, so kann die Roboterhand nur mehr mit dem User-Interface
bewegt werden. \\
\\
Als erweiterte Funktion für die Zukunft, kann auf der Platine des Eingabesubsystems ein Schalter angebracht werden, der bei Bestätigung
den Steuermodus automatisch umstellt. Hierzu müsste ein kurzer String übergeben werden, der folglich in der QT-Entwicklungsumgebung verarbeitet
und erkannt wird. \\
\\
\textbf{Serial-Port Initialisierung} \\
Direkt unter dem Schalter zur Einstellung des Steuermodus, befindet sich das Eingabefeld für den Serial-Port, der vom Benutzer eingegeben werden muss. Durch 
einen Druck mit der Maus of den $OK-Button$, oder durch ein Drücken der $Enter-Taste$ nach dem Eingeben des Portnamen, wird die Serial-Kommunikation mit der Platine des Ausgabesubsystem 
initialisiert und gestartet. \\
\\
\textbf{Dark-Mode-Switch} \\
In der rechten, oberen Ecke der UI-Oberfläche, befindet sich ein Schalter, mit dem der $Theme$ des Interfaces zwischen $Dark$ und $Light$ gewechselt werden kann. Dies dient ausschließlich der 
visuellen Darstellung und hat keinen Einfluss auf die Funktionalitäten der Anwendung. QT führt die Farbänderung aller Elemente automatisch durch, wodurch Programmieraufwand gespart wird. \\
\\
\textbf{Standby-Switch} \\
Unterhalb des $Dark-Mode-Switches$, befindet sich ein $Standby-Button$. Wird dieser Knopf gedrückt, so bewegen sich alle Finger der Roboterhand in eine halbgeschlossene Stellung. Der Standby-Modus
wird aufgehoben, sobald eine erneute Eingabe erfolgt. Wichtig zu beachten ist allerdings, dass die $Standby-Funktion$ im User-Interface nur verwendet werden kann, wenn der Schalter zum Einstellen des 
Steuermodus auf $UI-Controlled$ gestellt ist. \\
\\
Als zukünftige Verbesserung, könnte, wie auch schon bei der Einstellung des Steuermodus erwähnt, eine Funktion auf der Platine des Eingabesubsystems eingebaut werden, mit der eine $Standby-Condition$
ebenfalls bei der Steuerung mit dem Handschuh erzwungen werden kann. Um nicht zu viele Schalter und Drucktaster auf der Platine verbauen zu müssen, könnte diese Eingabe auch sprachlich realisiert werden. \\
\\
\textbf{Vorgefertigte Posen} \\
\\
Links, mittig im User-Interface, befindet sich eine Tabellenstruktur. Diese ist mit sechs $Buttons$ bestückt, die, bei Betätigung dieser, eine schon vorgefertigte Pose an das Ausgabesubsystem schicken. Diese Handstellung
wird folglich von der Roboterhand eingenommen. \\
\\
Bei jeder, durch das User-Interface, initiierten Bewegung, wird ein $String$ an das Ausgabesubsystem geschickt. Durch dieses, im Vorhinein, festgelegte Protokoll, wird die Servostellung übergeben, wodurch die Finger der
Roboterhand in die gewünschte Position bewegt werden. Das Code des Ausgabesubsystems prüft die ankommenden Werte vor der Bewegung der Motoren auf Plausibilität. \\
\\
\textbf{Finger-Slider} \\
\\
Im untere, linken Bereich des Grafikoberfläche, befindet sich ein $Stack-Layout$, das mit sechs $Slidern$ gefüllt ist. Diese Schieberegler ermöglichen es dem Benutzer jeden Finger der Roboterhand einzeln zu steuern. Dies
funktioniert allerdings wieder nur, wenn der $Steuermodusschalter$ auf $UI-Controlled$ gestellt ist. Mit dem untersten Slider, können auch alle Finger auf einmal bewegt werden. Steuermöglichkeiten wie diese sind vorgesehen, 
damit der Benutzer bei einer möglichen Fehlfunktion des Eingabesubsystems nicht handlungsunfähig wird. Mit dem User-Interface kann somit noch weitergearbeitet werden, wennauch nicht so praktikabel wie per Eingabesubsystem, nämlich dem Handschuh. \\
\\
Die Übergabe der Steuerwerte erfolgt mit einem Protokoll [siehe \textcolor{blue}{\autoref{chap:Kommunikation-Protokolle}}] \\
\\
\textbf{Kontrollanzeigen} \\ 
\\
Im unteren, rechten Bereich von [\textcolor{blue}{\autoref{fig:UI_Oberfläche}}], befinden sich die $Kontrollanzeigen$ für die Servostellungen und die Griffkraft der Roboterhand. Mittels dem Protokoll [siehe \textcolor{blue}{\autoref{chap:Kommunikation-Protokolle}}], werden
die Servowinkelwerte jedes einzelnen Servos an das User-Interface gesendet. Diese werden interpretiert und auf Plausibilität geprüft. Folglich werden die vorherigen Werte, die im Anzeigefenster standen, überschrieben und der neue aktualisierte Wert angezeigt. \\
\\
\textbf{3D-Modell} \\
\\
In der Mitte der Grafikoberfläche, ist die, nicht übersehbare, Darstellung eines echten Handskelets zu sehen. Dieses 3D-Modell wurde in Fusion 360 [\textcolor{blue}{\autoref{chap:Fusion 360}}] erstellt. Jedes einzelne Teil wurde anschließend exportiert und im QT-DesignStudio korrekt positioniert. Wichtig
hierbei ist es zu beachten, dass jedes Hand -und Fingerglied vor dem Export aus Fusion 360 genau an seinem Ursprung liegen muss, da die Beugung der Finger ansonsten nicht korrekt nachgestellt werden kann. Die Drehachse jedes Gelenks, wäre durch einen inkorrekten Export
verschoben.  

\subsubsection{Realisierung des Backends}
Mithilfe von C++, wurde im QT-Designer das Backend programmiert. Dies beinhaltet alle Funktionen die für die Serial-Kommunikation notwendig sind und alle weiteren Funktionalitäten die bei der Benutzerinteraktion gefordert sind. \\
\\
Das Backend ist in ein $Main-Programm$, ein $Header-File$ und ein $Source-File$ gegliedert. Im Header-File $functions.h$, werden alle benötigten Funktionen erstellt. Im Source-File $functions.cpp$, werden die Funktionen anschließend 
ausprogrammiert und miteinander verknüpft. Das Wort $Verknuepfen$, bezieht sich dabei auf das $Signal-Slot-System$ von QT, durch das Funktionen anhand von bestimmten Ereignissen aufgerufen werden können. Im Main-Programm $main.cpp$, werden die $Signals$
und $Slots$ in Abhängigkeit gesetzt und somit die Funktionen des Backends miteinander verknüpft. \\
\\
Der gesamte Code des User-Interface, ist in [\textcolor{blue}{\autoref{chap:Fertigungsunterlagen_Software_Code}}] zu sehen. \\
\\
Bei der Programmierung des Backends, wurden grundlegende C++-Kenntnisse aus dem Unterricht angewendet, die in dieser Dokumentation nicht näher erläutert werden. \\
\\

\newpage
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%==TESTS-UND-MESSUNGEN=====================================================
\section{Tests und Messungen}
\subsection{Widerstandsmessung der Flexsensoren [\textcolor{blue}{Schweitzer}]}
\textbf{Ziel und Sinn der Messung} \\
Jeder Flexsensor besitzt einen bestimmten Widerstandsbereich ($25k\Omega$ bis maximal $125k\Omega$). Laut Datenblatt muss allerdings von einer Toleranz von $+-30\%$ ausgegangen 
werden. Deshalb muss der Widerstandswert jedes einzelnen Flexsensors ausgelesen werden, um festzustellen, wie sehr dieser je Flexsensor variiert. \\
\\
Als Erstes wurde eine Messung jedes einzelnen Flexsensors durchgeführt. Dabei wurden zuerst Punkte auf einem Blatt Papier aufgezeichnet [\textcolor{blue}{\autoref{fig:Punkte_zur_Messung_Flexsensoren}}]. 
Der Flexsensor, der am Anfang, bevor dieser gebogen wird, nur auf der y-Achse liegt, wird dann immer mehr Richtung der jeweilig gekennzeichneten Punkte gebogen. 
Der untere Teil des Flexsensors bleibt stets auf den Koordinaten $(0|0)$, damit der Winkel von der y-Achse zur x-Achse gemessen werden kann. Punkt Nummer 1 liegt 
beispielsweise bei dem Winkel von 17\textdegree. Es wurde von zwei Flexsensoren der sich ändernde Widerstandswert mit dieser Methode ausgemessen. Man hat am Ende also sieben 
Widerstandswerte (Winkel von 0\textdegree, 17\textdegree, 27\textdegree, 40\textdegree, 53\textdegree, 65\textdegree, 76\textdegree, 90\textdegree) bei jedem der beiden Flexsensoren gemessen [siehe \textcolor{blue}{\autoref{tab:Messergebnisse_Papier}}]. \\
Man kann klar erkennen, dass die Widerstandswerte von Flexsensor 1 klar von jenen von Flexsensor 2 abweichen, gerade immer höheren Bereich des Biegungsgrades. 
Flexsensor 1 erreicht bei einer Biegung von 90\textdegree einen maximalen Widerstandswert von $110k\Omega$, bei Flexsensor 2 sind es nur $45k\Omega$. Des Weiteren konnte festgestellt 
werden, dass sich der Wert, aufgrund der Befestigung am Handschuh, welche keine stabile Position garantiert, teils bei jeder getätigten Messung wieder etwas verändert hat. \\
\\
\begin{figure}[H]
	\begin{center}
		\scalebox{1.0}
		{\includegraphics[width=0.8 \linewidth]{Punkte_zur_Messung_Flexsensoren}}
		\caption{Punkte zur Messung (Winkel)}
		\label{fig:Punkte_zur_Messung_Flexsensoren}				
	\end{center}
\end{figure}
\hfill \break

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        \multicolumn{2}{|c|}{\textbf{Flexsensor 1}} & \multicolumn{2}{c|}{\textbf{Flexsensor 2}} \\
        \hline
        Winkel (\textdegree) & Widerstand ($k\Omega$) & Winkel (\textdegree) & Widerstand ($k\Omega$) \\
        \hline
        0 & 44 & 0 & 25 \\
		17 & 55 & 17 & 28 \\
		27 & 65 & 27 & 31 \\
		40 & 75 & 40 & 36 \\
		53 & 85 & 53 & 39 \\
		65 & 92 & 65 & 41 \\
		76 & 102 & 76 & 42 \\
		90 & 110 & 90 & 45 \\
        \hline
    \end{tabular}
    \caption{Messergebnisse am Papier}
    \label{tab:Messergebnisse_Papier}
\end{table}
\hfill \break
Als Zweites wurden die ausgemessenen Werte von Flexsensor 2 [\textcolor{blue}{\autoref{tab:Messergebnisse_Papier}}] übernommen. Zusätzlich wurde nun der Flexsensor 2 auf den 
Handschuh am Bereich des Zeigefingers der rechten Hand montiert. Die in [\textcolor{blue}{\autoref{tab:Messergebnisse_Handschuh}}] zu sehende Einstellung (x/8), gibt den in der linken 
Tabelle nebenstehenden Winkel jeweils dazu an. Das bedeutet, dass man den Finger ungefähr bei der Einstellung von 2 um 17° abgebogen hat. Die nachfolgenden 
Abbildungen zeigen das unterschiedlich starke Abbiegen des Zeigefingers je Einstellung (1-8). \\
\\
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        \multicolumn{2}{|c|}{\textbf{Flexsensor 2 (Papier)}} & \multicolumn{2}{c|}{\textbf{Flexsensor 2 (Handschuh)}} \\
        \hline
        Winkel (\textdegree) & Widerstand ($k\Omega$) & Einstellung (x/8) & Widerstand ($k\Omega$) \\
        \hline
        0 & 25 & 1 & 25 \\
		17 & 28 & 2 & 27 \\
		27 & 31 & 3 & 29 \\
		40 & 36 & 4 & 31 \\
		53 & 39 & 5 & 33 \\
		65 & 41 & 6 & 35 \\
		76 & 42 & 7 & 37 \\
		90 & 45 & 8 & 39 \\
        \hline
    \end{tabular}
    \caption{Messergebnisse am Handschuh}
    \label{tab:Messergebnisse_Handschuh}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \begin{minipage}[c]{0.4\linewidth}
            \includegraphics[width=\linewidth]{Einstellung_1}
            \captionof{figure}{Einstellung 1}
        \end{minipage}
        &
        \begin{minipage}[c]{0.4\linewidth}
            \includegraphics[width=\linewidth]{Einstellung_2}
            \captionof{figure}{Einstellung 2}
        \end{minipage} \\
		\begin{minipage}[c]{0.4\linewidth}
            \includegraphics[width=\linewidth]{Einstellung_3}
            \captionof{figure}{Einstellung 3}
        \end{minipage}
        &
        \begin{minipage}[c]{0.4\linewidth}
            \includegraphics[width=\linewidth]{Einstellung_4}
            \captionof{figure}{Einstellung 4}
        \end{minipage} \\
		\begin{minipage}[c]{0.4\linewidth}
            \includegraphics[width=\linewidth]{Einstellung_5}
            \captionof{figure}{Einstellung 5}
        \end{minipage}
        &
        \begin{minipage}[c]{0.4\linewidth}
            \includegraphics[width=\linewidth]{Einstellung_6}
            \captionof{figure}{Einstellung 6}
        \end{minipage} \\
		\begin{minipage}[c]{0.4\linewidth}
            \includegraphics[width=\linewidth]{Einstellung_7}
            \captionof{figure}{Einstellung 7}
        \end{minipage}
        &
        \begin{minipage}[c]{0.4\linewidth}
            \includegraphics[width=\linewidth]{Einstellung_8}
            \captionof{figure}{Einstellung 8}
        \end{minipage} \\
		\hline
	\end{tabular}
    \caption{Messpositionen mit dem Handschuh}
    \label{tab:Messposition mit dem Handschuh}
\end{table}

\newpage
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%==Zusammenfassung=========================================================
\section{Ergebnisse und Erkenntisse}
\label{chap:Ergebnisse und Erkenntisse}
\subsection{Mechanik [\textcolor{blue}{Al-Maytah}]}

In der Entwicklungsphase der mechanischen Komponenten des Gesamtsystems kam es zu vielen Höhen und Tiefen.
Dieser Prozess war lange geprägt von einer Serie an Rückschlägen, doch aufgrund der daraus entstandenen
Erkenntisse und Fortschritte konnte die Hand und die zugehörige Steuerungskomponente zuverlässig verwirklicht werden. \\
\\
Während der gesamten Entwicklung der Prototypen war der 3D-Druck äußerst hilfreich und der Grundstein, welcher uns
überhaupt die Chance geboten hat ausgiebige Modelle und deren Verbesserungen zu entwerfen. Eine der wichtigsten Erkenntisse
ist es, wie wichtig das Miteinbeziehen von Toleranzen des Druckers beim Entwerfen eines Modells sind. Aber auch der Umgang mit der CAD-Software Fusion 360 
wurde von einem Entwurf zum Folgendem immer fortschrittlicher und professioneller. Dadurch konnten Hürden beim Entwerfen einer besseren Version der 
Hand stets überwunden werden. \\
\\
Angefangen hat die Entwicklungsphase mit einem simplen Entwurf des Faltmechanismus, dabei gab es den ersten sogenannten \textquote{Proof of concept}, welcher gezeigt hat, dass durch das Ziehen an einer Schnur das Falten eines Fingers bewirkt werden kann. \\
\\
Daraufhin folgte die Entwicklungsstufe \textquote{initial}, in der es sämtliche Probleme beim Abrollen des Fingers gab
und eine gleichmäßige Faltung aufgrund einer Fehlkonstruktion nicht möglich war. Auch war Reibung eines
der Probleme, welche dazu geführt haben, dass mehr Kraft beim Ziehen notwendig war. \\
\\
Man muss nicht immer das Rad neu erfinden, sondern eher neu ausrichten. In der Entwicklungsstufe \textquote{InMoov} wurde eine bereits fertige Hand, in der Hoffnung aus ihrem Entwurf zu lernen, realisiert. Jedoch gab es das Problem, dass diese Hand nicht zwingend dafür entworfen wurde um kräftig zu sein, sondern bei dieser mehr auf das Äußere, das Oberflächliche, geachtet wurde. Somit kam es aufgrund unserer Belastungstests zu sämtlichen Schäden, wie Rissen und Brüchen am Modell der Hand und ihrer Mechanik, sowie auch ständiger Reibung der Schnur an Kanten. \\
\\
Da Reibung, Risse und Brüche am Modell zum Problem wurden und es an Griff fehlte, gab es die Idee, eine Hand aus Silikon zu entwerfen, welche jedoch nicht lange stand hielt. Neben dem hohen Zeit- und Kostenaufwand kam es dazu, dass dieses Konzept verworfen werden musste. Dies lag daran, dass das Gießen einer gesamten Hand nicht möglich war. Es kam während des Gusses ständig dazu, dass Silikon aus der Gussform ausgelaufen ist und dies konnte nicht behoben werden. 
Dennoch gab es einen positiven Aspekt dieser Phase der Entwicklung, denn während zahlreicher gescheiteter Versuche eine Hand zu gießen, wurde einiges über den Silikonguss gelernt, sogar über das Silikon an sich. Dies war für die abschließende Entwicklungsstufe äußerst hilfreich. \\
\\
In der letzten Entwicklungsstufe, welche den Namen \textquote{Hybrid} trägt, konnten alle aus Rückschlägen und Fehlern gewonnene Erkenntnisse und Learnings integriert werden. Der unzuverlässige Mechanismus der vorherigen Stufen wurde durch ein fortgeschrittenes Konstrukt ersetzt, was zu mehr Zugkraft, Präzision sowie Stabilität führte. Besonders hilfreich waren beim Entwurf dieses Modells das gewonne Wissen in CAD Programmen und beim 3D-Druck im Laufe des Projekts. Da es nun Erfahrung im Umgang mit Silikon gab wurden auch Fingerkuppen aus diesem Material gefertigt um für mehr Griff in der Stufe \textquote{Hybrid} zu sorgen. \\
\\
Eine Besonderheit des Entwicklungsprozesses war es mitzuerleben, dass Rückschläge zu neuen Erkenntnissen und damit zu Fortschritten geführt haben. Bemerkenswert war auch, dass während des Prozesses Fähigkeiten im Umgang mit CAD-Programmen, dem 3D-Druck und im Bereich des Handwerks erweitert oder erlernt werden konnten. \\
\\
\subsection{Hardware [\textcolor{blue}{Szabo}]}
In diesem Punkt werden alle, im Laufe der Projektentwicklung gewonnen, Erkenntnisse erläutert. Dazu zählen nicht nur die
positiven Erfolge, sondern auch die negativen Aspekte und Rückschläge, die wir erfahren haben. \\
\\
Zunächst wurde ein erstes Konzept entwickelt. In Zuge dessen, wurde hauptsächlich recherchiert und überlegt, wie die 
einzelnen Ideen zum Bau einer bionischen Hand umgesetzt werden können. Dies betrifft die Messung der Fingerbeugung durch geeignete Sensorik, 
die Datenübertragung und die Aktorik in Form von Motoren. \\
\\
Anfangs war der Fortschritt sehr groß. Jede Woche wurden neue Konzepte getestet und durchdacht. Es war sehr schnell klar, dass wir Flexsensoren
als Sensorik verwenden wollen und somit konnte der Schaltungsentwurf beginnen. Entscheidungsfreudigkeit am Anfang des Projekts zahlt sich im Laufe der Entwicklung aus,
da nicht unnötige Zeit verschwendet wird unnütze und nicht funktionierende Konzepte durchzusetzen. Dieer Fehler wurde bei uns vermieden und somit hatten wir schon sehr früh 
Schaltungen und Testplatinen. Durch diese konnten wir Verbesserungen vornehmen und Fehler frühzeitig erkennen. \\
\\
Frühzeitige Fehler bei der Testschaltung des Eingabesubsystems waren keine Seltenheit. Rund ein -bis zwei Wochen wurden damit verbracht die Platine funktionsfähig zu machen, da 
durch die Schuliinterne Fertigung einige Fehler beim Fräsen der Leiterbahnen aufgetreten sind. Nicht nur Probleme bei der Fertigung, sondern auch beim Anlöten der Bauteile stoppten 
den Entwicklungsprozess kurzzeitig. Nachdem mit Jumper-Kabeln alle kaputten elektrischen Leitungen überbrückt worden sind, konnte die Schaltung auf Funktionalität durchgemessen werden.
Diese Messungen verliefen, nach der Behebung aller Leitungsdefekte, reibungslos und das Konzept der Messschaltung wurde bestätigt. Dies gab uns die Sicherheit nun die zweite Version der
Platine für das Eingabesubsystem zu entwerfen und extern, bei der Firma JLCPCB, fertigen zu lassen. \\
\\
Durch diese relativ gut verlaufene Phase der Schaltungsentwicklung, hat sich gezeigt, dass es sich auszahlt im Vorhinein zu planen, Schaltungen zu simulieren und zu berechnen und das initiale Konzept mehrmals durchzudenken. \\
\\
Ein sehr ähnlicher Entwicklungsprozess kam bei der Fertigung der Platine für das Ausgabesubsystem zu tragen. Nach dem Entschluss Servomotoren für die Ansteuerung der Roboterfinger zu verwenden, begann das erneute Überlegen. Diesmal
musste allerdings der beste und einfachste Weg für eine Motoransteuerung, bestenfalls mit einer Griffkraftüberwachung, konzeptioniert werden. Die gewählte Schaltung wurde erneut simuliert und auf einem Steckbrett aufgebaut. 
Danach wurde in der Schule eine Testplatine gefertigt und bestückt. Erneut sind allerdings die gleichen Probleme wie bei der Entwicklung der Schaltung für das Eingabesubsystem aufgetreten. Leiterbahnen haben sich beim Löten der 
eletronischen Bauteile gelöst, weshalb Jumper-Kabel verwendet werden mussten. Nach der Überbrückung der kaputten Leitungen, wurde die Platine erneut durchgemessen und ein Betrieb simuliert. Dadurch konnten wir die korrekte Funktion der 
Schaltung nachweisen und mit dem Design der zweiten Platine für das Ausgabesubsystem beginnen. Diese wurde ebenfalls bei der Firma JLCPCB bestellt. \\
\\
Erneut war zu erkennen, dass sich die Mühe am Anfang der Entwicklung ausgezahlt hat um mögliche Probleme, die später im Entwicklungsprozess auftreten könnten, auszuschließen. \\
\\

\subsection{Software}

\subsubsection{Eingabesubsystem [\textcolor{blue}{Schweitzer}]}
Als Erstes wurde ein Konzept entwickelt, was das Eingabesubsystem alles machen 
soll. Es wurden etliche Überlegungen getroffen, inwiefern welche Funktionen 
implementiert werden sollen oder nicht, um eine zuverlässige Steuerung des 
Ausgabesubsystems zu ermöglichen. Nachdem das Grundkonzept für die Hardware 
fertiggestellt worden war, konnte mit der detaillierten Planung für das 
Eingabesubsystem angefangen werden. \\
\\
Anfangs waren zu viele verschiedene Funktionen, die das Eingabesubsystem 
unterstützen soll, angedacht gewesen. Es wurde die ersten Wochen mit sehr 
optimistischen Zügen in die Zukunft geschaut. Es stellte sich jedoch nach 
nicht allzu langer Zeit heraus, dass es nicht möglich ist, all diese 
Funktionalitäten zu integrieren. Deshalb wurde ein erneut ein Konzept erstellt, 
in dem die wichtigsten davon vorhanden waren. \\
\\ 
Das Konzept sah wie folgt aus: Es soll über einen ESP32 jeder einzelne 
Widerstandswert der Flexsensoren beinahe pausenlos ausgelesen werden. 
Diese Werte sollen dann verarbeitet und, falls die durch den ADC umgewandelten
Werte außerhalb des festgelegten Wertebereichs liegen sollten, korrigiert 
werden. \\
\\
Mit der Überlegung, welche Datenübertragung gewählt werden soll, wurde 
ebenfalls Zeit verbracht. Die zu Beginn angestrebte Übertragung per Bluetooth 
wurde schlussendlich verworfen. Schlussendlich wird diese nun per ESP-NOW 
Protokoll (ähnlich zu Wifi) durchgeführt. Einige Wochen vergingen, bis klar 
war, inwiefern die Datenübertragung per ESP-NOW realisiert werden kann. Als 
es aber dann möglich war, einen stabilen Datenaustausch zwischen Eingabe- und 
Ausgabesubsystem herzustellen, wurde dieser Schritt, nicht Bluetooth zu 
verwenden, als der absolut richtige angesehen. \\
\\
Nachdem das Auslesen der Daten der Flexsensoren vom Eingabesubsystem 
erfolgreich durchgeführt werden konnte, wurde eine Datenkorrektur angestrebt. 
Zwischendurch wurde angedacht, keine Korrektur durchzuführen, aber 
schlussendlich wurde eine Schutzmaßnahme eingeführt, um das Zittern der Finger 
des Ausgabesubsystems zu verringern, indem die Werte, die aus dem ADC 
ausgelesen werden, nur dann gesendet werden, wenn diese um +-10 vom zuletzt 
gesendeten Wert abweichen. Durch diese Maßnahme konnte eine deutliche 
Verbesserung der natürlich aussehenden Bewegung der Roboterhand vom 
Ausgabesubsystem sichergestellt werden. Schäden an der Mechanik konnten hiermit vermieden werden. \\
\\
Die Arduino IDE hat sich durchwegs als passende Entwicklungsumgebung bewährt. 
Sie ermöglicht es, den Code problemlos zu interpretieren, zu formatieren, zu 
kompilieren und auf den ESP32 hochzuladen. Allerdings kann es zu einem Problem 
mit der Arduino IDE 2 kommen, da sie einen bestimmten Codeabschnitt nicht 
korrekt interpretieren kann. Dies liegt an den Unterschieden in den Bibliotheken 
im Vergleich zur Arduino IDE 1. Durch Anpassungen am Code kann dieses Problem 
jedoch gelöst werden, sodass beide Versionen der Arduino IDE genutzt werden 
können. \\
\\
Im Verlauf des Entwicklungsprozesses können immer wieder Rückschläge auftreten, 
unabhängig von deren Ursache. Oft wird die Komplexität bei der Umsetzung 
bestimmter Funktionen unterschätzt und im Laufe der Zeit muss erkannt werden, 
dass entweder ein neues Konzept entwickelt oder mehr Zeit in die Realisierung 
investiert werden muss. \\
\\
In der Regel erfordert die Umsetzung verschiedener Softwareblöcke mehr Zeit, 
als ursprünglich angenommen. Der Code funktioniert meist erst nach mehreren 
Überarbeitungen so, wie es sich von Anfang an gewünscht wurde. Dennoch können 
zahlreiche neue Bereiche im Softwarebereich erschlossen werden, einschließlich 
der Ansteuerung und Datenverarbeitung. \\
\\
Letztendlich erweisen sich die Überlegungen, die bereits am Anfang angestellt 
wurden, als sinnvoll. Dies führt dazu, dass nicht alle Überlegungen 
zwischendurch verworfen werden müssen. \\
\\
\subsubsection{Ausgabesubsystem [\textcolor{blue}{Al-Maytah}]}

Die Software des Ausgabesubsystems, welche dessen intelligente Komponente ist, 
hat gezeigt von welcher Bedeutung Ordnung während eines langfristigen Entwicklungsprozesses ist. 
Dass der entwickelte Code funktioniert, ist die Grundvoraussetzung für dieses System, 
doch ohne die entsprechende Organisation und Ordnung rückt dieser Aspekt schnell 
in den Hintergrund. \\
\\
Somit wurde recht früh in der Entwicklungsphase bemerkt, dass es an Struktur 
im Bereich der Software fehlt. Zahlreiche Maßnahmen wurden ergriffen um dem 
entgegen zu wirken. Zu einem eine bessere und einheitliche Organisation des Eingabe- sowie 
Ausgabesubsystems im GitHub-Repository und das Einführen gewisser Entwicklungsstufen und Branchen. 
Wodurch es immer eine Version gab die getestet ist und zuverlässig funktioniert, sowie auch eine 
Entwickler-Version welche unter ständiger Bearbeitung stand. \\
\\
Im Laufe der Zeit hat sich ergeben, dass es zu unübersichtlich ist, den gesamten Code in eine einzelne
Datei zu schreiben. Demnach wurde das Gesamtsystem in einzelne Komponenten gegliedert. 
die Software unterteilt sich somit in Komponenten, welche im Hauptprogramm integriert werden.
Dies hat dazu geführt, dass die Wartung und Entwicklung der Software rapide voran ging.
Fehler wurden schneller entdeckt, oder es konnten fehlerhafte Code-Abschnitte einfach ausgetauscht werden. \\
\\
Als Beispiel wurde der Datenkorrekturalgorithmus extern entwickelt und in einem eigenem Sketch ausgiebig getestet.
Hat dieser funktioniert, wurde er als Komponente in das Hauptprogramm eingebunden.
Meist waren wenige Tests notwendig bis die Implementierung vollendet war. \\
\\
Äußerst lehrreich war die drahtlose Übertragung der Daten zwischen dem Eingabe- und Ausgabesubsystem.
Diese hat für eine lange Zeit nicht funktioniert und war auch nicht äußerst stabil. 
Als die Datenübertragung erstmals möglich war, konnte die Hand mit dem Handschuh
das erste Mal bedient werden. \\
Dadurch wurde ein Zittern der Hand erkannt, welche softwareseitig behoben wurde. \\
\\
Im Großen und Ganzen hat sich gezeigt, dass Software mehr als nur Programmieren ist. Ordnung 
und eine entsprechende Organisation sind ein großer Bestandteil des Endprodukts und
haben vieles ermöglicht. \\
\\

\subsection{Gesamtintegration [\textcolor{blue}{Schweitzer}]}
In diesem Abschnitt reflektieren wir die Vielfalt an Erkenntnissen, die wir 
während der Projektentwicklung gesammelt haben. Dabei nehmen wir sowohl die 
positiven Errungenschaften als auch die Herausforderungen und Rückschläge in 
den Blick, die wir erlebt haben. \\
\\
Zunächst möchten wir die Bedeutung eines detaillierten Konzepts hervorheben. 
Dieses dient als solide Grundlage, auf die wir im weiteren Verlauf zurückgreifen 
können. Es ermöglicht uns, eine erneute Gesamtüberlegung des Projekts nach 
einigen Wochen zu vermeiden, obwohl es natürlich unmöglich ist, alle zukünftigen 
Probleme im Voraus zu antizipieren. \\
\\
Unser Hauptziel bestand darin, ein umfassendes Konzept für die Integration 
aller Komponenten zu entwickeln. Im Klartext bedeutet dies, dass Hardware, 
Software und Mechanik am Ende harmonisch zusammenarbeiten und ein funktionierendes 
Gesamtsystem bilden sollten. In unserem Konzept haben wir von Anfang an 
festgelegt, was wir grundsätzlich entwickeln wollen. \\
\\
Nachdem wir uns darauf geeinigt hatten, einen Roboterarm mittels eines 
Handschuhs zu steuern, konnten wir uns den Details zuwenden. Es stand schnell 
fest, dass wir die Position der Fingergelenke mithilfe von Flexsensoren 
erfassen würden, die auf der Außenseite der Finger angebracht sind. \\
\\
Ebenso war schnell klar, dass wir den Roboterarm mit einem 3D-Drucker 
herstellen würden. Es gibt schlichtweg keine einfachere Methode, um in 
kürzester Zeit manuell mit einer Modellierungssoftware Fusion 360 [siehe \textcolor{blue}{\autoref{chap:Fusion 360}}] erstellte 
Teile zu produzieren. \\
\\
Die Entwicklung der Hardware konnte beginnen, sobald wir festgelegt hatten, 
welche elektronischen Bauteile zum Einsatz kommen sollten. Jede einzelne 
Verbindung, die wir in der Elektronik-Design-Automatisierung Software KiCad [siehe \textcolor{blue}{\autoref{chap:KiCad}}]
erstellt haben, wurde sorgfältig durchdacht. Gleiches gilt für die Anordnung 
der Bauteile, um mögliche Störungen verschiedener Signale zu vermeiden. \\
\\
Die Softwareentwicklung wurde von Anfang an mithilfe der Entwicklungsumgebung Arduio IDE
[siehe \textcolor{blue}{\autoref{chap:Arduino IDE}}] durchgeführt. Der Mikrocontroller ESP32, der eine zentrale Rolle 
in unserem Projekt spielt, wurde von Anfang an für das Auslesen, Verarbeiten 
und Senden der Daten ausgewählt. \\
\\
Nachdem wir unseren ersten 3D-Druck eines Open-Source Projekts der Roboterhand 
gedruckt hatten, konnten wir uns überlegen, inwiefern wir die Finger bewegen 
können und wie dies realisiert werden kann. Angelschnüre wurden als Zugmechanismus 
verwendet, welche durch jeden der einzelnen 3D-gedruckten Fingern verliefen 
und dann jeweils an einem Servomotor befestigt wurden. Mit der Zeit zeigte 
sich, dass die Angelschnur allerdings immer mehr an Stabilität verliert und 
abreißt oder aber auch, dass sie die 3D-gedruckten Teile einschneidet, was 
wiederum die Mechanik großflächig beschädigt. \\
\\
Die Platinen waren nicht immer fehlerfrei, durch kreative Ansätze konnte 
allerdings jedes Mal eine Lösung gefunden werden, wie diese doch verwendet 
werden können, wie beispielsweise das Setzen von Drahtbrücken, falls 
Leiterbahnen beschädigt waren. \\
\\
Die Software war anfangs sehr fehlerbehaftet und hat zu ungewünschten 
Situationen geführt. Es musste überlegt werden, wie weit sich beispielsweise 
die Servos drehen dürfen, sodass die Mechanik keinen Schaden davonträgt. Dies 
war nicht immer leicht, allerdings konnten diese Probleme schlussendlich 
behoben werden, sodass nun alle Funktionen der Software gezielt an die Hardware 
und die Mechanik angepasst worden sind. \\
\\
Schlussendlich konnten wir eine harmonische Interaktion zwischen Hardware, 
Software und Mechanik erreichen. Die Software liest die Werte der Flexsensoren 
aus, der Code auf dem ESP32 interpretiert und überprüft diese Daten und leitet 
sie vom Eingabesystem zum Ausgabesystem weiter. Das Ausgabesystem interpretiert 
die empfangenen Daten und verarbeitet sie entsprechend. Letztendlich werden 
die Servomotoren mit diesen Daten angesteuert. Im Code sind Schutzgrenzen eingebaut, 
um ein Überdrehen der Servos zu verhindern. \\
\\
Die Hardware, einschließlich der Messschaltungen, funktioniert einwandfrei und 
erfüllt alle Anforderungen. In der Endversion gibt es keine Störungen bei den 
einzelnen Signalen mehr. Die Mechanik wurde mehrfach überarbeitet, insbesondere 
die Integration der Servos. Durch die Verwendung von Metallhülsen an den erforderlichen 
Stellen schneiden die Angelschnüre nicht mehr in den 3D-Druck ein. \\
\\
Insgesamt funktioniert die Steuerung sowohl auf der Seite des Eingabesystems 
als auch die Ausführung am Ausgabesystem sehr gut. Es ist uns gelungen, eine 
sehr natürliche Bewegung der menschlichen Hand nachzuahmen. \\
\\
Während der gesamten Entwicklungsphase konnten wir zahlreiche Erfahrungen 
sammeln. Es gab viele Herausforderungen, aber auch daraus resultierende 
Erfolge waren keine Seltenheit. Oft waren wir etwas zu optimistisch, aber 
letztendlich konnten wir alle Meilensteine rechtzeitig erreichen. Mit dem 
Wissen, das wir während der gesamten Entwicklungsphase gesammelt haben, können
wir nun effizienter an ähnlichen Projekten arbeiten. \\
\\

\newpage
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%==AUSBLICK================================================================
\section{Ausblick}
\label{chap:Ausblick}

Das Projekt bietet eine gute Basis für zukünftige, aufbauende Erweiterungen. Einige Änderungs -oder Verbesserungsvorschläge des Gesamtdesigns sind in Folge beschrieben. \\
\\
\textbf{Handgelenksrotation} \\
\\
Auf der Platine des Eingabesystems könnte eine Steuerung für einen Gyroskopsensor integriert werden. 
Dieser Sensor, am Handschuh befestigt, wäre in der Lage, die Drehbewegungen des Handgelenks zu 
erfassen. Die erfassten Daten könnten dann durch eine speziell dafür entwickelte Software auf der 
Platine ausgelesen und verarbeitet werden. Dies würde es ermöglichen, nicht nur die Finger des 
Roboterarms zu bewegen, sondern auch eine Rotation des Handgelenks zu realisieren. Ein solches 
Feature würde den zusätzlichen Vorteil bieten, dass Objekte aus verschiedenen Winkeln gegriffen 
werden könnten. \\
\\
\textbf{Taktile Sensoren an den Fingerspitzen} \\
\\
Taktile Sensoren an den Fingerspitzen der Roboterhand könnten den auf jeden einzelnen Finger 
ausgeübten Druck messen. Durch eine spezielle Messschaltung könnten die Daten dieser Sensoren 
ausgelesen und verarbeitet werden. Dies würde es ermöglichen, zu bestimmen, ob ein bestimmter 
Druckpunkt erreicht ist, bei dem ein gehaltenes Objekt beschädigt oder sogar zerstört werden könnte. 
Bei einem zu hohen gemessenen Druck (der je nach Objekt variieren und möglicherweise manuell 
eingestellt werden könnte) könnte eine Sicherheitsfunktion in der Software aktiviert werden. Diese 
würde die Roboterhand in ihrer aktuellen Position verharren lassen und keine zusätzliche Kraft auf 
das Objekt ausüben. \\
\\
\textbf{Akku auf Platine des Eingabesubsystems} \\
\\
Es wurde bereits ein Akku für die Platine des Eingabesubsystems eingeplant. Dieser ist auch bereits 
in der neuesten Version der Platine vorhanden und sollte auch funktionieren. Damit wäre auch ein 
Betrieb dieser ohne ein Netzteil möglich. Das hat den Vorteil, dass man mit dem Handschuh nicht 
mehr von der Anbindung des Netzteils an die Platine abhängig und kann sich schlussfolgernd leichter 
durch den Raum bewegen. Die Daten werden genauso wie zuvor übertragen, da alles für beide 
Betriebsmöglichkeiten (Akku und Netzteil) konzipiert wurde. \\
\\
\textbf{Mehrere Modi im User-Interface} \\
\\
Es soll möglich sein, dass mehrere voreingestellte Modi im User-Interface ausgewählt werden können. 
Über diese soll es möglich gemacht werden, dass man beispielsweise einen bestimmten Gegenstand 
einer definierten Liste auswählen kann. Darüber soll es dann möglich sein, dass das Ausgabesubsystem 
ja nach eingestelltem Modi die Gegenstände mit der richtigen Intensität greift, ohne, dass diese 
beschädigt oder zerstört beziehungsweise aber auch nicht fallengelassen werden. Ein anderer Modus 
wiederum könnte beispielsweise den Befehl an die Platine senden, dass die Roboterhand in der 
derzeitigen Position halten soll. \\
\\
\textbf{Sicherheit beim Senden von Daten} \\
\\
Es könnte auf eine Verschlüsselung beim Senden von Daten gesetzt werden, damit diese kein 
Unbefugter abfangen und auswerten kann. In unserem Fall stellt es kein Problem dar, dass die 
Daten keine Verschlüsselung besitzen, aber in anderen Bereichen, beispielsweise in der Industrie, 
wird eine zuverlässige und verschlüsselte Übertragung der Daten essenziell sein. Keiner soll 
dadurch das System manipulieren können. \\
\\
\textbf{Größere Analyse von Daten} \\
\\
Durch einen zusätzlichen Datenträger, wie zum Beispiel einer SD-Karte, können Daten dauerhaft 
gespeichert werden. Dadurch wäre es möglich eine Analyse dieser über einen festgelegten Zeitraum 
durchzuführen. Es könnte dadurch herausgefunden werden, wie viel Strom bei einem festgelegten 
Gegenstand beispielsweise bei einer bestimmten Drehung des Servos von der Schaltung verbraucht 
wird. Wenn dies über einige erneut folgende Messungen beinahe gleich ist, dann kein der 
arithmetische Mittelwert herausgefunden werden. Dieser kann dann für bestimmte 
Sicherheitsvorkehrungen verwendet werden. Umso öfter Daten gesammelt und analysiert wurden, umso 
leichter ist es, festzulegen, wann die Schaltung nicht mehr richtig funktioniert. Außerdem kann 
über eine ausführliche Analyse verschiedenster gemessener Werte besser analysiert werden, wie oft 
gewisse Stromspitzen auftreten. \\
\\
\textbf{Mechanische Komponenten kompakter verbauen} \\
\\
Das mechanische Gehäuse für den Motorblock kann kompakter modelliert werden. Des Weiteren ist der 
3D-gedruckte Unterarm etwas zu groß geraten. In Zukunft müsste hier auf Maße geachtet werden, die 
dem menschlichen Unterarm entsprechen, um eine realistischere Darstellung zu gewährleisten. 
In vielen Bereichen des modellierten Roboterarms sind momentan zu viele Lufträume, die bei 
zukünftigen Modellierungen deutlich reduziert werden können. \\
\\
\textbf{Professionell gefertigte mechanische Teile} \\
\\
\textcolor{red}{
Zwar eignet sich der 3D-Druck mit dem Kunstoff PLA für einen Anfangsprototypen, führt jedoch auch dazu, dass die daraus gewonnene Qualität langfristig keine Option ist.
Somit müssen besonders mechanische Komponenten mit Verfahren gefertigt werden, die auch industriell ihre Annerkennung finden. Besonders Zahnräder und Zahnstangen
sollten aus zuverlässigen Kunstoffen oder Metallen bestehen, die belastbar und haltbar sind. Weiters stehen die Finger und deren Glieder unter ständiger Belastung, 
besonders während des Faltvorgangs und müssen demnach auch aus einem härteren Kunststoff gefertigt werden.
}
\\

\newpage
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\section{Abkürzungsverzeichnis}

{\large \textbf{ADC}} Analog-Digital-Wandler \\
\\
{\large \textbf{CAD-Software}} Computer Aided Design Software \\
\\
{\large \textbf{FDM}} Fused Deposition Modelling \\
\\
{\large \textbf{GUI}} Graphical User Interface \\
\\
{\large \textbf{GND}} Ground \\
\\
{\large \textbf{IC}} Integrated Circuit \\
\\
{\large \textbf{I2C}} Inter-Integrated Circuit \\
\\
{\large \textbf{IP-Adresse}} Internet Protocol Address \\
\\
{\large \textbf{MAC-Adresse}} Media Access Control Address \\
\\
{\large \textbf{OPV}} Operationsverstärker \\
\\
{\large \textbf{PCB}} Printed Circuit Board \\
\\
{\large \textbf{PLA}} Polyactid \\
\\
{\large \textbf{SLS}} Selective Laser Sintering \\
\\
{\large \textbf{SMD}} Surface Mount Device \\
\\
{\large \textbf{THT}} Through Hole Technology \\
\\
{\large \textbf{UART}} Universal Asynchronus Receiver / Transmitter \\
\\
{\large \textbf{UI}} User Interface \\
\\
{\large \textbf{USB}} Universal Serial Bus \\
\\
{\large \textbf{WIFI}} Wireless Fidelity \\
\\
{\large \textbf{WLAN}} Wireless Local Area Network \\
\\

\newpage
%==PROJEKTMANAGEMENT=======================================================
\section{Projektmanagement}
\subsection{Projektstrukturplan}

\subsection{Milestoneplan}
\begin{table}[H]
    \centering
    \begin{tabular}{|c|l|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{Milestonenummer} & \textbf{Beschreibung} & \textbf{Fälligkeitsdatum} \\
        \hline
        1 & Lastenheft fertig & 10.10.2023 \\
		\hline
        2 & Kostenkalkulationen fertig & 24.10.2023 \\
		\hline
        3 & Prototypen proof of concept & 21.11.2023 \\
		\hline
        4 & Hardwaredesign fertig & 05.12.2023 \\
		\hline
        5 & PCB-Design fertig & 09.01.2024 \\
		\hline
        6 & Softwareimplementierung für Integrationstest fertig & 30.01.2024 \\
		\hline
        7 & Integration aller Komponenten & 06.02.2024 \\
		\hline
        8 & User Interface fertiggestellt & 13.02.2024 \\
		\hline
        9 & Abnahme durch die Projektbetreuer & 12.03.2024 \\
        \hline
    \end{tabular}
    \caption{Milestoneplan}
    \label{tab:Milestoneplan}
\end{table}

\subsection{Gantt-Diagram}

\newpage
\subsection{Arbeitstunden}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{Datum} & \textbf{Arbeitstunden} & \textbf{Uhrzeit} & \textbf{Person} & \textbf{verrichtete Arbeit} \\
        \hline
		07.09.2023 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Datenbanktexte fertigstellen, mechanische Überlegungen für Roboterhand konkretisieren}} \\
		\hline
		07.09.2023 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Datenbanktexte fertigstellen, mechanische Überlegungen für Roboterhand konkretisieren}} \\
		\hline
		07.09.2023 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Datenbanktexte fertigstellen, mechanische Überlegungen für Roboterhand konkretisieren}} \\
		\hline
		12.09.2023 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Kostenkalkulationen begonnen}} \\
		\hline
		12.09.2023 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Testaufbau der Roboterhand mit Servomotoren, Netzteil und Potentiometern}} \\
		\hline
		12.09.2023 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Platinen fertig bearbeitet und Prof. Fuchsberger zur Inspektion und möglichen Bestellung gegeben}} \\
		\hline
		19.09.2023 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Kostenkalkulationen weitergeführt}} \\
		\hline
		19.09.2023 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Testaufbau der Roboterhand weitergemacht}} \\
		\hline
		19.09.2023 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Hardwaredesign der Messschaltungen für Strom und Spannung mittels ADC}} \\
		\hline
		20.09.2023 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Mindmap für Programmierung erstellt, Software Roadmap erstellt}} \\
		\hline
		20.09.2023 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Testaufbau Roboterhand, Konzept für die Programmierung überlegt}} \\
		\hline  
    \end{tabular}
    \label{tab:Arbeitsstunden1}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{Datum} & \textbf{Arbeitstunden} & \textbf{Uhrzeit} & \textbf{Person} & \textbf{verrichtete Arbeit} \\
        \hline
		20.09.2023 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Hardwareentwicklung Spannungs -und Strommessung, Kicad Schaltplan bearbeiten}} \\
		\hline
		21.09.2023 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Softwareentwicklung, Übertragungsraten der ADCs angeschaut}} \\
		\hline
		21.09.2023 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Überarbeitung der Mechanik}} \\
		\hline
		21.09.2023 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Hardwareentwicklung, Simulationen}} \\
		\hline
		26.09.2023 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Flexsensoren ausmessen}} \\
		\hline
		26.09.2023 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Servomotor ausmessen}} \\
		\hline
		26.09.2023 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{bei beiden Messungen unterstützt}} \\
		\hline 
		27.09.2023 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Ausmessung der Flexsensoren und Dokumentieren der Ergebnisse}} \\
		\hline
		27.09.2023 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Kalibirierung der Roboterhand }} \\
		\hline  
		27.09.2023 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Versuchsaufbau Spannungsmessung mit INA129 und Hardwareentwicklung}} \\
		\hline
		28.09.2023 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Dokumentation und Testen der Flexsensoren}} \\
		\hline
		28.09.2023 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Verbesserung der Roboterhand}} \\
		\hline
		28.09.2023 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Hardwareentwicklung und PCB-Design, Bauteilliste aktualisieren}} \\
		\hline
		03.10.2023 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Software für das Auslesen der Flexsensoren geplant und Strommessung mitaufgebaut}} \\
		\hline
		03.10.2023 & 1,5 & 12:30 - 14:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Strommessschaltung (Servoansteuerung)}} \\
		\hline
	\end{tabular}
    \label{tab:Arbeitsstunden2}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{Datum} & \textbf{Arbeitstunden} & \textbf{Uhrzeit} & \textbf{Person} & \textbf{verrichtete Arbeit} \\
        \hline
		03.10.2023 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Auswertung der Strommessung am Steckbrett}} \\
		\hline
		04.10.2023 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Servomessung und Versuchsaufbau}} \\
		\hline
		04.10.2023 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Servomessung und Versuchsaufbau}} \\
		\hline  
		04.10.2023 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Richtlinien heraussuchen und Pflichtenheft verfasst}} \\
		\hline
		05.10.2023 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Dokumentation der Richtlinien und das Projekthandbuch weitergemacht}} \\
		\hline
		05.10.2023 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Programmierung des User-Interface}} \\
		\hline
		05.10.2023 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Platinen fräsen und in der mechanischen Werkstatt wegen dem Fräsen von Teilen fragen}} \\
		\hline
		10.10.2023 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Platinen gelötet}} \\
		\hline
		10.10.2023 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Roboterhand zusammengebaut }} \\
		\hline
		10.10.2023 & 1,0 & 13:20 - 14:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Dokumentation und Hilfe beim Löten}} \\
		\hline
		11.10.2023 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Platinen gelötet}} \\
		\hline
		11.10.2023 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Roboterhand zusammengebaut }} \\
		\hline  
		11.10.2023 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Dokumentation und Messprotokoll erstellt}} \\
		\hline
		12.10.2023 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Am Programm zum Auslesen der Flexsensoren weitergearbeitet}} \\
		\hline
		12.10.2023 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Roboterhad kalibiriert}} \\
		\hline
		12.10.2023 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Dokumentation und Messprotokolle erstellt}} \\
		\hline
	\end{tabular}
    \label{tab:Arbeitsstunden3}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{Datum} & \textbf{Arbeitstunden} & \textbf{Uhrzeit} & \textbf{Person} & \textbf{verrichtete Arbeit} \\
        \hline
		17.10.2023 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Bestücken der Platinen}} \\
		\hline
		17.10.2023 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Mechanik und erste Überlegungen für die Programmierung}} \\
		\hline
		17.10.2023 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Bestückung der Platinen}} \\
		\hline
		18.10.2023 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Flussdiagramm für die Softwareentwicklung erstellt}} \\
		\hline
		18.10.2023 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Programmierung der Handschuhplatine}} \\
		\hline  
		18.10.2023 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Löten der Platinen}} \\
		\hline
		19.10.2023 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Programmierung der ESPs}} \\
		\hline
		19.10.2023 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Programmierung der ESPs}} \\
		\hline
		19.10.2023 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Löten der Platinen}} \\
		\hline
		24.10.2023 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Programmierung der ESPs und Besprechung des generellen Aufbaus der Programme mit Prof. Diemberger}} \\
		\hline
		24.10.2023 & 0,0 & / & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{/}} \\
		\hline
		24.10.2023 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Löten der Platinen und ausbessern von diversen Fehlern und Kurzschlüssen}} \\
		\hline
		18.10.2023 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Programmierung der Übertragung zwischen zwei ESPs}} \\
		\hline
		18.10.2023 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Programmierung der Übertragung zwischen zwei ESPs}} \\
		\hline  
		18.10.2023 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Löten der Platinen und ausbessern von Fehlern}} \\
		\hline
		07.11.2023 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP32 Programmierung}} \\
		\hline
		07.11.2023 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{ESP32 Programmierung}} \\
		\hline
		07.11.2023 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Letzter Check der Platinen und diese bei JLCPCB bestellt}} \\
		\hline
	\end{tabular}
    \label{tab:Arbeitsstunden4}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{Datum} & \textbf{Arbeitstunden} & \textbf{Uhrzeit} & \textbf{Person} & \textbf{verrichtete Arbeit} \\
        \hline
		09.11.2023 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP32 Programmierung}} \\
		\hline
		09.11.2023 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{ESP32 Programmierung}} \\
		\hline
		09.11.2023 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Dokument "Hardwarebeschreibung" verfasst}} \\
		\hline
		21.11.2023 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Programmierung der drahtlosen Schnittstelle zwischen beiden ESPs}} \\
		\hline
		21.11.2023 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Programmierung der drahtlosen Schnittstelle zwischen beiden ESPs}} \\
		\hline
		21.11.2023 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Testen der neuen Platinen }} \\
		\hline
		22.11.2023 & 0,0 & 11:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Programmierung der Übertragung zwischen zwei ESPs}} \\
		\hline
		22.11.2023 & 4,5 & 11:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Programmierung der Übertragung zwischen zwei ESPs}} \\
		\hline  
		22.11.2023 & 4,5 & 11:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Löten der Platinen und ausbessern von Fehlern}} \\
		\hline
		23.11.2023 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP32 Programmierung und Platinentesting}} \\
		\hline
		23.11.2023 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{ESP32 Programmierung und Platinentesting}} \\
		\hline
		23.11.2023 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Testen und Durchmesen der Platinen gemeinsam mit Softwareüberprüfung}} \\
		\hline
		28.11.2023 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{erste Servoansteuerung mit der neuen Platine}} \\
		\hline
		28.11.2023 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Weiterentwicklung der Roboterhand und erneutes Testen der Handschuhplatine nach beheben eines Lötfehlers}} \\
		\hline
		28.11.2023 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Fehlersuche an den Platinen und Messtabelle für die Messchaltung der Flexsensoren erstellt}} \\
		\hline
	\end{tabular}
    \label{tab:Arbeitsstunden5}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{Datum} & \textbf{Arbeitstunden} & \textbf{Uhrzeit} & \textbf{Person} & \textbf{verrichtete Arbeit} \\
        \hline
		29.11.2023 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Programmierung des ESP Senderprogramms}} \\
		\hline
		29.11.2023 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Programmierung des ESP Empfängerprogramms}} \\
		\hline  
		29.11.2023 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Unterstützung bei der Programmierung}} \\
		\hline
		30.11.2023 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Überlegungen für Algorithmus zur Korrektur der Flexsensortoleranz}} \\
		\hline
		30.11.2023 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Entwicklung des Algorithmus für Fehlerwertkorrektur auf der Roboterhandplatine}} \\
		\hline
		30.11.2023 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{ESPnow Interface testing und Datenübertragung}} \\
		\hline
		05.12.2023 & 1,5 & 12:30 - 14:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Testen der Strommessung der Roboterhandplatine}} \\
		\hline
		05.12.2023 & 0,0 & / & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{/}} \\
		\hline
		05.12.2023 & 1,5 & 12:30 - 14:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Testen der Strommessung der Roboterhandplatine}} \\
		\hline
		06.12.2023 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung}} \\
		\hline
		06.12.2023 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung}} \\
		\hline  
		06.12.2023 & 0,0 & / & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{/}} \\
		\hline
		07.12.2023 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung und erste Inbetriebnahme aller Komponenten gemeinsam}} \\
		\hline
		07.12.2023 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung und erste Inbetriebnahme aller Komponenten gemeinsam}} \\
		\hline
		07.12.2023 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Überprüfung aller Schaltungsteile bei der ersten Komplettinbetriebnahme}} \\
		\hline
		12.12.2023 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung}} \\
		\hline
		12.12.2023 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Roboterhand 3D-Design}} \\
		\hline
	\end{tabular}
    \label{tab:Arbeitsstunden6}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{Datum} & \textbf{Arbeitstunden} & \textbf{Uhrzeit} & \textbf{Person} & \textbf{verrichtete Arbeit} \\
        \hline
		12.12.2023 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Platinendesign letzte Iteration}} \\
		\hline
		13.12.2023 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung}} \\
		\hline
		13.12.2023 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Roboterhand 3D-Design}} \\
		\hline  
		13.12.2023 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Platinendesign letzte Iteration}} \\
		\hline
		14.12.2023 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung}} \\
		\hline
		14.12.2023 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Roboterhand 3D-Design}} \\
		\hline
		14.12.2023 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Platinendesign letzte Iteration}} \\
		\hline
		19.12.2023 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP32 Programmierung}} \\
		\hline
		19.12.2023 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Design der Roboterhand }} \\
		\hline
		19.12.2023 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{UI Programmierung}} \\
		\hline
		20.12.2023 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP32 Programmierung}} \\
		\hline
		20.12.2023 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Design der Roboterhand}} \\
		\hline  
		20.12.2023 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{UI Programmierung}} \\
		\hline
		21.12.2023 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP32 Programmierung}} \\
		\hline
		21.12.2023 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Design der Roboterhand}} \\
		\hline
		21.12.2023 & 0.0 & / & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{/}} \\
		\hline
		09.01.2024 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung}} \\
		\hline
		09.01.2024 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Modelierung der Roboterhand}} \\
		\hline
		09.01.2024 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Handschuh mit Sensoren bestückt und verdrahtet}} \\
		\hline
		10.01.2024 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Handschuhplatine programmiert}} \\
		\hline
		10.01.2024 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{C++ Dateien für Roboterhand zusammengeführt}} \\
		\hline  
		10.01.2024 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{UI Programmierung}} \\
		\hline
		11.01.2024 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung}} \\
		\hline
		11.01.2024 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Roboterhand - 3D Druck}} \\
		\hline
		11.01.2024 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{UI Programmierung}} \\
		\hline
	\end{tabular}
    \label{tab:Arbeitsstunden7}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{Datum} & \textbf{Arbeitstunden} & \textbf{Uhrzeit} & \textbf{Person} & \textbf{verrichtete Arbeit} \\
        \hline
		16.01.2024 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung}} \\
		\hline
		16.01.2024 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung}} \\
		\hline
		16.01.2024 & 3,5 & / & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{/}} \\
		\hline
		17.01.2024 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung}} \\
		\hline
		17.01.2024 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Mechanik der Roboterhand verbessert}} \\
		\hline  
		17.01.2024 & 3,5 & / & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{/}} \\
		\hline
		18.01.2024 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung}} \\
		\hline
		18.01.2024 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung}} \\
		\hline
		18.01.2024 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{finalen Schaltlan der Handschuhplatine erstellt}} \\
		\hline
		23.01.2024 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung}} \\
		\hline
		23.01.2024 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung}} \\
		\hline
		23.01.2024 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung}} \\
		\hline
		24.01.2024 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{ESP Programmierung}} \\
		\hline
		24.01.2024 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Mechanik der Roboterhand zum 3D drucken fertig gemacht}} \\
		\hline
		24.01.2024 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Dokumentation fortgesetzt}} \\
		\hline  
		25.01.2024 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Tag der offenen Tür Projektvorstellung}} \\
		\hline
		25.01.2024 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Tag der offenen Tür Projektvorstellung}} \\
		\hline
		25.01.2024 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Tag der offenen Tür Projektvorstellung}} \\
		\hline
		30.01.2024 & 0,0 & / & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{/}} \\
		\hline
		30.01.2024 & 0,0 & / & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{/}} \\
		\hline
		30.01.2024 & 0,0 & / & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{/}} \\
		\hline
		31.01.2024 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Strommessung der Roboterhandplatine in Betrieb genommen}} \\
		\hline
		31.01.2024 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Zusammenbau der gedruckten Teile der Mechanik}} \\
		\hline
	\end{tabular}
    \label{tab:Arbeitsstunden8}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{Datum} & \textbf{Arbeitstunden} & \textbf{Uhrzeit} & \textbf{Person} & \textbf{verrichtete Arbeit} \\
        \hline
		31.01.2024 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Dokumentation fortgesetzt und beim Zusammenbau der Mechanik geholfen}} \\
		\hline  
		01.02.2024 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Finetuning der Sensorik am Handschuh}} \\
		\hline
		01.02.2024 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Feinsjustierung der Mechanik}} \\
		\hline
		01.02.2024 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Dokumentation fortgeführt und Verbesserungen für die Mechanik überlegt}} \\
		\hline
		13.02.2024 & 0,0 & / & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{/}} \\
		\hline
		13.02.2024 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Feinsjustierung der Mechanik}} \\
		\hline
		13.02.2024 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Dokumentation fortgeführt}} \\
		\hline
		14.02.2024 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		14.02.2024 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		14.02.2024 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline  
		15.02.2024 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		15.02.2024 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		15.02.2024 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		20.02.2024 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		20.02.2024 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Feinjustierung der Mechanik und weiterarbeiten an der Dokumentation}} \\
		\hline
		20.02.2024 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Feinjustierung der Mechanik und weiterarbeiten an der Dokumentation}} \\
		\hline
	\end{tabular}
    \label{tab:Arbeitsstunden9}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{Datum} & \textbf{Arbeitstunden} & \textbf{Uhrzeit} & \textbf{Person} & \textbf{verrichtete Arbeit} \\
        \hline
		21.02.2024 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		21.02.2024 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		21.02.2024 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline  
		22.02.2024 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		22.02.2024 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		22.02.2024 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		27.02.2024 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		27.02.2024 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		27.02.2024 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		28.02.2024 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		28.02.2024 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		28.02.2024 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		29.02.2024 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		29.02.2024 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		29.02.2024 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		05.03.2024 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		05.03.2024 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		05.03.2024 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
	\end{tabular}
    \label{tab:Arbeitsstunden10}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{Datum} & \textbf{Arbeitstunden} & \textbf{Uhrzeit} & \textbf{Person} & \textbf{verrichtete Arbeit} \\
        \hline
		06.03.2024 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		06.03.2024 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		06.03.2024 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		07.03.2024 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		07.03.2024 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		07.03.2024 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		12.03.2024 & 3,5 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Finetuning an der Roboterhand und Adaptierung der Software}} \\
		\hline
		12.03.2024 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Finetuning an der Roboterhand und Adaptierung der Software}} \\
		\hline
		12.03.2024 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		13.03.2024 & 3,5 & 12:30 - 16:00 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{Projekthandbuch für die Werkstatt bearbeitet}} \\
		\hline
		13.03.2024 & 3,5 & 12:30 - 16:00 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{Projekthandbuch für die Werkstatt bearbeitet}} \\
		\hline
		13.03.2024 & 3,5 & 12:30 - 16:00 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{Projekthandbuch für die Werkstatt bearbeitet}} \\
		\hline
		14.03.2024 & 3,5 & 9:50 - 13:20 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		14.03.2024 & 3,5 & 9:50 - 13:20 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		14.03.2024 & 3,5 & 9:50 - 13:20 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		19.03.2024 & 0,0 & 13:20 - 16:50 & Fabian Schweitzer & \fcolorbox{white}{white}{\parbox{5cm}{krank}} \\
		\hline
		19.03.2024 & 3,5 & 13:20 - 16:50 & Amir Al-Maytah & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
		19.03.2024 & 3,5 & 13:20 - 16:50 & Ladislaus Szabo & \fcolorbox{white}{white}{\parbox{5cm}{an der Dokumentation weitergearbeitet}} \\
		\hline
	\end{tabular}
    \label{tab:Arbeitsstunden11}
\end{table}
\hfill \break
\hfill \break
\hfill \break
\textbf{Gesamtstundenanzahl:} \\	
\\
Fabian Schweitzer: 197,5 \\
Amir Al-Maytah: 202 \\
Ladislaus Szabo: 191,5 \\

\newpage
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\section{Programme, Installationen und Plugins}
\subsection{Fusion 360}
\label{chap:Fusion 360}
Fusion 360 ist eine CAD-Software, die es ermöglicht 3D-Modelle zu erstellen, diese zu bearbeiten und anschließend zu exportieren. \\
\\
\subsection{UltiMaker Cura}
\label{chap:UltiMaker Cura}
Ultimaker Cura ist eine Software, die es ermöglicht 3D-Modelle für den 3D-Druck vorzubereiten und Problemstellen auszubessern. Die 
Software bietet einige Einstellmöglichkeiten, wie beispielsweise für das Slicen von Objekten. \\
\\
\subsection{KiCad}
\label{chap:KiCad}
KiCad ist ein Tool zum Erstellen von Schaltplänen und Platinenlayouts. Es können Footprints zugewiesen, Schaltungsfunktionen überprüft und anschließend Bauteile auf einem Platinenmodell angeordnet werden. \\
\\
\subsection{Arduino IDE}
\label{chap:Arduino IDE}
Die Arduino IDE ist eine Entwicklungsumgebung zur Programmierung von Arduino-Mikrokontrollern. Durch diverse Plugins können auch andere Mikrokontroller programmiert werden, wie in unserem Fall der ESP23. \\
\\
\subsection{QT Framework}
\label{chap:QT Framework}
QT ist ein Softwareentwicklungstool, das eine plattformunabhängige Programmierung von Anwendungen ermöglicht. Apps können ohne Änderungen des Quellcodes für Linux, Windows und Mac kompiliert werden. Es können ebenfalls Mobile-Anwendungen
erstellt werden. \\
\\
\newpage
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%==FERTIGUNGSUNTERLAGEN====================================================
\section{Fertigungsunterlagen}
\label{chap:Fertigungsunterlagen}
\subsection{Mechanik}
\label{chap:Fertigungsunterlagen_Mechanik}
\subsubsection{Skizzen ud Konzepte}

\subsubsection{CAD-Zeichnungen}

\subsubsection{3D-Modelle}

\newpage
\subsection{Hardware}
\label{chap:Fertigungsunterlagen_Hardware}
\subsubsection{Skizzen und Konzepte}

\newpage
\subsubsection{Stromlaufpläne}

\includepdf[fitpaper]{/Users/laci/Schule/Diplomarbeit_GitHub/LATEX_DOKU_DA/src/Schaltplan_Handschuh_v1.pdf}
\includepdf[fitpaper]{/Users/laci/Schule/Diplomarbeit_GitHub/LATEX_DOKU_DA/src/Schaltplan_Handschuh_v2.pdf}
\includepdf[fitpaper]{/Users/laci/Schule/Diplomarbeit_GitHub/LATEX_DOKU_DA/src/Schaltplan_Handschuh_v3.pdf}

\includepdf[fitpaper]{/Users/laci/Schule/Diplomarbeit_GitHub/LATEX_DOKU_DA/src/Schaltplan_Roboterhand_v1.pdf}
\includepdf[fitpaper]{/Users/laci/Schule/Diplomarbeit_GitHub/LATEX_DOKU_DA/src/Schaltplan_Roboterhand_v2.pdf}
\includepdf[fitpaper]{/Users/laci/Schule/Diplomarbeit_GitHub/LATEX_DOKU_DA/src/Schaltplan_Roboterhand_v3.pdf}

\subsubsection{Platinenlayouts}
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{PCBlayout_Handschuh_v1}}
		\caption{PCB Layout Eingabesubsystem Version 1}
		\label{fig:PCBlayout_Handschuh_v1}		
	\end{center}
\end{figure}
\pagebreak
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{PCBlayout_Handschuh_v2}}
		\caption{PCB Layout Eingabesubsystem Version 2}
		\label{fig:PCBlayout_Handschuh_v2}		
	\end{center}
\end{figure}
\pagebreak
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{PCBlayout_Handschuh_v3}}
		\caption{PCB Layout Eingabesubsystem Version 3}
		\label{fig:PCBlayout_Handschuh_v3}		
	\end{center}
\end{figure}
\pagebreak
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{PCBlayout_Roboterhand_v1}}
		\caption{PCB Layout Ausgabesubsystem Version 1}
		\label{fig:PCBlayout_Roboterhand_v1}		
	\end{center}
\end{figure}
\pagebreak
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{PCBlayout_Roboterhand_v2}}
		\caption{PCB Layout Ausgabesubsystem Version 2}
		\label{fig:PCBlayout_Roboterhand_v2}		
	\end{center}
\end{figure}
\pagebreak
\begin{figure}[H]
	\begin{center}
		\scalebox{1.2}
		{\includegraphics[width=0.8 \linewidth]{PCBlayout_Roboterhand_v3}}
		\caption{PCB Layout Ausgabesubsystem Version 3}
		\label{fig:PCBlayout_Roboterhand_v3}		
	\end{center}
\end{figure}

\subsubsection{Bestückungslisten}
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{References} & \textbf{Value} & \textbf{Footprint} & \textbf{Quantity} \\
        \hline
		C2, C6 & 10u & \fcolorbox{white}{white}{\parbox{5cm}{C\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 2 \\
		\hline
		C1 & 100n & \fcolorbox{white}{white}{\parbox{5cm}{C\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 1 \\
		\hline
		C7 & 68n & \fcolorbox{white}{white}{\parbox{5cm}{C\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 1 \\
		\hline
		R6, R9, R12, R13, R14 & 10k & \fcolorbox{white}{white}{\parbox{5cm}{C\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 5 \\
		\hline
		R1, R3, R4 & 4k7 & \fcolorbox{white}{white}{\parbox{5cm}{C\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 3 \\
		\hline
		R5 & 120R & \fcolorbox{white}{white}{\parbox{5cm}{C\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 1 \\
		\hline
		R7 & 2k32 & \fcolorbox{white}{white}{\parbox{5cm}{C\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 1 \\
		\hline
		R8 & 1k & \fcolorbox{white}{white}{\parbox{5cm}{C\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 1 \\
		\hline
		R10 & 1k1 & \fcolorbox{white}{white}{\parbox{5cm}{C\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 1 \\
		\hline
		R11 & 240R & \fcolorbox{white}{white}{\parbox{5cm}{C\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 1 \\
		\hline
		U1 & ESP32-WROOM-32 & \fcolorbox{white}{white}{\parbox{5cm}{ESP32-WROOM-32}} & 1 \\
		\hline
		U2 & INA129 & \fcolorbox{white}{white}{\parbox{5cm}{SOIC127P600X175-8N}} & 1 \\
		\hline
		U3 & CH340C & \fcolorbox{white}{white}{\parbox{5cm}{SOIC-16\_3.9x9.9mm \_P1.27mm}} & 1 \\
		\hline
		U5 & AMS1117-3.3 & \fcolorbox{white}{white}{\parbox{5cm}{SOT-223-3\_TabPin2}} & 1 \\
		\hline
		U6 & MAX11613 & \fcolorbox{white}{white}{\parbox{5cm}{MSOP-8\_3x3mm\_P0.65mm}} & 1 \\
		\hline
		SW1, SW2 & SW\_Push\_Dual & \fcolorbox{white}{white}{\parbox{5cm}{SW\_SPST\_TL3305A}} & 2 \\
		\hline
		JP2, JP3, JP4, JP5 & Jumper\_2\_Open & \fcolorbox{white}{white}{\parbox{5cm}{SolderJumper-2\_P1.3mm \_Bridged2Bar\_Pad1.0x1.5mm}} & 4 \\
		\hline
		Q1, Q2 & BC846 & \fcolorbox{white}{white}{\parbox{5cm}{SOT-23}} & 2 \\
		\hline
		IC1 & MUX508IDR & \fcolorbox{white}{white}{\parbox{5cm}{SOIC127P600X175-16N}} & 1 \\
		\hline
		J2, J3, J4, J5, J6 & Conn\_01x02\_Socket & \fcolorbox{white}{white}{\parbox{5cm}{PinSocket\_1x02\_P2.54mm \_Vertical}} & 5 \\
		\hline
	\end{tabular}
	\caption{Betstückungsliste Platine Eingabesubsystem Version 1}
    \label{tab:Bestückungsliste1}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{References} & \textbf{Value} & \textbf{Footprint} & \textbf{Quantity} \\
		\hline
		J7 & Conn\_01x02\_Socket & \fcolorbox{white}{white}{\parbox{5cm}{TerminalBlock\_Phoenix \_MKDS-1,5-2-5.08\_1x02 \_P5.08mm\_Horizontal}} & 1 \\
		\hline
		J8 & USB\_B\_Micro & \fcolorbox{white}{white}{\parbox{5cm}{USB\_Micro-B\_Amphenol \_10103594-0001LF\_Horizontal}} & 1 \\
		\hline
	\end{tabular}
	\caption{Betstückungsliste Platine Eingabesubsystem Version 1}
    \label{tab:Bestückungsliste2}
\end{table}
\pagebreak

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{References} & \textbf{Value} & \textbf{Footprint} & \textbf{Quantity} \\
        \hline
		\fcolorbox{white}{white}{\parbox{5cm}{C1, C4, C5, C6, C8, C11, C12, C13, C15, C16}} & 0.1u & \fcolorbox{white}{white}{\parbox{5cm}{C\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 10 \\
		\hline
		C9, C10 & 22u & \fcolorbox{white}{white}{\parbox{5cm}{C\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 2 \\
		\hline
		C2 & 10u & \fcolorbox{white}{white}{\parbox{5cm}{C\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 1 \\
		\hline
		C3 & 2.2n & \fcolorbox{white}{white}{\parbox{5cm}{C\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 1 \\
		\hline
		C7 & 68n & \fcolorbox{white}{white}{\parbox{5cm}{C\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 1 \\
		\hline
		R6, R13, R14, R15 & 10k & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 4 \\
		\hline
		R2, R16 & 5k1 & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 2 \\
		\hline
		R3, R4 & 4k7 & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 2 \\
		\hline
		R17, R19 & 22R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 2 \\
		\hline
		R18, R20 & 330R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 2 \\
		\hline
		R5 & 120R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 1 \\
		\hline
		R7 & 2k32 & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 1 \\
		\hline
		R8 & 1k & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 1 \\
		\hline
		R9 & 220R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 1 \\
		\hline
		R10 & 1k1 & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 1 \\
		\hline
		R11 & 240R & \fcolorbox{white}{white}{\parbox{5cm}{R\_1206\_3216Metric\_Pad1. 30x1.75mm\_HandSolder}} & 1 \\
		\hline
		R12 & 100R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 1 \\
		\hline
		D2 & D\_POWER & \fcolorbox{white}{white}{\parbox{5cm}{D\_0805\_2012Metric\_Pad1. 15x1.40mm\_HandSolder}} & 1 \\
		\hline
	\end{tabular}
	\caption{Betstückungsliste Platine Eingabesubsystem Version 2}
    \label{tab:Bestückungsliste3}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{References} & \textbf{Value} & \textbf{Footprint} & \textbf{Quantity} \\
        \hline
		D3 & D\_prog1 & \fcolorbox{white}{white}{\parbox{5cm}{D\_0805\_2012Metric\_Pad1. 15x1.40mm\_HandSolder}} & 1 \\
		\hline
		U2 & INA129 & \fcolorbox{white}{white}{\parbox{5cm}{SOIC127P600X175-8N}} & 1 \\
		\hline
		U3 & CH340C & \fcolorbox{white}{white}{\parbox{5cm}{SOIC-16\_3.9x9.9mm \_P1.27mm}} & 1 \\
		\hline
		U4 & MPU-6000 & \fcolorbox{white}{white}{\parbox{5cm}{QFN50P400X400X95-25N}} & 1 \\
		\hline
		U8 & AMS1117-3.3 & \fcolorbox{white}{white}{\parbox{5cm}{SOT-223-3\_TabPin2}} & 1 \\
		\hline
		Q1, Q2 & BC846 & \fcolorbox{white}{white}{\parbox{5cm}{SOT-23}} & 2 \\
		\hline
		S1, S2 & FSM2JSMAATR & \fcolorbox{white}{white}{\parbox{5cm}{FSM2J\_1}} & 2 \\
		\hline
		IC1 & MUX508IDR & \fcolorbox{white}{white}{\parbox{5cm}{SOIC127P600X175-16N}} & 1 \\
		\hline
		IC2 & ESP32-WROOM-32E-N16 & \fcolorbox{white}{white}{\parbox{5cm}{ESP32WROOM32EN16}} & 1 \\
		\hline
		IC4 & MCP3021A5T-E\_OT & \fcolorbox{white}{white}{\parbox{5cm}{SOT95P280X145-5N}} & 1 \\
		\hline
		JP2 & SolderJumper\_2\_Open & \fcolorbox{white}{white}{\parbox{5cm}{SolderJumper-2\_P1.3mm \_Open\_Pad1.0x1.5mm}} & 1 \\
		\hline
		J1, J2 & Conn\_01x05\_Socket & \fcolorbox{white}{white}{\parbox{5cm}{PinSocket\_1x05\_P2.54mm \_Vertical}} & 2 \\
		\hline
		J3 & USB\_C\_Receptacle\_USB2.0 & \fcolorbox{white}{white}{\parbox{5cm}{USB4110GFA}} & 1 \\
		\hline
	\end{tabular}
	\caption{Betstückungsliste Platine Eingabesubsystem Version 2}
    \label{tab:Bestückungsliste4}
\end{table}

\pagebreak

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{References} & \textbf{Value} & \textbf{Footprint} & \textbf{Quantity} \\
        \hline
		\fcolorbox{white}{white}{\parbox{5cm}{C1, C2, C4, C5, C6, C7, C8, C9, C11, C13, C15, C18, C19}} & 100n & \fcolorbox{white}{white}{\parbox{5cm}{C\_0402\_1005Metric}} & 13 \\
		\hline
		C12, C21 & 47u & \fcolorbox{white}{white}{\parbox{5cm}{C\_0402\_1005Metric}} & 2 \\
		\hline
		C17, C26 & 10u & \fcolorbox{white}{white}{\parbox{5cm}{C\_0402\_1005Metric}} & 2 \\
		\hline
		C22, C23 & 4.7u & \fcolorbox{white}{white}{\parbox{5cm}{C\_0402\_1005Metric}} & 2 \\
		\hline
		C3 & 2.2n & \fcolorbox{white}{white}{\parbox{5cm}{C\_0402\_1005Metric}} & 1 \\
		\hline
		C10 & 68n & \fcolorbox{white}{white}{\parbox{5cm}{C\_0402\_1005Metric}} & 1 \\
		\hline
		C20 & 47p & \fcolorbox{white}{white}{\parbox{5cm}{C\_0402\_1005Metric}} & 1 \\
		\hline
		C24 & 680p & \fcolorbox{white}{white}{\parbox{5cm}{C\_0402\_1005Metric}} & 1 \\
		\hline
		\fcolorbox{white}{white}{\parbox{5cm}{R8, R13, R15, R18, R22, R25, R30, R31, R36}} & 10k & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 9 \\
		\hline
		R16, R17, R23 & 4.7k & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 3 \\
		\hline
		R27, R28, R29 & 470R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 3 \\
		\hline
		R32, R33, R34 & 1R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 3 \\
		\hline
		R1, R3 & 5.1k & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 2 \\
		\hline
		R7, R24 & 1k & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 2 \\
		\hline
		R9, R10 & 22R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 2 \\
		\hline
		R11, R12 & 330R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 2 \\
		\hline
		R2 & 240R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 1 \\
		\hline
		R4 & 1.1k & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 1 \\
		\hline
		R5 & 120R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 1 \\
		\hline
		R6 & 2.32k & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 1 \\
		\hline
		R14 & 100R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 1 \\
		\hline
		R19 & 220R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 1 \\
		\hline
		R21 & 30.9k & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 1 \\
		\hline
		R26 & 100k & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 1 \\
		\hline
		R35 & 30k & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 1 \\
		\hline
		L1 & 2.7u & \fcolorbox{white}{white}{\parbox{5cm}{L\_1210\_3225Metric\_Pad1. 42x2.65mm\_HandSolder}} & 1 \\
		\hline
		L2 & 100u & \fcolorbox{white}{white}{\parbox{5cm}{L\_1210\_3225Metric\_Pad1. 42x2.65mm\_HandSolder}} & 1 \\
		\hline
	\end{tabular}
	\caption{Betstückungsliste Platine Eingabesubsystem Version 3}
    \label{tab:Bestückungsliste4}
\end{table}

\pagebreak

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{References} & \textbf{Value} & \textbf{Footprint} & \textbf{Quantity} \\
        \hline
		D3, D5, D6 & LED\_Small & \fcolorbox{white}{white}{\parbox{5cm}{LED\_0402\_1005Metric}} & 3 \\
		\hline
		D1 & D\_prog1 & \fcolorbox{white}{white}{\parbox{5cm}{LED\_0402\_1005Metric}} & 1 \\
		\hline
		D2 & D\_POWER & \fcolorbox{white}{white}{\parbox{5cm}{LED\_0402\_1005Metric}} & 1 \\
		\hline
		D7 & 1N5819 & \fcolorbox{white}{white}{\parbox{5cm}{D\_SOD-123}} & 1 \\
		\hline
		U1 & MPU-6000 & \fcolorbox{white}{white}{\parbox{5cm}{QFN50P400X400X95-25N}} & 1 \\
		\hline
		U2 & MC33063AD & \fcolorbox{white}{white}{\parbox{5cm}{SOIC-8\_3.9x4.9mm\_P1.27mm}} & 1 \\
		\hline
		U3 & INA129 & \fcolorbox{white}{white}{\parbox{5cm}{SOIC127P600X175-8N}} & 1 \\
		\hline
		U4 & CH340C & \fcolorbox{white}{white}{\parbox{5cm}{SOIC-16\_3.9x9.9mm \_P1.27mm}} & 1 \\
		\hline
		U5 & MCP73871 & \fcolorbox{white}{white}{\parbox{5cm}{QFN-20-1EP\_4x4mm \_P0.5mm\_EP2.5x2.5mm}} & 1 \\
		\hline
		SW3, SW4, SW5 & SW\_Push\_Dual & \fcolorbox{white}{white}{\parbox{5cm}{SW4\_PTS815 SJM 250 SMTR LFS\_CNK}} & 3 \\
		\hline
		SW1 & AS11CP & \fcolorbox{white}{white}{\parbox{5cm}{SW\_AS11CP}} & 1 \\
		\hline
		Q1, Q2 & BC846 & \fcolorbox{white}{white}{\parbox{5cm}{SOT-23}} & 2 \\
		\hline
		IC1 & MUX508IDR & \fcolorbox{white}{white}{\parbox{5cm}{SOIC127P600X175-16N}} & 1 \\
		\hline
		IC2 & ESP32-WROOM-32E-N16 & \fcolorbox{white}{white}{\parbox{5cm}{ESP32-WROOM-32D}} & 1 \\
		\hline
		IC3 & MCP3021A5T-E\_OT & \fcolorbox{white}{white}{\parbox{5cm}{SOT95P280X145-5N}} & 1 \\
		\hline
		IC4 & TPS563300DRLR & \fcolorbox{white}{white}{\parbox{5cm}{SOTFL50P160X60-8N}} & 1 \\
		\hline
		TH1 & 10k & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 1 \\
		\hline
		J1 & Conn\_01x06\_Socket & \fcolorbox{white}{white}{\parbox{5cm}{CONN\_SMO6B\_JST}} & 1 \\
		\hline
		J2 & Conn\_01x02\_Socket & \fcolorbox{white}{white}{\parbox{5cm}{CONN\_SM02B-NSHSS\_JST}} & 1 \\
		\hline
		J5 & USB\_C\_Receptacle\_USB2.0 & \fcolorbox{white}{white}{\parbox{5cm}{USB4110GFA}} & 1 \\
		\hline
	\end{tabular}
	\caption{Betstückungsliste Platine Eingabesubsystem Version 3}
    \label{tab:Bestückungsliste4}
\end{table}

\pagebreak

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{References} & \textbf{Value} & \textbf{Footprint} & \textbf{Quantity} \\
        \hline
		C1, C8, C11, C12 & 10u & \fcolorbox{white}{white}{\parbox{5cm}{C\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 4 \\
		\hline
		C3, C4, C5, C7 & 0.1u & \fcolorbox{white}{white}{\parbox{5cm}{C\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 4 \\
		\hline
		C2 & 68n & \fcolorbox{white}{white}{\parbox{5cm}{C\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 1 \\
		\hline
		\fcolorbox{white}{white}{\parbox{4cm}{R1, R2, R8, R15, R17, R18, R19. R20, R21, R22, R27, R28, R40, R47}} & 10k & \fcolorbox{white}{white}{\parbox{5cm}{R\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 14 \\
		\hline
		R29, R41, R42 & 4k7 & \fcolorbox{white}{white}{\parbox{5cm}{R\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 3 \\
		\hline
		R4, R7 & 330m & \fcolorbox{white}{white}{\parbox{5cm}{R\_2512\_6332Metric\_Pad1. 40x3.35mm\_HandSolder}} & 2 \\
		\hline
		R3 & 220R & \fcolorbox{white}{white}{\parbox{5cm}{R\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 1 \\
		\hline
		R9 & 100k & \fcolorbox{white}{white}{\parbox{5cm}{R\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 1 \\
		\hline
		R10 & 6k2 & \fcolorbox{white}{white}{\parbox{5cm}{R\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 1 \\
		\hline
		R13 & 120R & \fcolorbox{white}{white}{\parbox{5cm}{R\_1206\_3216Metric\_Pad1. 33x1.80mm\_HandSolder}} & 1 \\
		\hline
		U1 & PCA9685PW & \fcolorbox{white}{white}{\parbox{5cm}{TSSOP-28\_4.4x9.7mm \_P0.65mm}} & 1 \\
		\hline
		U6 & ESP32-WROOM-32 & \fcolorbox{white}{white}{\parbox{5cm}{ESP32-WROOM-32}} & 1 \\
		\hline
		U7 & CH340C & \fcolorbox{white}{white}{\parbox{5cm}{SOIC-16\_3.9x9.9mm \_P1.27mm}} & 1 \\
		\hline
		U10 & AMS1117-3.3 & \fcolorbox{white}{white}{\parbox{5cm}{SOT-223-3\_TabPin2}} & 1 \\
		\hline
		SW1, SW2 & SW\_Push\_Dual & \fcolorbox{white}{white}{\parbox{5cm}{SW\_SPST\_TL3305A}} & 2 \\
		\hline
		\fcolorbox{white}{white}{\parbox{4cm}{JP1, JP2, JP3, JP4, JP5, JP6, JP7, JP8, JP9, JP10}} & Jumper\_2\_Open & \fcolorbox{white}{white}{\parbox{5cm}{SolderJumper-2\_P1.3mm \_Bridged2Bar\_Pad1.0x1.5mm}} & 10 \\
		\hline
		Q1, Q2 & BC846 & \fcolorbox{white}{white}{\parbox{5cm}{SOT-23}} & 2 \\
		\hline
		IC1 & MUX508IDR & \fcolorbox{white}{white}{\parbox{5cm}{SOIC127P600X175-16N}} & 1 \\
		\hline
		IC2 & MCP3021A5T-E\_OT & \fcolorbox{white}{white}{\parbox{5cm}{SOT95P280X145-5N}} & 1 \\
		\hline
		IC3 & TLV2322ID & \fcolorbox{white}{white}{\parbox{5cm}{SOIC127P600X175-8N}} & 1 \\
		\hline
	\end{tabular}
	\caption{Betstückungsliste Platine Ausgabesubsystem Version 1}
    \label{tab:Bestückungsliste5}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{References} & \textbf{Value} & \textbf{Footprint} & \textbf{Quantity} \\
        \hline
		J1 & Conn\_01x03\_Pin & \fcolorbox{white}{white}{\parbox{5cm}{PinHeader\_1x03\_P2.54mm \_Vertical}} & 1 \\
		\hline
		J5 & USB\_B\_Micro & \fcolorbox{white}{white}{\parbox{5cm}{USB\_Micro-B\_Amphenol \_10103594-0001LF\_Horizontal}} & 1 \\
		\hline
		J7 & Conn\_Coaxial\_Power & \fcolorbox{white}{white}{\parbox{5cm}{BarrelJack\_Horizontal}} & 1 \\
		\hline
	\end{tabular}
	\caption{Betstückungsliste Platine Ausgabesubsystem Version 1}
    \label{tab:Bestückungsliste6}
\end{table}

\pagebreak

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{References} & \textbf{Value} & \textbf{Footprint} & \textbf{Quantity} \\
		\hline
		\fcolorbox{white}{white}{\parbox{5cm}{C1, C4, C5, C6, C8, C11, C12, C13}} & 0.1u & \fcolorbox{white}{white}{\parbox{5cm}{C\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 8 \\
		\hline
		C8, C9 & 22u & \fcolorbox{white}{white}{\parbox{5cm}{C\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 4 \\
		\hline
		C2 & 68n & \fcolorbox{white}{white}{\parbox{5cm}{C\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 1 \\
		\hline
		C7 & 10u & \fcolorbox{white}{white}{\parbox{5cm}{C\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 1 \\
		\hline
		\fcolorbox{white}{white}{\parbox{5cm}{R4, R6, R8, R9, R12, R13, R14, R15, R26, R27, R33, R34}} & 330m & \fcolorbox{white}{white}{\parbox{5cm}{R\_2512\_6332Metric\_Pad1. 40x3.35mm\_HandSolder}} & 12 \\
		\hline
		\fcolorbox{white}{white}{\parbox{5cm}{R1, R2, R16, R17, R18, R19, R20, R21, R29, R32}} & 10k & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 10 \\
		\hline
		\fcolorbox{white}{white}{\parbox{5cm}{R3, R5, R7, R10, R11, R22, R25}} & 220R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 7 \\
		\hline
		R30, R31 & 4k7 & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 2 \\
		\hline
		R35, R36 & 5k1 & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 2 \\
		\hline
		R37, R40 & 22R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 2 \\
		\hline
		R23 & 100k & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 1 \\
		\hline
		R24 & 6k2 & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 1 \\
		\hline
		R28 & 120R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 1 \\
		\hline
		R39 & 100R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0603\_1608Metric\_Pad1. 08x0.95mm\_HandSolder}} & 1 \\
		\hline
		D1 & D\_Power & \fcolorbox{white}{white}{\parbox{5cm}{D\_0805\_2012Metric\_Pad1. 15x1.40mm\_HandSolder}} & 1 \\
		\hline
		D3 & D\_prog1 & \fcolorbox{white}{white}{\parbox{5cm}{D\_0805\_2012Metric\_Pad1. 15x1.40mm\_HandSolder}} & 1 \\
		\hline
		U1 & PCA9685PW & \fcolorbox{white}{white}{\parbox{5cm}{TSSOP-28\_4.4x9.7mm \_P0.65mm}} & 1 \\
		\hline
		U3 & CH340C & \fcolorbox{white}{white}{\parbox{5cm}{SOIC-16\_3.9x9.9mm \_P1.27mm}} & 1 \\
		\hline
	\end{tabular}
\caption{Betstückungsliste Platine Ausgabesubsystem Version 2}
\label{tab:Bestückungsliste7}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{References} & \textbf{Value} & \textbf{Footprint} & \textbf{Quantity} \\
		\hline
		U4 & AMS1117-3.3 & \fcolorbox{white}{white}{\parbox{5cm}{SOT-223-3\_TabPin2}} & 1 \\
		\hline
		\fcolorbox{white}{white}{\parbox{4cm}{JP1, JP2, JP3, JP4, JP5, JP6}} & Jumper\_2\_Open & \fcolorbox{white}{white}{\parbox{5cm}{SolderJumper-2\_P1.3mm \_Bridged2Bar\_Pad1.0x1.5mm}} & 6 \\
		\hline
		Q1, Q2 & BC846 & \fcolorbox{white}{white}{\parbox{5cm}{SOT-23}} & 2 \\
		\hline
		S2, S3 & FSM2JSMAATR & \fcolorbox{white}{white}{\parbox{5cm}{FSM2J\_1}} & 2 \\
		\hline
		IC1 & TLV2322ID & \fcolorbox{white}{white}{\parbox{5cm}{SOIC127P600X175-8N}} & 1 \\
		\hline
		IC2 & MUX508IDR & \fcolorbox{white}{white}{\parbox{5cm}{SOIC127P600X175-16N}} & 1 \\
		\hline
		IC3 & MCP3021A5T-E\_OT & \fcolorbox{white}{white}{\parbox{5cm}{SOT95P280X145-5N}} & 1 \\
		\hline
		IC4 & ESP32-WROOM-32E-N16 & \fcolorbox{white}{white}{\parbox{5cm}{ESP32WROOM32EN16}} & 1 \\
		\hline
		S1 & D3C-1210 & \fcolorbox{white}{white}{\parbox{5cm}{D3C1210}} & 1 \\
		\hline
		\fcolorbox{white}{white}{\parbox{4cm}{J1, J2, J3, J4, J5, J8}} & Conn\_01x03\_Pin & \fcolorbox{white}{white}{\parbox{5cm}{PinHeader\_1x03\_P2.54mm \_Vertical}} & 6 \\
		\hline
		J7 & Conn\_01x02\_Socket & \fcolorbox{white}{white}{\parbox{5cm}{PinHeader\_1x02\_P2.54mm \_Vertical}} & 1 \\
		\hline
		J9 & USB\_C\_Receptacle\_USB2.0 & \fcolorbox{white}{white}{\parbox{5cm}{USB4110GFA}} & 1 \\
		\hline
	\end{tabular}
\caption{Betstückungsliste Platine Ausgabesubsystem Version 2}
\label{tab:Bestückungsliste8}
\end{table}

\pagebreak

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{References} & \textbf{Value} & \textbf{Footprint} & \textbf{Quantity} \\
		\hline
		\fcolorbox{white}{white}{\parbox{3cm}{C1, C2, C7, C8, C9, C10, C11, C12, C14}} & 0.1u & \fcolorbox{white}{white}{\parbox{5cm}{C\_0402\_1005Metric}} & 9 \\
		\hline
		C3, C5 & 22u & \fcolorbox{white}{white}{\parbox{5cm}{C\_0402\_1005Metric}} & 2 \\
		\hline
		C4 & 68n & \fcolorbox{white}{white}{\parbox{5cm}{C\_0402\_1005Metric}} & 1 \\
		\hline
		C6 & 10u & \fcolorbox{white}{white}{\parbox{5cm}{C\_0402\_1005Metric}} & 1 \\
		\hline
		D1 & D\_Power & \fcolorbox{white}{white}{\parbox{5cm}{D\_0805\_2012Metric\_Pad1. 15x1.40mm\_HandSolder}} & 1 \\
		\hline
		D2 & D\_prog1 & \fcolorbox{white}{white}{\parbox{5cm}{D\_0805\_2012Metric\_Pad1. 15x1.40mm\_HandSolder}} & 1 \\
		\hline
		D3 & D\_Zener\_Small & \fcolorbox{white}{white}{\parbox{5cm}{D\_SOD-123}} & 1 \\
		\hline
		H1, H2, H3, H4 & MoutingHole & \fcolorbox{white}{white}{\parbox{5cm}{MountingHole\_3.2mm\_M3 \_DIN965\_Pad\_TopBottom}} & 4 \\
		\hline
		IC1 & MUX508IDR & \fcolorbox{white}{white}{\parbox{5cm}{SOIC127P600X175-16N}} & 1 \\
		\hline
		IC2 & TLV2322ID & \fcolorbox{white}{white}{\parbox{5cm}{SOIC127P600X175-8N}} & 1 \\
		\hline
		IC3 & MCP3021A5T-E\_OT & \fcolorbox{white}{white}{\parbox{5cm}{SOT95P280X145-5N}} & 1 \\
		\hline
		IC4 & ESP32-WROOM-32E-N16 & \fcolorbox{white}{white}{\parbox{5cm}{ESP32WROOM32EN16}} & 1 \\
		\hline
		J1 & Conn\_01x04\_Socket & \fcolorbox{white}{white}{\parbox{5cm}{PinHeader\_1x04\_P2.54mm \_Vertical}} & 1 \\
		\hline
		J9 & USB\_C\_Receptacle\_USB2.0 & \fcolorbox{white}{white}{\parbox{5cm}{USB4110GFA}} & 1 \\
		\hline
		\fcolorbox{white}{white}{\parbox{3cm}{J3, J4, J5, J6, J7, J8, J9, J10}} & Conn\_01x03\_Pin & \fcolorbox{white}{white}{\parbox{5cm}{PinHeader\_1x03\_P2.54mm \_Vertical}} & 8 \\
		\hline
		J11 & Barrel\_Jack & \fcolorbox{white}{white}{\parbox{5cm}{BarrelJack\_CLIFF\_FC681465 S\_SMT\_Horizontal}} & 1 \\
		\hline
		J12 & Conn\_01x03\_Socket & \fcolorbox{white}{white}{\parbox{5cm}{PinSocket\_1x03\_P2.54mm \_Vertical}} & 1 \\
		\hline
		Q1, Q2 & BC846 & \fcolorbox{white}{white}{\parbox{5cm}{SOT-23}} & 2 \\
		\hline
		Q3 & PMOS & \fcolorbox{white}{white}{\parbox{5cm}{TO-252-3\_TabPin2}} & 1 \\
		\hline
		R7, R8 & 5k1 & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 2 \\
		\hline
		R9, R42 & 100k & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 2 \\
		\hline
		R10 & 6k2 & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 1 \\
		\hline
		R11 & 120R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 1 \\
		\hline
		\fcolorbox{white}{white}{\parbox{3cm}{R12, R14, R21, R22, R29, R31, R43, R47}} & 330m & \fcolorbox{white}{white}{\parbox{5cm}{R\_1812\_4532Metric}} & 8 \\
		\hline
	\end{tabular}
\caption{Betstückungsliste Platine Ausgabesubsystem Version 3}
\label{tab:Bestückungsliste9}
\end{table}

\pagebreak

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}  % c für zentrierte Ausrichtung, l für linksbündig
        \hline
        \textbf{References} & \textbf{Value} & \textbf{Footprint} & \textbf{Quantity} \\
		\hline
		\fcolorbox{white}{white}{\parbox{5cm}{R13, R15, R19, R20, R27, R28, R30, R44, R46}} & 220R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 9 \\
		\hline
		\fcolorbox{white}{white}{\parbox{5cm}{R18, R35, R36, R37}} & 10k & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 4 \\
		\hline
		R25, R26 & 4k7 & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 2 \\
		\hline
		R32 & 100R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 1 \\
		\hline
		R38, R39 & 22R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 2 \\
		\hline
		R40, R41 & 330R & \fcolorbox{white}{white}{\parbox{5cm}{R\_0402\_1005Metric}} & 2 \\
		\hline
		SW1, SW2, SW3 & SW\_Push\_Dual & \fcolorbox{white}{white}{\parbox{5cm}{SW4\_PTS815 SJM 250 SMTR LFS\_CNK}} & 3 \\
		\hline
		U1 & PCA9685PW & \fcolorbox{white}{white}{\parbox{5cm}{TSSOP-28\_4.4x9.7mm \_P0.65mm}} & 1 \\
		\hline
		U2 & AMS1117-3.3 & \fcolorbox{white}{white}{\parbox{5cm}{SOT-223-3\_TabPin2}} & 1 \\
		\hline
		U3 & CH340C & \fcolorbox{white}{white}{\parbox{5cm}{SOIC-16\_3.9x9.9mm \_P1.27mm}} & 1 \\
		\hline
	\end{tabular}
\caption{Betstückungsliste Platine Ausgabesubsystem Version 3}
\label{tab:Bestückungsliste10}
\end{table}

\newpage
\subsection{Software}
\label{chap:Fertigungsunterlagen_Software}
\subsubsection{Skizzen und Konzepte}


\subsubsection{Diagramme}
\subsection{Software}
\label{chap:Fertigungsunterlagen_Software}
\subsubsection{Skizzen und Konzepte}


\subsubsection{Code}
\label{chap:Fertigungsunterlagen_Software_Code}
\paragraph{Eingabesubsystem}

\paragraph{Ausgabesubsystem}

\paragraph{User-Interface}

\newpage
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%==VERZEICHNISSE===========================================================
\listoffigures

\newpage

\listoftables

\newpage

\printbibliography

\newpage
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
\end{document}